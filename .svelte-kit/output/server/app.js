import {respond as respond$1} from "@sveltejs/kit/ssr";
import {create_ssr_component, validate_component, missing_component, escape, null_to_empty, add_attribute, subscribe, each} from "svelte/internal";
import {setContext, afterUpdate, onMount, getContext} from "svelte";
import * as cookie from "cookie";
import {v2} from "cloudinary";
import dotenv from "dotenv";
import {getLinkPreview} from "link-preview-js";
import {__extends as __extends$1, __assign, __values as __values$1, __read, __awaiter as __awaiter$7, __generator, __spreadArray, __rest} from "tslib";
import {writable} from "svelte/store";
var root_svelte_svelte_type_style_lang = "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}";
const css$a = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\texport let props_3 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n</script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}>\\n\\t\\t\\t\\t\\t{#if components[3]}\\n\\t\\t\\t\\t\\t\\t<svelte:component this={components[3]} {...(props_3 || {})}/>\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t</svelte:component>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AA2DC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
const Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {stores} = $$props;
  let {page} = $$props;
  let {components} = $$props;
  let {props_0 = null} = $$props;
  let {props_1 = null} = $$props;
  let {props_2 = null} = $$props;
  let {props_3 = null} = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  if ($$props.props_3 === void 0 && $$bindings.props_3 && props_3 !== void 0)
    $$bindings.props_3(props_3);
  $$result.css.add(css$a);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {
        default: () => `${components[3] ? `${validate_component(components[3] || missing_component, "svelte:component").$$render($$result, Object.assign(props_3 || {}), {}, {})}` : ``}`
      })}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1j55zn5"}">${navigated ? `${escape(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var stringToByteArray = function(str) {
  var out = [];
  var p2 = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      out[p2++] = c;
    } else if (c < 2048) {
      out[p2++] = c >> 6 | 192;
      out[p2++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p2++] = c >> 18 | 240;
      out[p2++] = c >> 12 & 63 | 128;
      out[p2++] = c >> 6 & 63 | 128;
      out[p2++] = c & 63 | 128;
    } else {
      out[p2++] = c >> 12 | 224;
      out[p2++] = c >> 6 & 63 | 128;
      out[p2++] = c & 63 | 128;
    }
  }
  return out;
};
var byteArrayToString = function(bytes) {
  var out = [];
  var pos = 0, c = 0;
  while (pos < bytes.length) {
    var c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      var c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      var c4 = bytes[pos++];
      var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c++] = String.fromCharCode(55296 + (u >> 10));
      out[c++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
var base64 = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  encodeByteArray: function(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    var output = [];
    for (var i = 0; i < input.length; i += 3) {
      var byte1 = input[i];
      var haveByte2 = i + 1 < input.length;
      var byte2 = haveByte2 ? input[i + 1] : 0;
      var haveByte3 = i + 2 < input.length;
      var byte3 = haveByte3 ? input[i + 2] : 0;
      var outByte1 = byte1 >> 2;
      var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      var outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  encodeString: function(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray(input), webSafe);
  },
  decodeString: function(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  decodeStringToByteArray: function(input, webSafe) {
    this.init_();
    var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    var output = [];
    for (var i = 0; i < input.length; ) {
      var byte1 = charToByteMap[input.charAt(i++)];
      var haveByte2 = i < input.length;
      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      var haveByte3 = i < input.length;
      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      var haveByte4 = i < input.length;
      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }
      var outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          var outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  init_: function() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (var i = 0; i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};
var base64Decode = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }
  switch (source.constructor) {
    case Date:
      var dateValue = source;
      return new Date(dateValue.getTime());
    case Object:
      if (target === void 0) {
        target = {};
      }
      break;
    case Array:
      target = [];
      break;
    default:
      return source;
  }
  for (var prop in source) {
    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
      continue;
    }
    target[prop] = deepExtend(target[prop], source[prop]);
  }
  return target;
}
function isValidKey(key) {
  return key !== "__proto__";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Deferred = function() {
  function Deferred2() {
    var _this = this;
    this.reject = function() {
    };
    this.resolve = function() {
    };
    this.promise = new Promise(function(resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
  }
  Deferred2.prototype.wrapCallback = function(callback) {
    var _this = this;
    return function(error2, value) {
      if (error2) {
        _this.reject(error2);
      } else {
        _this.resolve(value);
      }
      if (typeof callback === "function") {
        _this.promise.catch(function() {
        });
        if (callback.length === 1) {
          callback(error2);
        } else {
          callback(error2, value);
        }
      }
    };
  };
  return Deferred2;
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isMobileCordova() {
  return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
function isNode() {
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch (e) {
    return false;
  }
}
function isBrowser() {
  return typeof self === "object" && self.self === self;
}
function isBrowserExtension() {
  var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
function isElectron() {
  return getUA().indexOf("Electron/") >= 0;
}
function isIE() {
  var ua2 = getUA();
  return ua2.indexOf("MSIE ") >= 0 || ua2.indexOf("Trident/") >= 0;
}
function isUWP() {
  return getUA().indexOf("MSAppHost/") >= 0;
}
function isIndexedDBAvailable() {
  return "indexedDB" in self && indexedDB != null;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ERROR_NAME = "FirebaseError";
var FirebaseError = function(_super) {
  __extends$1(FirebaseError2, _super);
  function FirebaseError2(code, message, customData) {
    var _this = _super.call(this, message) || this;
    _this.code = code;
    _this.customData = customData;
    _this.name = ERROR_NAME;
    Object.setPrototypeOf(_this, FirebaseError2.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, ErrorFactory.prototype.create);
    }
    return _this;
  }
  return FirebaseError2;
}(Error);
var ErrorFactory = function() {
  function ErrorFactory2(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  ErrorFactory2.prototype.create = function(code) {
    var data = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      data[_i2 - 1] = arguments[_i2];
    }
    var customData = data[0] || {};
    var fullCode = this.service + "/" + code;
    var template2 = this.errors[code];
    var message = template2 ? replaceTemplate(template2, customData) : "Error";
    var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
    var error2 = new FirebaseError(fullCode, fullMessage, customData);
    return error2;
  };
  return ErrorFactory2;
}();
function replaceTemplate(template2, data) {
  return template2.replace(PATTERN, function(_, key) {
    var value = data[key];
    return value != null ? String(value) : "<" + key + "?>";
  });
}
var PATTERN = /\{\$([^}]+)}/g;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isEmpty(obj) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function querystring(querystringParams) {
  var params = [];
  var _loop_1 = function(key2, value2) {
    if (Array.isArray(value2)) {
      value2.forEach(function(arrayVal) {
        params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(value2));
    }
  };
  for (var _i2 = 0, _a2 = Object.entries(querystringParams); _i2 < _a2.length; _i2++) {
    var _b = _a2[_i2], key = _b[0], value = _b[1];
    _loop_1(key, value);
  }
  return params.length ? "&" + params.join("&") : "";
}
function querystringDecode(querystring2) {
  var obj = {};
  var tokens = querystring2.replace(/^\?/, "").split("&");
  tokens.forEach(function(token) {
    if (token) {
      var _a2 = token.split("="), key = _a2[0], value = _a2[1];
      obj[decodeURIComponent(key)] = decodeURIComponent(value);
    }
  });
  return obj;
}
function extractQuerystring(url) {
  var queryStart = url.indexOf("?");
  if (!queryStart) {
    return "";
  }
  var fragmentStart = url.indexOf("#", queryStart);
  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
}
function createSubscribe(executor, onNoObservers) {
  var proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
var ObserverProxy = function() {
  function ObserverProxy2(executor, onNoObservers) {
    var _this = this;
    this.observers = [];
    this.unsubscribes = [];
    this.observerCount = 0;
    this.task = Promise.resolve();
    this.finalized = false;
    this.onNoObservers = onNoObservers;
    this.task.then(function() {
      executor(_this);
    }).catch(function(e) {
      _this.error(e);
    });
  }
  ObserverProxy2.prototype.next = function(value) {
    this.forEachObserver(function(observer) {
      observer.next(value);
    });
  };
  ObserverProxy2.prototype.error = function(error2) {
    this.forEachObserver(function(observer) {
      observer.error(error2);
    });
    this.close(error2);
  };
  ObserverProxy2.prototype.complete = function() {
    this.forEachObserver(function(observer) {
      observer.complete();
    });
    this.close();
  };
  ObserverProxy2.prototype.subscribe = function(nextOrObserver, error2, complete) {
    var _this = this;
    var observer;
    if (nextOrObserver === void 0 && error2 === void 0 && complete === void 0) {
      throw new Error("Missing Observer.");
    }
    if (implementsAnyMethods$1(nextOrObserver, [
      "next",
      "error",
      "complete"
    ])) {
      observer = nextOrObserver;
    } else {
      observer = {
        next: nextOrObserver,
        error: error2,
        complete
      };
    }
    if (observer.next === void 0) {
      observer.next = noop;
    }
    if (observer.error === void 0) {
      observer.error = noop;
    }
    if (observer.complete === void 0) {
      observer.complete = noop;
    }
    var unsub = this.unsubscribeOne.bind(this, this.observers.length);
    if (this.finalized) {
      this.task.then(function() {
        try {
          if (_this.finalError) {
            observer.error(_this.finalError);
          } else {
            observer.complete();
          }
        } catch (e) {
        }
        return;
      });
    }
    this.observers.push(observer);
    return unsub;
  };
  ObserverProxy2.prototype.unsubscribeOne = function(i) {
    if (this.observers === void 0 || this.observers[i] === void 0) {
      return;
    }
    delete this.observers[i];
    this.observerCount -= 1;
    if (this.observerCount === 0 && this.onNoObservers !== void 0) {
      this.onNoObservers(this);
    }
  };
  ObserverProxy2.prototype.forEachObserver = function(fn2) {
    if (this.finalized) {
      return;
    }
    for (var i = 0; i < this.observers.length; i++) {
      this.sendOne(i, fn2);
    }
  };
  ObserverProxy2.prototype.sendOne = function(i, fn2) {
    var _this = this;
    this.task.then(function() {
      if (_this.observers !== void 0 && _this.observers[i] !== void 0) {
        try {
          fn2(_this.observers[i]);
        } catch (e) {
          if (typeof console !== "undefined" && console.error) {
            console.error(e);
          }
        }
      }
    });
  };
  ObserverProxy2.prototype.close = function(err) {
    var _this = this;
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    if (err !== void 0) {
      this.finalError = err;
    }
    this.task.then(function() {
      _this.observers = void 0;
      _this.onNoObservers = void 0;
    });
  };
  return ObserverProxy2;
}();
function implementsAnyMethods$1(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (var _i2 = 0, methods_1 = methods; _i2 < methods_1.length; _i2++) {
    var method = methods_1[_i2];
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
function noop() {
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
var Component = function() {
  function Component2(name2, instanceFactory, type) {
    this.name = name2;
    this.instanceFactory = instanceFactory;
    this.type = type;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  Component2.prototype.setInstantiationMode = function(mode) {
    this.instantiationMode = mode;
    return this;
  };
  Component2.prototype.setMultipleInstances = function(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  };
  Component2.prototype.setServiceProps = function(props) {
    this.serviceProps = props;
    return this;
  };
  Component2.prototype.setInstanceCreatedCallback = function(callback) {
    this.onInstanceCreated = callback;
    return this;
  };
  return Component2;
}();
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Provider = function() {
  function Provider2(name2, container) {
    this.name = name2;
    this.container = container;
    this.component = null;
    this.instances = new Map();
    this.instancesDeferred = new Map();
  }
  Provider2.prototype.get = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      var deferred = new Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          var instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  };
  Provider2.prototype.getImmediate = function(options2) {
    var _a2 = __assign({identifier: DEFAULT_ENTRY_NAME$1, optional: false}, options2), identifier = _a2.identifier, optional = _a2.optional;
    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error("Service " + this.name + " is not available");
      }
    }
  };
  Provider2.prototype.getComponent = function() {
    return this.component;
  };
  Provider2.prototype.setComponent = function(component) {
    var e_1, _a2;
    if (component.name !== this.name) {
      throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
    }
    if (this.component) {
      throw Error("Component for " + this.name + " has already been provided");
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({instanceIdentifier: DEFAULT_ENTRY_NAME$1});
      } catch (e) {
      }
    }
    try {
      for (var _b = __values$1(this.instancesDeferred.entries()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var _d = __read(_c2.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
        try {
          var instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          instanceDeferred.resolve(instance);
        } catch (e) {
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  Provider2.prototype.clearInstance = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    this.instancesDeferred.delete(identifier);
    this.instances.delete(identifier);
  };
  Provider2.prototype.delete = function() {
    return __awaiter$7(this, void 0, void 0, function() {
      var services;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            services = Array.from(this.instances.values());
            return [4, Promise.all(__spreadArray(__spreadArray([], __read(services.filter(function(service) {
              return "INTERNAL" in service;
            }).map(function(service) {
              return service.INTERNAL.delete();
            }))), __read(services.filter(function(service) {
              return "_delete" in service;
            }).map(function(service) {
              return service._delete();
            }))))];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  Provider2.prototype.isComponentSet = function() {
    return this.component != null;
  };
  Provider2.prototype.isInitialized = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    return this.instances.has(identifier);
  };
  Provider2.prototype.initialize = function(opts) {
    var e_2, _a2;
    if (opts === void 0) {
      opts = {};
    }
    var _b = opts.instanceIdentifier, instanceIdentifier = _b === void 0 ? DEFAULT_ENTRY_NAME$1 : _b, _c2 = opts.options, options2 = _c2 === void 0 ? {} : _c2;
    var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(this.name + "(" + normalizedIdentifier + ") has already been initialized");
    }
    if (!this.isComponentSet()) {
      throw Error("Component " + this.name + " has not been registered yet");
    }
    var instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options: options2
    });
    try {
      for (var _d = __values$1(this.instancesDeferred.entries()), _e2 = _d.next(); !_e2.done; _e2 = _d.next()) {
        var _f = __read(_e2.value, 2), instanceIdentifier_1 = _f[0], instanceDeferred = _f[1];
        var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier_1);
        if (normalizedIdentifier === normalizedDeferredIdentifier) {
          instanceDeferred.resolve(instance);
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_e2 && !_e2.done && (_a2 = _d.return))
          _a2.call(_d);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return instance;
  };
  Provider2.prototype.getOrInitializeService = function(_a2) {
    var instanceIdentifier = _a2.instanceIdentifier, _b = _a2.options, options2 = _b === void 0 ? {} : _b;
    var instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options: options2
      });
      this.instances.set(instanceIdentifier, instance);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_c2) {
        }
      }
    }
    return instance || null;
  };
  Provider2.prototype.normalizeInstanceIdentifier = function(identifier) {
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
    } else {
      return identifier;
    }
  };
  Provider2.prototype.shouldAutoInitialize = function() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  };
  return Provider2;
}();
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME$1 ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ComponentContainer = function() {
  function ComponentContainer2(name2) {
    this.name = name2;
    this.providers = new Map();
  }
  ComponentContainer2.prototype.addComponent = function(component) {
    var provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error("Component " + component.name + " has already been registered with " + this.name);
    }
    provider.setComponent(component);
  };
  ComponentContainer2.prototype.addOrOverwriteComponent = function(component) {
    var provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  };
  ComponentContainer2.prototype.getProvider = function(name2) {
    if (this.providers.has(name2)) {
      return this.providers.get(name2);
    }
    var provider = new Provider(name2, this);
    this.providers.set(name2, provider);
    return provider;
  };
  ComponentContainer2.prototype.getProviders = function() {
    return Array.from(this.providers.values());
  };
  return ComponentContainer2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k2 = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k2++)
      r2[k2] = a[j2];
  return r2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a$1;
var instances = [];
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
var levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
var defaultLogLevel = LogLevel.INFO;
var ConsoleMethod = (_a$1 = {}, _a$1[LogLevel.DEBUG] = "log", _a$1[LogLevel.VERBOSE] = "log", _a$1[LogLevel.INFO] = "info", _a$1[LogLevel.WARN] = "warn", _a$1[LogLevel.ERROR] = "error", _a$1);
var defaultLogHandler = function(instance, logType) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  if (logType < instance.logLevel) {
    return;
  }
  var now = new Date().toISOString();
  var method = ConsoleMethod[logType];
  if (method) {
    console[method].apply(console, __spreadArrays(["[" + now + "]  " + instance.name + ":"], args));
  } else {
    throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
  }
};
var Logger = function() {
  function Logger2(name2) {
    this.name = name2;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
    instances.push(this);
  }
  Object.defineProperty(Logger2.prototype, "logLevel", {
    get: function() {
      return this._logLevel;
    },
    set: function(val) {
      if (!(val in LogLevel)) {
        throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
      }
      this._logLevel = val;
    },
    enumerable: false,
    configurable: true
  });
  Logger2.prototype.setLogLevel = function(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  };
  Object.defineProperty(Logger2.prototype, "logHandler", {
    get: function() {
      return this._logHandler;
    },
    set: function(val) {
      if (typeof val !== "function") {
        throw new TypeError("Value assigned to `logHandler` must be a function");
      }
      this._logHandler = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Logger2.prototype, "userLogHandler", {
    get: function() {
      return this._userLogHandler;
    },
    set: function(val) {
      this._userLogHandler = val;
    },
    enumerable: false,
    configurable: true
  });
  Logger2.prototype.debug = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));
    this._logHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));
  };
  Logger2.prototype.log = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));
    this._logHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));
  };
  Logger2.prototype.info = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));
    this._logHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));
  };
  Logger2.prototype.warn = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));
    this._logHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));
  };
  Logger2.prototype.error = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));
    this._logHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));
  };
  return Logger2;
}();
function setLogLevel$3(level) {
  instances.forEach(function(inst) {
    inst.setLogLevel(level);
  });
}
function setUserLogHandler(logCallback, options2) {
  var _loop_1 = function(instance2) {
    var customLogLevel = null;
    if (options2 && options2.level) {
      customLogLevel = levelStringToEnum[options2.level];
    }
    if (logCallback === null) {
      instance2.userLogHandler = null;
    } else {
      instance2.userLogHandler = function(instance3, level) {
        var args = [];
        for (var _i3 = 2; _i3 < arguments.length; _i3++) {
          args[_i3 - 2] = arguments[_i3];
        }
        var message = args.map(function(arg) {
          if (arg == null) {
            return null;
          } else if (typeof arg === "string") {
            return arg;
          } else if (typeof arg === "number" || typeof arg === "boolean") {
            return arg.toString();
          } else if (arg instanceof Error) {
            return arg.message;
          } else {
            try {
              return JSON.stringify(arg);
            } catch (ignored) {
              return null;
            }
          }
        }).filter(function(arg) {
          return arg;
        }).join(" ");
        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance3.logLevel)) {
          logCallback({
            level: LogLevel[level].toLowerCase(),
            message,
            args,
            type: instance3.name
          });
        }
      };
    }
  };
  for (var _i2 = 0, instances_1 = instances; _i2 < instances_1.length; _i2++) {
    var instance = instances_1[_i2];
    _loop_1(instance);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
  constructor(container) {
    this.container = container;
  }
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
}
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
const name$5 = "@firebase/app-exp";
const version$6 = "0.0.900-exp.894b5da5a";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger$1 = new Logger("@firebase/app");
const name$1$1 = "@firebase/app-compat";
const name$2$1 = "@firebase/analytics-compat";
const name$3$1 = "@firebase/analytics-exp";
const name$4$1 = "@firebase/auth-exp";
const name$5$1 = "@firebase/auth-compat";
const name$6 = "@firebase/database";
const name$7 = "@firebase/database-compat";
const name$8 = "@firebase/functions-exp";
const name$9 = "@firebase/functions-compat";
const name$a = "@firebase/installations-exp";
const name$b = "@firebase/installations-compat";
const name$c = "@firebase/messaging-exp";
const name$d = "@firebase/messaging-compat";
const name$e = "@firebase/performance-exp";
const name$f = "@firebase/performance-compat";
const name$g = "@firebase/remote-config-exp";
const name$h = "@firebase/remote-config-compat";
const name$i = "@firebase/storage";
const name$j = "@firebase/storage-compat";
const name$k = "@firebase/firestore";
const name$l = "@firebase/firestore-compat";
const name$m = "firebase-exp";
const version$1$1 = "9.0.0-beta.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = "[DEFAULT]";
const PLATFORM_LOG_STRING = {
  [name$5]: "fire-core",
  [name$1$1]: "fire-core-compat",
  [name$3$1]: "fire-analytics",
  [name$2$1]: "fire-analytics-compat",
  [name$4$1]: "fire-auth",
  [name$5$1]: "fire-auth-compat",
  [name$6]: "fire-rtdb",
  [name$7]: "fire-rtdb-compat",
  [name$8]: "fire-fn",
  [name$9]: "fire-fn-compat",
  [name$a]: "fire-iid",
  [name$b]: "fire-iid-compat",
  [name$c]: "fire-fcm",
  [name$d]: "fire-fcm-compat",
  [name$e]: "fire-perf",
  [name$f]: "fire-perf-compat",
  [name$g]: "fire-rc",
  [name$h]: "fire-rc-compat",
  [name$i]: "fire-gcs",
  [name$j]: "fire-gcs-compat",
  [name$k]: "fire-fst",
  [name$l]: "fire-fst-compat",
  "fire-js": "fire-js",
  [name$m]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _apps = new Map();
const _components = new Map();
function _addComponent(app, component) {
  try {
    app.container.addComponent(component);
  } catch (e) {
    logger$1.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
  }
}
function _addOrOverwriteComponent(app, component) {
  app.container.addOrOverwriteComponent(component);
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger$1.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app of _apps.values()) {
    _addComponent(app, component);
  }
  return true;
}
function _getProvider(app, name2) {
  return app.container.getProvider(name2);
}
function _removeServiceInstance(app, name2, instanceIdentifier = DEFAULT_ENTRY_NAME) {
  _getProvider(app, name2).clearInstance(instanceIdentifier);
}
function _clearComponents() {
  _components.clear();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS$1 = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["bad-app-name"]: "Illegal App name: '{$appName}",
  ["duplicate-app"]: "Firebase App named '{$appName}' already exists",
  ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  ["invalid-log-argument"]: "First argument to `onLog` must be null or a function."
};
const ERROR_FACTORY$1 = new ErrorFactory("app", "Firebase", ERRORS$1);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl$1 {
  constructor(options2, config2, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options2);
    this._name = config2.name;
    this._automaticDataCollectionEnabled = config2.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component("app-exp", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY$1.create("app-deleted", {appName: this._name});
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SDK_VERSION = version$1$1;
function initializeApp(options2, rawConfig = {}) {
  if (typeof rawConfig !== "object") {
    const name3 = rawConfig;
    rawConfig = {name: name3};
  }
  const config2 = Object.assign({name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false}, rawConfig);
  const name2 = config2.name;
  if (typeof name2 !== "string" || !name2) {
    throw ERROR_FACTORY$1.create("bad-app-name", {
      appName: String(name2)
    });
  }
  if (_apps.has(name2)) {
    throw ERROR_FACTORY$1.create("duplicate-app", {appName: name2});
  }
  const container = new ComponentContainer(name2);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl$1(options2, config2, container);
  _apps.set(name2, newApp);
  return newApp;
}
function getApp(name2 = DEFAULT_ENTRY_NAME) {
  const app = _apps.get(name2);
  if (!app) {
    throw ERROR_FACTORY$1.create("no-app", {appName: name2});
  }
  return app;
}
function getApps() {
  return Array.from(_apps.values());
}
async function deleteApp(app) {
  const name2 = app.name;
  if (_apps.has(name2)) {
    _apps.delete(name2);
    await Promise.all(app.container.getProviders().map((provider) => provider.delete()));
    app.isDeleted = true;
  }
}
function registerVersion(libraryKeyOrName, version2, variant) {
  var _a2;
  let library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version2.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version2}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
    }
    logger$1.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({library, version: version2}), "VERSION"));
}
function onLog(logCallback, options2) {
  if (logCallback !== null && typeof logCallback !== "function") {
    throw ERROR_FACTORY$1.create("invalid-log-argument");
  }
  setUserLogHandler(logCallback, options2);
}
function setLogLevel$2(logLevel) {
  setLogLevel$3(logLevel);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents$1(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  registerVersion(name$5, version$6, variant);
  registerVersion("fire-js", "");
}
registerCoreComponents$1();
var modularAPIs = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  SDK_VERSION,
  _DEFAULT_ENTRY_NAME: DEFAULT_ENTRY_NAME,
  _addComponent,
  _addOrOverwriteComponent,
  _apps,
  _clearComponents,
  _components,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  deleteApp,
  getApp,
  getApps,
  initializeApp,
  onLog,
  registerVersion,
  setLogLevel: setLogLevel$2
});
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
  constructor(_delegate, firebase2) {
    this._delegate = _delegate;
    this.firebase = firebase2;
    _addComponent(_delegate, new Component("app-compat", () => this, "PUBLIC"));
    this.container = _delegate.container;
  }
  get automaticDataCollectionEnabled() {
    return this._delegate.automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this._delegate.automaticDataCollectionEnabled = val;
  }
  get name() {
    return this._delegate.name;
  }
  get options() {
    return this._delegate.options;
  }
  delete() {
    return new Promise((resolve) => {
      this._delegate.checkDestroyed();
      resolve();
    }).then(() => {
      this.firebase.INTERNAL.removeApp(this.name);
      return deleteApp(this._delegate);
    });
  }
  _getService(name2, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    this._delegate.checkDestroyed();
    return this._delegate.container.getProvider(name2).getImmediate({
      identifier: instanceIdentifier
    });
  }
  _removeServiceInstance(name2, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    this._delegate.container.getProvider(name2).clearInstance(instanceIdentifier);
  }
  _addComponent(component) {
    _addComponent(this._delegate, component);
  }
  _addOrOverwriteComponent(component) {
    _addOrOverwriteComponent(this._delegate, component);
  }
  toJSON() {
    return {
      name: this.name,
      automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
      options: this.options
    };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance."
};
const ERROR_FACTORY = new ErrorFactory("app-compat", "Firebase", ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createFirebaseNamespaceCore(firebaseAppImpl) {
  const apps = {};
  const namespace = {
    __esModule: true,
    initializeApp: initializeAppCompat,
    app,
    registerVersion,
    setLogLevel: setLogLevel$2,
    onLog,
    apps: null,
    SDK_VERSION,
    INTERNAL: {
      registerComponent: registerComponentCompat,
      removeApp,
      useAsService,
      modularAPIs
    }
  };
  namespace["default"] = namespace;
  Object.defineProperty(namespace, "apps", {
    get: getApps2
  });
  function removeApp(name2) {
    delete apps[name2];
  }
  function app(name2) {
    name2 = name2 || DEFAULT_ENTRY_NAME;
    if (!contains(apps, name2)) {
      throw ERROR_FACTORY.create("no-app", {appName: name2});
    }
    return apps[name2];
  }
  app["App"] = firebaseAppImpl;
  function initializeAppCompat(options2, rawConfig = {}) {
    const app2 = initializeApp(options2, rawConfig);
    const appCompat = new firebaseAppImpl(app2, namespace);
    apps[app2.name] = appCompat;
    return appCompat;
  }
  function getApps2() {
    return Object.keys(apps).map((name2) => apps[name2]);
  }
  function registerComponentCompat(component) {
    const componentName = component.name;
    const componentNameWithoutCompat = componentName.replace("-compat", "");
    if (_registerComponent(component) && component.type === "PUBLIC") {
      const serviceNamespace = (appArg = app()) => {
        if (typeof appArg[componentNameWithoutCompat] !== "function") {
          throw ERROR_FACTORY.create("invalid-app-argument", {
            appName: componentName
          });
        }
        return appArg[componentNameWithoutCompat]();
      };
      if (component.serviceProps !== void 0) {
        deepExtend(serviceNamespace, component.serviceProps);
      }
      namespace[componentNameWithoutCompat] = serviceNamespace;
      firebaseAppImpl.prototype[componentNameWithoutCompat] = function(...args) {
        const serviceFxn = this._getService.bind(this, componentName);
        return serviceFxn.apply(this, component.multipleInstances ? args : []);
      };
    }
    return component.type === "PUBLIC" ? namespace[componentNameWithoutCompat] : null;
  }
  function useAsService(app2, name2) {
    if (name2 === "serverAuth") {
      return null;
    }
    const useService = name2;
    return useService;
  }
  return namespace;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createFirebaseNamespace() {
  const namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
  namespace.INTERNAL = Object.assign(Object.assign({}, namespace.INTERNAL), {
    createFirebaseNamespace,
    extendNamespace,
    createSubscribe,
    ErrorFactory,
    deepExtend
  });
  function extendNamespace(props) {
    deepExtend(namespace, props);
  }
  return namespace;
}
const firebase = createFirebaseNamespace();
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger("@firebase/app-compat");
const name$4 = "@firebase/app-compat";
const version$5 = "0.0.900-exp.894b5da5a";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
  registerVersion(name$4, version$5, variant);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
if (isBrowser() && self.firebase !== void 0) {
  logger.warn(`
    Warning: Firebase is already defined in the global scope. Please make sure
    Firebase library is only loaded once.
  `);
  const sdkVersion = self.firebase.SDK_VERSION;
  if (sdkVersion && sdkVersion.indexOf("LITE") >= 0) {
    logger.warn(`
    Warning: You are trying to load Firebase while using Firebase Performance standalone script.
    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.
    `);
  }
}
const firebase$1 = firebase;
registerCoreComponents();
var name$3 = "firebase-exp";
var version$4 = "9.0.0-beta.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
firebase$1.registerVersion(name$3, version$4, "app-compat");
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _debugErrorMap() {
  return {
    ["admin-restricted-operation"]: "This operation is restricted to administrators only.",
    ["argument-error"]: "",
    ["app-not-authorized"]: "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
    ["app-not-installed"]: "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
    ["captcha-check-failed"]: "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
    ["code-expired"]: "The SMS code has expired. Please re-send the verification code to try again.",
    ["cordova-not-ready"]: "Cordova framework is not ready.",
    ["cors-unsupported"]: "This browser is not supported.",
    ["credential-already-in-use"]: "This credential is already associated with a different user account.",
    ["custom-token-mismatch"]: "The custom token corresponds to a different audience.",
    ["requires-recent-login"]: "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
    ["dependent-sdk-initialized-before-auth"]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.",
    ["dynamic-link-not-activated"]: "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
    ["email-change-needs-verification"]: "Multi-factor users must always have a verified email.",
    ["email-already-in-use"]: "The email address is already in use by another account.",
    ["emulator-config-failed"]: 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "useAuthEmulator()" sooner.',
    ["expired-action-code"]: "The action code has expired.",
    ["cancelled-popup-request"]: "This operation has been cancelled due to another conflicting popup being opened.",
    ["internal-error"]: "An internal AuthError has occurred.",
    ["invalid-app-credential"]: "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
    ["invalid-app-id"]: "The mobile app identifier is not registed for the current project.",
    ["invalid-user-token"]: "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
    ["invalid-auth-event"]: "An internal AuthError has occurred.",
    ["invalid-verification-code"]: "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.",
    ["invalid-continue-uri"]: "The continue URL provided in the request is invalid.",
    ["invalid-cordova-configuration"]: "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
    ["invalid-custom-token"]: "The custom token format is incorrect. Please check the documentation.",
    ["invalid-dynamic-link-domain"]: "The provided dynamic link domain is not configured or authorized for the current project.",
    ["invalid-email"]: "The email address is badly formatted.",
    ["invalid-emulator-scheme"]: "Emulator URL must start with a valid scheme (http:// or https://).",
    ["invalid-api-key"]: "Your API key is invalid, please check you have copied it correctly.",
    ["invalid-cert-hash"]: "The SHA-1 certificate hash provided is invalid.",
    ["invalid-credential"]: "The supplied auth credential is malformed or has expired.",
    ["invalid-message-payload"]: "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
    ["invalid-multi-factor-session"]: "The request does not contain a valid proof of first factor successful sign-in.",
    ["invalid-oauth-provider"]: "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
    ["invalid-oauth-client-id"]: "The OAuth client ID provided is either invalid or does not match the specified API key.",
    ["unauthorized-domain"]: "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
    ["invalid-action-code"]: "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
    ["wrong-password"]: "The password is invalid or the user does not have a password.",
    ["invalid-persistence-type"]: "The specified persistence type is invalid. It can only be local, session or none.",
    ["invalid-phone-number"]: "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
    ["invalid-provider-id"]: "The specified provider ID is invalid.",
    ["invalid-recipient-email"]: "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
    ["invalid-sender"]: "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
    ["invalid-verification-id"]: "The verification ID used to create the phone auth credential is invalid.",
    ["invalid-tenant-id"]: "The Auth instance's tenant ID is invalid.",
    ["missing-android-pkg-name"]: "An Android Package Name must be provided if the Android App is required to be installed.",
    ["auth-domain-config-required"]: "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
    ["missing-app-credential"]: "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
    ["missing-verification-code"]: "The phone auth credential was created with an empty SMS verification code.",
    ["missing-continue-uri"]: "A continue URL must be provided in the request.",
    ["missing-iframe-start"]: "An internal AuthError has occurred.",
    ["missing-ios-bundle-id"]: "An iOS Bundle ID must be provided if an App Store ID is provided.",
    ["missing-or-invalid-nonce"]: "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
    ["missing-multi-factor-info"]: "No second factor identifier is provided.",
    ["missing-multi-factor-session"]: "The request is missing proof of first factor successful sign-in.",
    ["missing-phone-number"]: "To send verification codes, provide a phone number for the recipient.",
    ["missing-verification-id"]: "The phone auth credential was created with an empty verification ID.",
    ["app-deleted"]: "This instance of FirebaseApp has been deleted.",
    ["multi-factor-info-not-found"]: "The user does not have a second factor matching the identifier provided.",
    ["multi-factor-auth-required"]: "Proof of ownership of a second factor is required to complete sign-in.",
    ["account-exists-with-different-credential"]: "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
    ["network-request-failed"]: "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.",
    ["no-auth-event"]: "An internal AuthError has occurred.",
    ["no-such-provider"]: "User was not linked to an account with the given provider.",
    ["null-user"]: "A null user object was provided as the argument for an operation which requires a non-null user object.",
    ["operation-not-allowed"]: "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
    ["operation-not-supported-in-this-environment"]: 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
    ["popup-blocked"]: "Unable to establish a connection with the popup. It may have been blocked by the browser.",
    ["popup-closed-by-user"]: "The popup has been closed by the user before finalizing the operation.",
    ["provider-already-linked"]: "User can only be linked to one identity for the given provider.",
    ["quota-exceeded"]: "The project's quota for this operation has been exceeded.",
    ["redirect-cancelled-by-user"]: "The redirect operation has been cancelled by the user before finalizing.",
    ["redirect-operation-pending"]: "A redirect sign-in operation is already pending.",
    ["rejected-credential"]: "The request contains malformed or mismatching credentials.",
    ["second-factor-already-in-use"]: "The second factor is already enrolled on this account.",
    ["maximum-second-factor-count-exceeded"]: "The maximum allowed number of second factors on a user has been exceeded.",
    ["tenant-id-mismatch"]: "The provided tenant ID does not match the Auth instance's tenant ID",
    ["timeout"]: "The operation has timed out.",
    ["user-token-expired"]: "The user's credential is no longer valid. The user must sign in again.",
    ["too-many-requests"]: "We have blocked all requests from this device due to unusual activity. Try again later.",
    ["unauthorized-continue-uri"]: "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
    ["unsupported-first-factor"]: "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
    ["unsupported-persistence-type"]: "The current environment does not support the specified persistence type.",
    ["unsupported-tenant-operation"]: "This operation is not supported in a multi-tenant context.",
    ["unverified-email"]: "The operation requires a verified email.",
    ["user-cancelled"]: "The user did not grant your application the permissions it requested.",
    ["user-not-found"]: "There is no user record corresponding to this identifier. The user may have been deleted.",
    ["user-disabled"]: "The user account has been disabled by an administrator.",
    ["user-mismatch"]: "The supplied credentials do not correspond to the previously signed in user.",
    ["user-signed-out"]: "",
    ["weak-password"]: "The password must be 6 characters long or more.",
    ["web-storage-unsupported"]: "This browser is not supported or 3rd party cookies and data may be disabled.",
    ["already-initialized"]: "Auth can only be initialized once per app."
  };
}
function _prodErrorMap() {
  return {
    ["dependent-sdk-initialized-before-auth"]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
const debugErrorMap = _debugErrorMap;
const _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient$1 = new Logger("@firebase/auth-exp");
function _logError(msg, ...args) {
  if (logClient$1.logLevel <= LogLevel.ERROR) {
    logClient$1.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _fail(authOrCode, ...rest) {
  throw createErrorInternal(authOrCode, ...rest);
}
function _createError(authOrCode, ...rest) {
  return createErrorInternal(authOrCode, ...rest);
}
function createErrorInternal(authOrCode, ...rest) {
  if (typeof authOrCode !== "string") {
    const code = rest[0];
    const fullParams = [...rest.slice(1)];
    if (fullParams[0]) {
      fullParams[0].appName = authOrCode.name;
    }
    return authOrCode._errorFactory.create(code, ...fullParams);
  }
  return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
function _assert$4(assertion, authOrCode, ...rest) {
  if (!assertion) {
    throw createErrorInternal(authOrCode, ...rest);
  }
}
function debugFail(failure) {
  const message = `INTERNAL ASSERTION FAILED: ` + failure;
  _logError(message);
  throw new Error(message);
}
function debugAssert(assertion, message) {
  if (!assertion) {
    debugFail(message);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instanceCache = new Map();
function _getInstance(cls) {
  debugAssert(cls instanceof Function, "Expected a class definition");
  let instance = instanceCache.get(cls);
  if (instance) {
    debugAssert(instance instanceof cls, "Instance stored in cache mismatched with class");
    return instance;
  }
  instance = new cls();
  instanceCache.set(cls, instance);
  return instance;
}
function _initializeAuthInstance(auth2, deps) {
  const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
  const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
  if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
    auth2._updateErrorMap(deps.errorMap);
  }
  auth2._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getCurrentUrl() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.href) || "";
}
function _isHttpOrHttps$1() {
  return _getCurrentScheme$1() === "http:" || _getCurrentScheme$1() === "https:";
}
function _getCurrentScheme$1() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isOnline() {
  if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && (_isHttpOrHttps$1() || isBrowserExtension() || "connection" in navigator)) {
    return navigator.onLine;
  }
  return true;
}
function _getUserLanguage() {
  if (typeof navigator === "undefined") {
    return null;
  }
  const navigatorLanguage = navigator;
  return navigatorLanguage.languages && navigatorLanguage.languages[0] || navigatorLanguage.language || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Delay {
  constructor(shortDelay, longDelay) {
    this.shortDelay = shortDelay;
    this.longDelay = longDelay;
    debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
    this.isMobile = isMobileCordova() || isReactNative();
  }
  get() {
    if (!_isOnline()) {
      return Math.min(5e3, this.shortDelay);
    }
    return this.isMobile ? this.longDelay : this.shortDelay;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _emulatorUrl(config2, path) {
  debugAssert(config2.emulator, "Emulator should always be set here");
  const {url} = config2.emulator;
  if (!path) {
    return url;
  }
  return `${url}${path.startsWith("/") ? path.slice(1) : path}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FetchProvider {
  static initialize(fetchImpl, headersImpl, responseImpl) {
    this.fetchImpl = fetchImpl;
    if (headersImpl) {
      this.headersImpl = headersImpl;
    }
    if (responseImpl) {
      this.responseImpl = responseImpl;
    }
  }
  static fetch() {
    if (this.fetchImpl) {
      return this.fetchImpl;
    }
    if (typeof self !== "undefined" && "fetch" in self) {
      return self.fetch;
    }
    debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl) {
      return this.headersImpl;
    }
    if (typeof self !== "undefined" && "Headers" in self) {
      return self.Headers;
    }
    debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl) {
      return this.responseImpl;
    }
    if (typeof self !== "undefined" && "Response" in self) {
      return self.Response;
    }
    debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SERVER_ERROR_MAP = {
  ["CREDENTIAL_MISMATCH"]: "custom-token-mismatch",
  ["MISSING_CUSTOM_TOKEN"]: "internal-error",
  ["INVALID_IDENTIFIER"]: "invalid-email",
  ["MISSING_CONTINUE_URI"]: "internal-error",
  ["INVALID_PASSWORD"]: "wrong-password",
  ["MISSING_PASSWORD"]: "internal-error",
  ["EMAIL_EXISTS"]: "email-already-in-use",
  ["PASSWORD_LOGIN_DISABLED"]: "operation-not-allowed",
  ["INVALID_IDP_RESPONSE"]: "invalid-credential",
  ["INVALID_PENDING_TOKEN"]: "invalid-credential",
  ["FEDERATED_USER_ID_ALREADY_LINKED"]: "credential-already-in-use",
  ["MISSING_REQ_TYPE"]: "internal-error",
  ["EMAIL_NOT_FOUND"]: "user-not-found",
  ["RESET_PASSWORD_EXCEED_LIMIT"]: "too-many-requests",
  ["EXPIRED_OOB_CODE"]: "expired-action-code",
  ["INVALID_OOB_CODE"]: "invalid-action-code",
  ["MISSING_OOB_CODE"]: "internal-error",
  ["CREDENTIAL_TOO_OLD_LOGIN_AGAIN"]: "requires-recent-login",
  ["INVALID_ID_TOKEN"]: "invalid-user-token",
  ["TOKEN_EXPIRED"]: "user-token-expired",
  ["USER_NOT_FOUND"]: "user-token-expired",
  ["TOO_MANY_ATTEMPTS_TRY_LATER"]: "too-many-requests",
  ["INVALID_CODE"]: "invalid-verification-code",
  ["INVALID_SESSION_INFO"]: "invalid-verification-id",
  ["INVALID_TEMPORARY_PROOF"]: "invalid-credential",
  ["MISSING_SESSION_INFO"]: "missing-verification-id",
  ["SESSION_EXPIRED"]: "code-expired",
  ["MISSING_ANDROID_PACKAGE_NAME"]: "missing-android-pkg-name",
  ["UNAUTHORIZED_DOMAIN"]: "unauthorized-continue-uri",
  ["INVALID_OAUTH_CLIENT_ID"]: "invalid-oauth-client-id",
  ["ADMIN_ONLY_OPERATION"]: "admin-restricted-operation",
  ["INVALID_MFA_PENDING_CREDENTIAL"]: "invalid-multi-factor-session",
  ["MFA_ENROLLMENT_NOT_FOUND"]: "multi-factor-info-not-found",
  ["MISSING_MFA_ENROLLMENT_ID"]: "missing-multi-factor-info",
  ["MISSING_MFA_PENDING_CREDENTIAL"]: "missing-multi-factor-session",
  ["SECOND_FACTOR_EXISTS"]: "second-factor-already-in-use",
  ["SECOND_FACTOR_LIMIT_EXCEEDED"]: "maximum-second-factor-count-exceeded"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
function _addTidIfNecessary(auth2, request) {
  if (auth2.tenantId && !request.tenantId) {
    return Object.assign(Object.assign({}, request), {tenantId: auth2.tenantId});
  }
  return request;
}
async function _performApiRequest(auth2, method, path, request, customErrorMap = {}) {
  return _performFetchWithErrorHandling(auth2, customErrorMap, () => {
    let body = {};
    let params = {};
    if (request) {
      if (method === "GET") {
        params = request;
      } else {
        body = {
          body: JSON.stringify(request)
        };
      }
    }
    const query = querystring(Object.assign({key: auth2.config.apiKey}, params)).slice(1);
    const headers = new (FetchProvider.headers())();
    headers.set("Content-Type", "application/json");
    headers.set("X-Client-Version", auth2._getSdkClientVersion());
    if (auth2.languageCode) {
      headers.set("X-Firebase-Locale", auth2.languageCode);
    }
    return FetchProvider.fetch()(_getFinalTarget(auth2, auth2.config.apiHost, path, query), Object.assign({
      method,
      headers,
      referrerPolicy: "no-referrer"
    }, body));
  });
}
async function _performFetchWithErrorHandling(auth2, customErrorMap, fetchFn) {
  auth2._canInitEmulator = false;
  const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
  try {
    const networkTimeout = new NetworkTimeout(auth2);
    const response = await Promise.race([
      fetchFn(),
      networkTimeout.promise
    ]);
    networkTimeout.clearNetworkTimeout();
    const json = await response.json();
    if ("needConfirmation" in json) {
      throw _makeTaggedError(auth2, "account-exists-with-different-credential", json);
    }
    if (response.ok && !("errorMessage" in json)) {
      return json;
    } else {
      const errorMessage = response.ok ? json.errorMessage : json.error.message;
      const serverErrorCode = errorMessage.split(" : ")[0];
      if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
        throw _makeTaggedError(auth2, "credential-already-in-use", json);
      } else if (serverErrorCode === "EMAIL_EXISTS") {
        throw _makeTaggedError(auth2, "email-already-in-use", json);
      }
      const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
      _fail(auth2, authError);
    }
  } catch (e) {
    if (e instanceof FirebaseError) {
      throw e;
    }
    _fail(auth2, "network-request-failed");
  }
}
async function _performSignInRequest(auth2, method, path, request, customErrorMap = {}) {
  const serverResponse = await _performApiRequest(auth2, method, path, request, customErrorMap);
  if ("mfaPendingCredential" in serverResponse) {
    _fail(auth2, "multi-factor-auth-required", {
      serverResponse
    });
  }
  return serverResponse;
}
function _getFinalTarget(auth2, host, path, query) {
  const base = `${host}${path}?${query}`;
  if (!auth2.config.emulator) {
    return `${auth2.config.apiScheme}://${base}`;
  }
  return _emulatorUrl(auth2.config, base);
}
class NetworkTimeout {
  constructor(auth2) {
    this.auth = auth2;
    this.timer = null;
    this.promise = new Promise((_, reject) => {
      this.timer = setTimeout(() => {
        return reject(_createError(this.auth, "timeout"));
      }, DEFAULT_API_TIMEOUT_MS.get());
    });
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
}
function _makeTaggedError(auth2, code, response) {
  const errorParams = {
    appName: auth2.name
  };
  if (response.email) {
    errorParams.email = response.email;
  }
  if (response.phoneNumber) {
    errorParams.phoneNumber = response.phoneNumber;
  }
  const error2 = _createError(auth2, code, errorParams);
  error2.customData._tokenResponse = response;
  return error2;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function deleteAccount(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:delete", request);
}
async function deleteLinkedAccounts(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:update", request);
}
async function getAccountInfo(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:lookup", request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function utcTimestampToDateString(utcTimestamp) {
  if (!utcTimestamp) {
    return void 0;
  }
  try {
    const date = new Date(Number(utcTimestamp));
    if (!isNaN(date.getTime())) {
      return date.toUTCString();
    }
  } catch (e) {
  }
  return void 0;
}
async function getIdTokenResult(user, forceRefresh = false) {
  const userInternal = getModularInstance(user);
  const token = await userInternal.getIdToken(forceRefresh);
  const claims = _parseToken(token);
  _assert$4(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error");
  const firebase2 = typeof claims.firebase === "object" ? claims.firebase : void 0;
  const signInProvider = firebase2 === null || firebase2 === void 0 ? void 0 : firebase2["sign_in_provider"];
  return {
    claims,
    token,
    authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
    issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
    expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
    signInProvider: signInProvider || null,
    signInSecondFactor: (firebase2 === null || firebase2 === void 0 ? void 0 : firebase2["sign_in_second_factor"]) || null
  };
}
function secondsStringToMilliseconds(seconds) {
  return Number(seconds) * 1e3;
}
function _parseToken(token) {
  const [algorithm, payload, signature] = token.split(".");
  if (algorithm === void 0 || payload === void 0 || signature === void 0) {
    _logError("JWT malformed, contained fewer than 3 sections");
    return null;
  }
  try {
    const decoded = base64Decode(payload);
    if (!decoded) {
      _logError("Failed to decode base64 JWT payload");
      return null;
    }
    return JSON.parse(decoded);
  } catch (e) {
    _logError("Caught error parsing JWT payload as JSON", e);
    return null;
  }
}
function _tokenExpiresIn(token) {
  const parsedToken = _parseToken(token);
  _assert$4(parsedToken, "internal-error");
  _assert$4(typeof parsedToken.exp !== "undefined", "internal-error");
  _assert$4(typeof parsedToken.iat !== "undefined", "internal-error");
  return Number(parsedToken.exp) - Number(parsedToken.iat);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {
  if (bypassAuthState) {
    return promise;
  }
  try {
    return await promise;
  } catch (e) {
    if (e instanceof FirebaseError && isUserInvalidated(e)) {
      if (user.auth.currentUser === user) {
        await user.auth.signOut();
      }
    }
    throw e;
  }
}
function isUserInvalidated({code}) {
  return code === `auth/${"user-disabled"}` || code === `auth/${"user-token-expired"}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProactiveRefresh {
  constructor(user) {
    this.user = user;
    this.isRunning = false;
    this.timerId = null;
    this.errorBackoff = 3e4;
  }
  _start() {
    if (this.isRunning) {
      return;
    }
    this.isRunning = true;
    this.schedule();
  }
  _stop() {
    if (!this.isRunning) {
      return;
    }
    this.isRunning = false;
    if (this.timerId !== null) {
      clearTimeout(this.timerId);
    }
  }
  getInterval(wasError) {
    var _a2;
    if (wasError) {
      const interval = this.errorBackoff;
      this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4);
      return interval;
    } else {
      this.errorBackoff = 3e4;
      const expTime = (_a2 = this.user.stsTokenManager.expirationTime) !== null && _a2 !== void 0 ? _a2 : 0;
      const interval = expTime - Date.now() - 3e5;
      return Math.max(0, interval);
    }
  }
  schedule(wasError = false) {
    if (!this.isRunning) {
      return;
    }
    const interval = this.getInterval(wasError);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, interval);
  }
  async iteration() {
    try {
      await this.user.getIdToken(true);
    } catch (e) {
      if (e.code === `auth/${"network-request-failed"}`) {
        this.schedule(true);
      }
      return;
    }
    this.schedule();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserMetadata {
  constructor(createdAt, lastLoginAt) {
    this.createdAt = createdAt;
    this.lastLoginAt = lastLoginAt;
    this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
    this.creationTime = utcTimestampToDateString(this.createdAt);
  }
  _copy(metadata) {
    this.createdAt = metadata.createdAt;
    this.lastLoginAt = metadata.lastLoginAt;
    this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reloadWithoutSaving(user) {
  var _a2;
  const auth2 = user.auth;
  const idToken = await user.getIdToken();
  const response = await _logoutIfInvalidated(user, getAccountInfo(auth2, {idToken}));
  _assert$4(response === null || response === void 0 ? void 0 : response.users.length, auth2, "internal-error");
  const coreAccount = response.users[0];
  user._notifyReloadListener(coreAccount);
  const newProviderData = ((_a2 = coreAccount.providerUserInfo) === null || _a2 === void 0 ? void 0 : _a2.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
  const providerData = mergeProviderData(user.providerData, newProviderData);
  const oldIsAnonymous = user.isAnonymous;
  const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
  const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
  const updates = {
    uid: coreAccount.localId,
    displayName: coreAccount.displayName || null,
    photoURL: coreAccount.photoUrl || null,
    email: coreAccount.email || null,
    emailVerified: coreAccount.emailVerified || false,
    phoneNumber: coreAccount.phoneNumber || null,
    tenantId: coreAccount.tenantId || null,
    providerData,
    metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
    isAnonymous
  };
  Object.assign(user, updates);
}
async function reload(user) {
  const userInternal = getModularInstance(user);
  await _reloadWithoutSaving(userInternal);
  await userInternal.auth._persistUserIfCurrent(userInternal);
  userInternal.auth._notifyListenersIfCurrent(userInternal);
}
function mergeProviderData(original, newData) {
  const deduped = original.filter((o) => !newData.some((n2) => n2.providerId === o.providerId));
  return [...deduped, ...newData];
}
function extractProviderData(providers) {
  return providers.map((_a2) => {
    var {providerId} = _a2, provider = __rest(_a2, ["providerId"]);
    return {
      providerId,
      uid: provider.rawId || "",
      displayName: provider.displayName || null,
      email: provider.email || null,
      phoneNumber: provider.phoneNumber || null,
      photoURL: provider.photoUrl || null
    };
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function requestStsToken(auth2, refreshToken) {
  const response = await _performFetchWithErrorHandling(auth2, {}, () => {
    const body = querystring({
      "grant_type": "refresh_token",
      "refresh_token": refreshToken
    }).slice(1);
    const {tokenApiHost, apiKey} = auth2.config;
    const url = _getFinalTarget(auth2, tokenApiHost, "/v1/token", `key=${apiKey}`);
    return FetchProvider.fetch()(url, {
      method: "POST",
      headers: {
        "X-Client-Version": auth2._getSdkClientVersion(),
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
  });
  return {
    accessToken: response.access_token,
    expiresIn: response.expires_in,
    refreshToken: response.refresh_token
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StsTokenManager {
  constructor() {
    this.refreshToken = null;
    this.accessToken = null;
    this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(response) {
    _assert$4(response.idToken, "internal-error");
    _assert$4(typeof response.idToken !== "undefined", "internal-error");
    _assert$4(typeof response.refreshToken !== "undefined", "internal-error");
    const expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
    this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
  }
  async getToken(auth2, forceRefresh = false) {
    _assert$4(!this.accessToken || this.refreshToken, auth2, "user-token-expired");
    if (!forceRefresh && this.accessToken && !this.isExpired) {
      return this.accessToken;
    }
    if (this.refreshToken) {
      await this.refresh(auth2, this.refreshToken);
      return this.accessToken;
    }
    return null;
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(auth2, oldToken) {
    const {accessToken, refreshToken, expiresIn} = await requestStsToken(auth2, oldToken);
    this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
  }
  updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
    this.refreshToken = refreshToken || null;
    this.accessToken = accessToken || null;
    this.expirationTime = Date.now() + expiresInSec * 1e3;
  }
  static fromJSON(appName, object) {
    const {refreshToken, accessToken, expirationTime} = object;
    const manager = new StsTokenManager();
    if (refreshToken) {
      _assert$4(typeof refreshToken === "string", "internal-error", {
        appName
      });
      manager.refreshToken = refreshToken;
    }
    if (accessToken) {
      _assert$4(typeof accessToken === "string", "internal-error", {
        appName
      });
      manager.accessToken = accessToken;
    }
    if (expirationTime) {
      _assert$4(typeof expirationTime === "number", "internal-error", {
        appName
      });
      manager.expirationTime = expirationTime;
    }
    return manager;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(stsTokenManager) {
    this.accessToken = stsTokenManager.accessToken;
    this.refreshToken = stsTokenManager.refreshToken;
    this.expirationTime = stsTokenManager.expirationTime;
  }
  _clone() {
    return Object.assign(new StsTokenManager(), this.toJSON());
  }
  _performRefresh() {
    return debugFail("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assertStringOrUndefined(assertion, appName) {
  _assert$4(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", {appName});
}
class UserImpl {
  constructor(_a2) {
    var {uid, auth: auth2, stsTokenManager} = _a2, opt = __rest(_a2, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase";
    this.emailVerified = false;
    this.isAnonymous = false;
    this.tenantId = null;
    this.providerData = [];
    this.proactiveRefresh = new ProactiveRefresh(this);
    this.reloadUserInfo = null;
    this.reloadListener = null;
    this.uid = uid;
    this.auth = auth2;
    this.stsTokenManager = stsTokenManager;
    this.accessToken = stsTokenManager.accessToken;
    this.displayName = opt.displayName || null;
    this.email = opt.email || null;
    this.phoneNumber = opt.phoneNumber || null;
    this.photoURL = opt.photoURL || null;
    this.isAnonymous = opt.isAnonymous || false;
    this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
  }
  async getIdToken(forceRefresh) {
    const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
    _assert$4(accessToken, this.auth, "internal-error");
    if (this.accessToken !== accessToken) {
      this.accessToken = accessToken;
      await this.auth._persistUserIfCurrent(this);
      this.auth._notifyListenersIfCurrent(this);
    }
    return accessToken;
  }
  getIdTokenResult(forceRefresh) {
    return getIdTokenResult(this, forceRefresh);
  }
  reload() {
    return reload(this);
  }
  _assign(user) {
    if (this === user) {
      return;
    }
    _assert$4(this.uid === user.uid, this.auth, "internal-error");
    this.displayName = user.displayName;
    this.photoURL = user.photoURL;
    this.email = user.email;
    this.emailVerified = user.emailVerified;
    this.phoneNumber = user.phoneNumber;
    this.isAnonymous = user.isAnonymous;
    this.tenantId = user.tenantId;
    this.providerData = user.providerData.map((userInfo) => Object.assign({}, userInfo));
    this.metadata._copy(user.metadata);
    this.stsTokenManager._assign(user.stsTokenManager);
  }
  _clone(auth2) {
    return new UserImpl(Object.assign(Object.assign({}, this), {auth: auth2, stsTokenManager: this.stsTokenManager._clone()}));
  }
  _onReload(callback) {
    _assert$4(!this.reloadListener, this.auth, "internal-error");
    this.reloadListener = callback;
    if (this.reloadUserInfo) {
      this._notifyReloadListener(this.reloadUserInfo);
      this.reloadUserInfo = null;
    }
  }
  _notifyReloadListener(userInfo) {
    if (this.reloadListener) {
      this.reloadListener(userInfo);
    } else {
      this.reloadUserInfo = userInfo;
    }
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(response, reload2 = false) {
    let tokensRefreshed = false;
    if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
      this.stsTokenManager.updateFromServerResponse(response);
      tokensRefreshed = true;
    }
    if (reload2) {
      await _reloadWithoutSaving(this);
    }
    await this.auth._persistUserIfCurrent(this);
    if (tokensRefreshed) {
      this.auth._notifyListenersIfCurrent(this);
    }
  }
  async delete() {
    const idToken = await this.getIdToken();
    await _logoutIfInvalidated(this, deleteAccount(this.auth, {idToken}));
    this.stsTokenManager.clearRefreshToken();
    return this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((userInfo) => Object.assign({}, userInfo)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(auth2, object) {
    var _a2, _b, _c2, _d, _e2, _f, _g, _h2;
    const displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : void 0;
    const email = (_b = object.email) !== null && _b !== void 0 ? _b : void 0;
    const phoneNumber = (_c2 = object.phoneNumber) !== null && _c2 !== void 0 ? _c2 : void 0;
    const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : void 0;
    const tenantId = (_e2 = object.tenantId) !== null && _e2 !== void 0 ? _e2 : void 0;
    const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : void 0;
    const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : void 0;
    const lastLoginAt = (_h2 = object.lastLoginAt) !== null && _h2 !== void 0 ? _h2 : void 0;
    const {uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager} = object;
    _assert$4(uid && plainObjectTokenManager, auth2, "internal-error");
    const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
    _assert$4(typeof uid === "string", auth2, "internal-error");
    assertStringOrUndefined(displayName, auth2.name);
    assertStringOrUndefined(email, auth2.name);
    _assert$4(typeof emailVerified === "boolean", auth2, "internal-error");
    _assert$4(typeof isAnonymous === "boolean", auth2, "internal-error");
    assertStringOrUndefined(phoneNumber, auth2.name);
    assertStringOrUndefined(photoURL, auth2.name);
    assertStringOrUndefined(tenantId, auth2.name);
    assertStringOrUndefined(_redirectEventId, auth2.name);
    assertStringOrUndefined(createdAt, auth2.name);
    assertStringOrUndefined(lastLoginAt, auth2.name);
    const user = new UserImpl({
      uid,
      auth: auth2,
      email,
      emailVerified,
      displayName,
      isAnonymous,
      photoURL,
      phoneNumber,
      tenantId,
      stsTokenManager,
      createdAt,
      lastLoginAt
    });
    if (providerData && Array.isArray(providerData)) {
      user.providerData = providerData.map((userInfo) => Object.assign({}, userInfo));
    }
    if (_redirectEventId) {
      user._redirectEventId = _redirectEventId;
    }
    return user;
  }
  static async _fromIdTokenResponse(auth2, idTokenResponse, isAnonymous = false) {
    const stsTokenManager = new StsTokenManager();
    stsTokenManager.updateFromServerResponse(idTokenResponse);
    const user = new UserImpl({
      uid: idTokenResponse.localId,
      auth: auth2,
      stsTokenManager,
      isAnonymous
    });
    await _reloadWithoutSaving(user);
    return user;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InMemoryPersistence {
  constructor() {
    this.type = "NONE";
    this.storage = {};
  }
  async _isAvailable() {
    return true;
  }
  async _set(key, value) {
    this.storage[key] = value;
  }
  async _get(key) {
    const value = this.storage[key];
    return value === void 0 ? null : value;
  }
  async _remove(key) {
    delete this.storage[key];
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
}
InMemoryPersistence.type = "NONE";
const inMemoryPersistence = InMemoryPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _persistenceKeyName(key, apiKey, appName) {
  return `${"firebase"}:${key}:${apiKey}:${appName}`;
}
class PersistenceUserManager {
  constructor(persistence, auth2, userKey) {
    this.persistence = persistence;
    this.auth = auth2;
    this.userKey = userKey;
    const {config: config2, name: name2} = this.auth;
    this.fullUserKey = _persistenceKeyName(this.userKey, config2.apiKey, name2);
    this.fullPersistenceKey = _persistenceKeyName("persistence", config2.apiKey, name2);
    this.boundEventHandler = auth2._onStorageEvent.bind(auth2);
    this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(user) {
    return this.persistence._set(this.fullUserKey, user.toJSON());
  }
  async getCurrentUser() {
    const blob = await this.persistence._get(this.fullUserKey);
    return blob ? UserImpl._fromJSON(this.auth, blob) : null;
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(newPersistence) {
    if (this.persistence === newPersistence) {
      return;
    }
    const currentUser = await this.getCurrentUser();
    await this.removeCurrentUser();
    this.persistence = newPersistence;
    if (currentUser) {
      return this.setCurrentUser(currentUser);
    }
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(auth2, persistenceHierarchy, userKey = "authUser") {
    if (!persistenceHierarchy.length) {
      return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth2, userKey);
    }
    let chosenPersistence = _getInstance(inMemoryPersistence);
    for (const persistence of persistenceHierarchy) {
      if (await persistence._isAvailable()) {
        chosenPersistence = persistence;
        break;
      }
    }
    let userToMigrate = null;
    const key = _persistenceKeyName(userKey, auth2.config.apiKey, auth2.name);
    for (const persistence of persistenceHierarchy) {
      try {
        const blob = await persistence._get(key);
        if (blob) {
          const user = UserImpl._fromJSON(auth2, blob);
          if (persistence !== chosenPersistence) {
            userToMigrate = user;
          }
          break;
        }
      } catch (_a2) {
      }
    }
    if (userToMigrate) {
      await chosenPersistence._set(key, userToMigrate.toJSON());
    }
    await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (persistence !== chosenPersistence) {
        try {
          await persistence._remove(key);
        } catch (_a2) {
        }
      }
    }));
    return new PersistenceUserManager(chosenPersistence, auth2, userKey);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getBrowserName(userAgent) {
  const ua2 = userAgent.toLowerCase();
  if (ua2.includes("opera/") || ua2.includes("opr/") || ua2.includes("opios/")) {
    return "Opera";
  } else if (_isIEMobile(ua2)) {
    return "IEMobile";
  } else if (ua2.includes("msie") || ua2.includes("trident/")) {
    return "IE";
  } else if (ua2.includes("edge/")) {
    return "Edge";
  } else if (_isFirefox(ua2)) {
    return "Firefox";
  } else if (ua2.includes("silk/")) {
    return "Silk";
  } else if (_isBlackBerry(ua2)) {
    return "Blackberry";
  } else if (_isWebOS(ua2)) {
    return "Webos";
  } else if (_isSafari(ua2)) {
    return "Safari";
  } else if ((ua2.includes("chrome/") || _isChromeIOS(ua2)) && !ua2.includes("edge/")) {
    return "Chrome";
  } else if (_isAndroid(ua2)) {
    return "Android";
  } else {
    const re2 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
    const matches = userAgent.match(re2);
    if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
      return matches[1];
    }
  }
  return "Other";
}
function _isFirefox(ua2 = getUA()) {
  return /firefox\//i.test(ua2);
}
function _isSafari(userAgent = getUA()) {
  const ua2 = userAgent.toLowerCase();
  return ua2.includes("safari/") && !ua2.includes("chrome/") && !ua2.includes("crios/") && !ua2.includes("android");
}
function _isChromeIOS(ua2 = getUA()) {
  return /crios\//i.test(ua2);
}
function _isIEMobile(ua2 = getUA()) {
  return /iemobile/i.test(ua2);
}
function _isAndroid(ua2 = getUA()) {
  return /android/i.test(ua2);
}
function _isBlackBerry(ua2 = getUA()) {
  return /blackberry/i.test(ua2);
}
function _isWebOS(ua2 = getUA()) {
  return /webos/i.test(ua2);
}
function _isIOS(ua2 = getUA()) {
  return /iphone|ipad|ipod/i.test(ua2);
}
function _isIOS7Or8(ua2 = getUA()) {
  return /(iPad|iPhone|iPod).*OS 7_\d/i.test(ua2) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(ua2);
}
function _isIOSStandalone(ua2 = getUA()) {
  var _a2;
  return _isIOS(ua2) && !!((_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.standalone);
}
function _isIE10() {
  return isIE() && document.documentMode === 10;
}
function _isMobileBrowser(ua2 = getUA()) {
  return _isIOS(ua2) || _isAndroid(ua2) || _isWebOS(ua2) || _isBlackBerry(ua2) || /windows phone/i.test(ua2) || _isIEMobile(ua2);
}
function _isIframe() {
  try {
    return !!(window && window !== window.top);
  } catch (e) {
    return false;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getClientVersion(clientPlatform, frameworks = []) {
  let reportedPlatform;
  switch (clientPlatform) {
    case "Browser":
      reportedPlatform = _getBrowserName(getUA());
      break;
    case "Worker":
      reportedPlatform = `${_getBrowserName(getUA())}-${clientPlatform}`;
      break;
    default:
      reportedPlatform = clientPlatform;
  }
  const reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
  return `${reportedPlatform}/${"JsCore"}/${SDK_VERSION}/${reportedFrameworks}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthImpl {
  constructor(app, config2) {
    this.app = app;
    this.config = config2;
    this.currentUser = null;
    this.emulatorConfig = null;
    this.operations = Promise.resolve();
    this.authStateSubscription = new Subscription(this);
    this.idTokenSubscription = new Subscription(this);
    this.redirectUser = null;
    this.isProactiveRefreshEnabled = false;
    this.redirectInitializerError = null;
    this._canInitEmulator = true;
    this._isInitialized = false;
    this._deleted = false;
    this._initializationPromise = null;
    this._popupRedirectResolver = null;
    this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
    this.lastNotifiedUid = void 0;
    this.languageCode = null;
    this.tenantId = null;
    this.settings = {appVerificationDisabledForTesting: false};
    this.frameworks = [];
    this.name = app.name;
    this.clientVersion = config2.sdkClientVersion;
  }
  _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
    if (popupRedirectResolver) {
      this._popupRedirectResolver = _getInstance(popupRedirectResolver);
    }
    this._initializationPromise = this.queue(async () => {
      var _a2;
      if (this._deleted) {
        return;
      }
      this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
      if (this._deleted) {
        return;
      }
      if ((_a2 = this._popupRedirectResolver) === null || _a2 === void 0 ? void 0 : _a2._shouldInitProactively) {
        await this._popupRedirectResolver._initialize(this);
      }
      await this.initializeCurrentUser(popupRedirectResolver);
      if (this._deleted) {
        return;
      }
      this._isInitialized = true;
    });
    return this._initializationPromise.then(() => {
      if (this.redirectInitializerError) {
        throw this.redirectInitializerError;
      }
    });
  }
  async _onStorageEvent() {
    if (this._deleted) {
      return;
    }
    const user = await this.assertedPersistence.getCurrentUser();
    if (!this.currentUser && !user) {
      return;
    }
    if (this.currentUser && user && this.currentUser.uid === user.uid) {
      this._currentUser._assign(user);
      await this.currentUser.getIdToken();
      return;
    }
    await this._updateCurrentUser(user);
  }
  async initializeCurrentUser(popupRedirectResolver) {
    var _a2;
    let storedUser = await this.assertedPersistence.getCurrentUser();
    if (popupRedirectResolver && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const redirectUserEventId = (_a2 = this.redirectUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId;
      const storedUserEventId = storedUser === null || storedUser === void 0 ? void 0 : storedUser._redirectEventId;
      const result = await this.tryRedirectSignIn(popupRedirectResolver);
      if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
        storedUser = result.user;
      }
    }
    if (!storedUser) {
      return this.directlySetCurrentUser(null);
    }
    if (!storedUser._redirectEventId) {
      return this.reloadAndSetCurrentUserOrClear(storedUser);
    }
    _assert$4(this._popupRedirectResolver, this, "argument-error");
    await this.getOrInitRedirectPersistenceManager();
    if (this.redirectUser && this.redirectUser._redirectEventId === storedUser._redirectEventId) {
      return this.directlySetCurrentUser(storedUser);
    }
    return this.reloadAndSetCurrentUserOrClear(storedUser);
  }
  async tryRedirectSignIn(redirectResolver) {
    let result = null;
    try {
      result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
    } catch (e) {
      this.redirectInitializerError = e;
      await this._setRedirectUser(null);
    }
    return result;
  }
  async reloadAndSetCurrentUserOrClear(user) {
    try {
      await _reloadWithoutSaving(user);
    } catch (e) {
      if (e.code !== `auth/${"network-request-failed"}`) {
        return this.directlySetCurrentUser(null);
      }
    }
    return this.directlySetCurrentUser(user);
  }
  useDeviceLanguage() {
    this.languageCode = _getUserLanguage();
  }
  async _delete() {
    this._deleted = true;
  }
  async updateCurrentUser(userExtern) {
    const user = userExtern ? getModularInstance(userExtern) : null;
    if (user) {
      _assert$4(user.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token");
    }
    return this._updateCurrentUser(user && user._clone(this));
  }
  async _updateCurrentUser(user) {
    if (this._deleted) {
      return;
    }
    if (user) {
      _assert$4(this.tenantId === user.tenantId, this, "tenant-id-mismatch");
    }
    return this.queue(async () => {
      await this.directlySetCurrentUser(user);
      this.notifyAuthListeners();
    });
  }
  async signOut() {
    if (this.redirectPersistenceManager || this._popupRedirectResolver) {
      await this._setRedirectUser(null);
    }
    return this._updateCurrentUser(null);
  }
  setPersistence(persistence) {
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(_getInstance(persistence));
    });
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type;
  }
  _updateErrorMap(errorMap) {
    this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
  }
  onAuthStateChanged(nextOrObserver, error2, completed) {
    return this.registerStateListener(this.authStateSubscription, nextOrObserver, error2, completed);
  }
  onIdTokenChanged(nextOrObserver, error2, completed) {
    return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error2, completed);
  }
  toJSON() {
    var _a2;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2.toJSON()
    };
  }
  async _setRedirectUser(user, popupRedirectResolver) {
    const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
    return user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user);
  }
  async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
    if (!this.redirectPersistenceManager) {
      const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
      _assert$4(resolver, this, "argument-error");
      this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser");
      this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(id2) {
    var _a2, _b;
    if (this._isInitialized) {
      await this.queue(async () => {
      });
    }
    if (((_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId) === id2) {
      return this._currentUser;
    }
    if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id2) {
      return this.redirectUser;
    }
    return null;
  }
  async _persistUserIfCurrent(user) {
    if (user === this.currentUser) {
      return this.queue(async () => this.directlySetCurrentUser(user));
    }
  }
  _notifyListenersIfCurrent(user) {
    if (user === this.currentUser) {
      this.notifyAuthListeners();
    }
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = true;
    if (this.currentUser) {
      this._currentUser._startProactiveRefresh();
    }
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = false;
    if (this.currentUser) {
      this._currentUser._stopProactiveRefresh();
    }
  }
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var _a2, _b;
    if (!this._isInitialized) {
      return;
    }
    this.idTokenSubscription.next(this.currentUser);
    const currentUid = (_b = (_a2 = this.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) !== null && _b !== void 0 ? _b : null;
    if (this.lastNotifiedUid !== currentUid) {
      this.lastNotifiedUid = currentUid;
      this.authStateSubscription.next(this.currentUser);
    }
  }
  registerStateListener(subscription, nextOrObserver, error2, completed) {
    if (this._deleted) {
      return () => {
      };
    }
    const cb2 = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next;
    const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    _assert$4(promise, this, "internal-error");
    promise.then(() => cb2(this.currentUser));
    if (typeof nextOrObserver === "function") {
      return subscription.addObserver(nextOrObserver, error2, completed);
    } else {
      return subscription.addObserver(nextOrObserver);
    }
  }
  async directlySetCurrentUser(user) {
    if (this.currentUser && this.currentUser !== user) {
      this._currentUser._stopProactiveRefresh();
      if (user && this.isProactiveRefreshEnabled) {
        user._startProactiveRefresh();
      }
    }
    this.currentUser = user;
    if (user) {
      await this.assertedPersistence.setCurrentUser(user);
    } else {
      await this.assertedPersistence.removeCurrentUser();
    }
  }
  queue(action) {
    this.operations = this.operations.then(action, action);
    return this.operations;
  }
  get assertedPersistence() {
    _assert$4(this.persistenceManager, this, "internal-error");
    return this.persistenceManager;
  }
  _logFramework(framework) {
    if (this.frameworks.includes(framework)) {
      return;
    }
    this.frameworks.push(framework);
    this.frameworks.sort();
    this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
  }
  _getFrameworks() {
    return this.frameworks;
  }
  _getSdkClientVersion() {
    return this.clientVersion;
  }
}
function _castAuth(auth2) {
  return getModularInstance(auth2);
}
class Subscription {
  constructor(auth2) {
    this.auth = auth2;
    this.observer = null;
    this.addObserver = createSubscribe((observer) => this.observer = observer);
  }
  get next() {
    _assert$4(this.observer, this.auth, "internal-error");
    return this.observer.next.bind(this.observer);
  }
}
function useAuthEmulator(auth2, url, options2) {
  const authInternal = _castAuth(auth2);
  _assert$4(authInternal._canInitEmulator, authInternal, "emulator-config-failed");
  _assert$4(/^https?:\/\//.test(url), authInternal, "invalid-emulator-scheme");
  const disableWarnings = !!(options2 === null || options2 === void 0 ? void 0 : options2.disableWarnings);
  const protocol = extractProtocol(url);
  const {host, port} = extractHostAndPort(url);
  const portStr = port === null ? "" : `:${port}`;
  authInternal.config.emulator = {url: `${protocol}//${host}${portStr}/`};
  authInternal.settings.appVerificationDisabledForTesting = true;
  authInternal.emulatorConfig = Object.freeze({
    host,
    port,
    protocol: protocol.replace(":", ""),
    options: Object.freeze({disableWarnings})
  });
  emitEmulatorWarning(disableWarnings);
}
function extractProtocol(url) {
  const protocolEnd = url.indexOf(":");
  return protocolEnd < 0 ? "" : url.substr(0, protocolEnd + 1);
}
function extractHostAndPort(url) {
  const protocol = extractProtocol(url);
  const authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length));
  if (!authority) {
    return {host: "", port: null};
  }
  const hostAndPort = authority[2].split("@").pop() || "";
  const bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
  if (bracketedIPv6) {
    const host = bracketedIPv6[1];
    return {host, port: parsePort(hostAndPort.substr(host.length + 1))};
  } else {
    const [host, port] = hostAndPort.split(":");
    return {host, port: parsePort(port)};
  }
}
function parsePort(portStr) {
  if (!portStr) {
    return null;
  }
  const port = Number(portStr);
  if (isNaN(port)) {
    return null;
  }
  return port;
}
function emitEmulatorWarning(disableBanner) {
  function attachBanner() {
    const el = document.createElement("p");
    const sty = el.style;
    el.innerText = "Running in emulator mode. Do not use with production credentials.";
    sty.position = "fixed";
    sty.width = "100%";
    sty.backgroundColor = "#ffffff";
    sty.border = ".1em solid #000000";
    sty.color = "#ff0000";
    sty.bottom = "0px";
    sty.left = "0px";
    sty.margin = "0px";
    sty.zIndex = "10000";
    sty.textAlign = "center";
    el.classList.add("firebase-emulator-warning");
    document.body.appendChild(el);
  }
  if (typeof console !== "undefined" && typeof console.info === "function") {
    console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
  }
  if (typeof window !== "undefined" && typeof document !== "undefined" && !disableBanner) {
    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", attachBanner);
    } else {
      attachBanner();
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthCredential {
  constructor(providerId, signInMethod) {
    this.providerId = providerId;
    this.signInMethod = signInMethod;
  }
  toJSON() {
    return debugFail("not implemented");
  }
  _getIdTokenResponse(_auth) {
    return debugFail("not implemented");
  }
  _linkToIdToken(_auth, _idToken) {
    return debugFail("not implemented");
  }
  _getReauthenticationResolver(_auth) {
    return debugFail("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function resetPassword(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:resetPassword", _addTidIfNecessary(auth2, request));
}
async function updateEmailPassword(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:update", request);
}
async function applyActionCode(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:update", _addTidIfNecessary(auth2, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithPassword(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithPassword", _addTidIfNecessary(auth2, request));
}
async function sendOobCode(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:sendOobCode", _addTidIfNecessary(auth2, request));
}
async function sendEmailVerification(auth2, request) {
  return sendOobCode(auth2, request);
}
async function sendPasswordResetEmail(auth2, request) {
  return sendOobCode(auth2, request);
}
async function sendSignInLinkToEmail(auth2, request) {
  return sendOobCode(auth2, request);
}
async function verifyAndChangeEmail(auth2, request) {
  return sendOobCode(auth2, request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithEmailLink(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth2, request));
}
async function signInWithEmailLinkForLinking(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth2, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmailAuthCredential extends AuthCredential {
  constructor(_email, _password, signInMethod, _tenantId = null) {
    super("password", signInMethod);
    this._email = _email;
    this._password = _password;
    this._tenantId = _tenantId;
  }
  static _fromEmailAndPassword(email, password) {
    return new EmailAuthCredential(email, password, "password");
  }
  static _fromEmailAndCode(email, oobCode, tenantId = null) {
    return new EmailAuthCredential(email, oobCode, "emailLink", tenantId);
  }
  toJSON() {
    return {
      email: this._email,
      password: this._password,
      signInMethod: this.signInMethod,
      tenantId: this._tenantId
    };
  }
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
      if (obj.signInMethod === "password") {
        return this._fromEmailAndPassword(obj.email, obj.password);
      } else if (obj.signInMethod === "emailLink") {
        return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
      }
    }
    return null;
  }
  async _getIdTokenResponse(auth2) {
    switch (this.signInMethod) {
      case "password":
        return signInWithPassword(auth2, {
          returnSecureToken: true,
          email: this._email,
          password: this._password
        });
      case "emailLink":
        return signInWithEmailLink(auth2, {
          email: this._email,
          oobCode: this._password
        });
      default:
        _fail(auth2, "internal-error");
    }
  }
  async _linkToIdToken(auth2, idToken) {
    switch (this.signInMethod) {
      case "password":
        return updateEmailPassword(auth2, {
          idToken,
          returnSecureToken: true,
          email: this._email,
          password: this._password
        });
      case "emailLink":
        return signInWithEmailLinkForLinking(auth2, {
          idToken,
          email: this._email,
          oobCode: this._password
        });
      default:
        _fail(auth2, "internal-error");
    }
  }
  _getReauthenticationResolver(auth2) {
    return this._getIdTokenResponse(auth2);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithIdp(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(auth2, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI = "http://localhost";
class OAuthCredential extends AuthCredential {
  constructor() {
    super(...arguments);
    this.pendingToken = null;
  }
  static _fromParams(params) {
    const cred = new OAuthCredential(params.providerId, params.signInMethod);
    if (params.idToken || params.accessToken) {
      if (params.idToken) {
        cred.idToken = params.idToken;
      }
      if (params.accessToken) {
        cred.accessToken = params.accessToken;
      }
      if (params.nonce && !params.pendingToken) {
        cred.nonce = params.nonce;
      }
      if (params.pendingToken) {
        cred.pendingToken = params.pendingToken;
      }
    } else if (params.oauthToken && params.oauthTokenSecret) {
      cred.accessToken = params.oauthToken;
      cred.secret = params.oauthTokenSecret;
    } else {
      _fail("argument-error");
    }
    return cred;
  }
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    const {providerId, signInMethod} = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
    if (!providerId || !signInMethod) {
      return null;
    }
    const cred = new OAuthCredential(providerId, signInMethod);
    Object.assign(cred, rest);
    return cred;
  }
  _getIdTokenResponse(auth2) {
    const request = this.buildRequest();
    return signInWithIdp(auth2, request);
  }
  _linkToIdToken(auth2, idToken) {
    const request = this.buildRequest();
    request.idToken = idToken;
    return signInWithIdp(auth2, request);
  }
  _getReauthenticationResolver(auth2) {
    const request = this.buildRequest();
    request.autoCreate = false;
    return signInWithIdp(auth2, request);
  }
  buildRequest() {
    const request = {
      requestUri: IDP_REQUEST_URI,
      returnSecureToken: true
    };
    if (this.pendingToken) {
      request.pendingToken = this.pendingToken;
    } else {
      const postBody = {};
      if (this.idToken) {
        postBody["id_token"] = this.idToken;
      }
      if (this.accessToken) {
        postBody["access_token"] = this.accessToken;
      }
      if (this.secret) {
        postBody["oauth_token_secret"] = this.secret;
      }
      postBody["providerId"] = this.providerId;
      if (this.nonce && !this.pendingToken) {
        postBody["nonce"] = this.nonce;
      }
      request.postBody = querystring(postBody);
    }
    return request;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendPhoneVerificationCode(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:sendVerificationCode", _addTidIfNecessary(auth2, request));
}
async function signInWithPhoneNumber(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth2, request));
}
async function linkWithPhoneNumber(auth2, request) {
  const response = await _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth2, request));
  if (response.temporaryProof) {
    throw _makeTaggedError(auth2, "account-exists-with-different-credential", response);
  }
  return response;
}
const VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {
  ["USER_NOT_FOUND"]: "user-not-found"
};
async function verifyPhoneNumberForExisting(auth2, request) {
  const apiRequest = Object.assign(Object.assign({}, request), {operation: "REAUTH"});
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth2, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PhoneAuthCredential extends AuthCredential {
  constructor(params) {
    super("phone", "phone");
    this.params = params;
  }
  static _fromVerification(verificationId, verificationCode) {
    return new PhoneAuthCredential({verificationId, verificationCode});
  }
  static _fromTokenResponse(phoneNumber, temporaryProof) {
    return new PhoneAuthCredential({phoneNumber, temporaryProof});
  }
  _getIdTokenResponse(auth2) {
    return signInWithPhoneNumber(auth2, this._makeVerificationRequest());
  }
  _linkToIdToken(auth2, idToken) {
    return linkWithPhoneNumber(auth2, Object.assign({idToken}, this._makeVerificationRequest()));
  }
  _getReauthenticationResolver(auth2) {
    return verifyPhoneNumberForExisting(auth2, this._makeVerificationRequest());
  }
  _makeVerificationRequest() {
    const {temporaryProof, phoneNumber, verificationId, verificationCode} = this.params;
    if (temporaryProof && phoneNumber) {
      return {temporaryProof, phoneNumber};
    }
    return {
      sessionInfo: verificationId,
      code: verificationCode
    };
  }
  toJSON() {
    const obj = {
      providerId: this.providerId
    };
    if (this.params.phoneNumber) {
      obj.phoneNumber = this.params.phoneNumber;
    }
    if (this.params.temporaryProof) {
      obj.temporaryProof = this.params.temporaryProof;
    }
    if (this.params.verificationCode) {
      obj.verificationCode = this.params.verificationCode;
    }
    if (this.params.verificationId) {
      obj.verificationId = this.params.verificationId;
    }
    return obj;
  }
  static fromJSON(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    const {verificationId, verificationCode, phoneNumber, temporaryProof} = json;
    if (!verificationCode && !verificationId && !phoneNumber && !temporaryProof) {
      return null;
    }
    return new PhoneAuthCredential({
      verificationId,
      verificationCode,
      phoneNumber,
      temporaryProof
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parseMode(mode) {
  switch (mode) {
    case "recoverEmail":
      return "RECOVER_EMAIL";
    case "resetPassword":
      return "PASSWORD_RESET";
    case "signIn":
      return "EMAIL_SIGNIN";
    case "verifyEmail":
      return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
      return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
      return "REVERT_SECOND_FACTOR_ADDITION";
    default:
      return null;
  }
}
function parseDeepLink(url) {
  const link = querystringDecode(extractQuerystring(url))["link"];
  const doubleDeepLink = link ? querystringDecode(extractQuerystring(link))["deep_link_id"] : null;
  const iOSDeepLink = querystringDecode(extractQuerystring(url))["deep_link_id"];
  const iOSDoubleDeepLink = iOSDeepLink ? querystringDecode(extractQuerystring(iOSDeepLink))["link"] : null;
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
class ActionCodeURL {
  constructor(actionLink) {
    var _a2, _b, _c2, _d, _e2, _f;
    const searchParams = querystringDecode(extractQuerystring(actionLink));
    const apiKey = (_a2 = searchParams["apiKey"]) !== null && _a2 !== void 0 ? _a2 : null;
    const code = (_b = searchParams["oobCode"]) !== null && _b !== void 0 ? _b : null;
    const operation = parseMode((_c2 = searchParams["mode"]) !== null && _c2 !== void 0 ? _c2 : null);
    _assert$4(apiKey && code && operation, "argument-error");
    this.apiKey = apiKey;
    this.operation = operation;
    this.code = code;
    this.continueUrl = (_d = searchParams["continueUrl"]) !== null && _d !== void 0 ? _d : null;
    this.languageCode = (_e2 = searchParams["languageCode"]) !== null && _e2 !== void 0 ? _e2 : null;
    this.tenantId = (_f = searchParams["tenantId"]) !== null && _f !== void 0 ? _f : null;
  }
  static parseLink(link) {
    const actionLink = parseDeepLink(link);
    try {
      return new ActionCodeURL(actionLink);
    } catch (_a2) {
      return null;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmailAuthProvider {
  constructor() {
    this.providerId = EmailAuthProvider.PROVIDER_ID;
  }
  static credential(email, password) {
    return EmailAuthCredential._fromEmailAndPassword(email, password);
  }
  static credentialWithLink(email, emailLink) {
    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
    _assert$4(actionCodeUrl, "argument-error");
    return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
  }
}
EmailAuthProvider.PROVIDER_ID = "password";
EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FederatedAuthProvider {
  constructor(providerId) {
    this.providerId = providerId;
    this.defaultLanguageCode = null;
    this.customParameters = {};
  }
  setDefaultLanguage(languageCode) {
    this.defaultLanguageCode = languageCode;
  }
  setCustomParameters(customOAuthParameters) {
    this.customParameters = customOAuthParameters;
    return this;
  }
  getCustomParameters() {
    return this.customParameters;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseOAuthProvider extends FederatedAuthProvider {
  constructor() {
    super(...arguments);
    this.scopes = [];
  }
  addScope(scope) {
    if (!this.scopes.includes(scope)) {
      this.scopes.push(scope);
    }
    return this;
  }
  getScopes() {
    return [...this.scopes];
  }
}
class OAuthProvider extends BaseOAuthProvider {
  static credentialFromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    _assert$4("providerId" in obj && "signInMethod" in obj, "argument-error");
    return OAuthCredential._fromParams(obj);
  }
  credential(params) {
    return this._credential(params);
  }
  _credential(params) {
    _assert$4(params.idToken || params.accessToken, "argument-error");
    return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), {providerId: this.providerId, signInMethod: this.providerId}));
  }
  static credentialFromResult(userCredential) {
    return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return OAuthProvider.oauthCredentialFromTaggedObject(error2.customData || {});
  }
  static oauthCredentialFromTaggedObject({_tokenResponse: tokenResponse}) {
    if (!tokenResponse) {
      return null;
    }
    const {oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId} = tokenResponse;
    if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
      return null;
    }
    if (!providerId) {
      return null;
    }
    try {
      return new OAuthProvider(providerId)._credential({
        idToken: oauthIdToken,
        accessToken: oauthAccessToken,
        rawNonce: nonce,
        pendingToken
      });
    } catch (e) {
      return null;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FacebookAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("facebook.com");
  }
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: FacebookAuthProvider.PROVIDER_ID,
      signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return FacebookAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({_tokenResponse: tokenResponse}) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a2) {
      return null;
    }
  }
}
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
FacebookAuthProvider.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GoogleAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("google.com");
    this.addScope("profile");
  }
  static credential(idToken, accessToken) {
    return OAuthCredential._fromParams({
      providerId: GoogleAuthProvider.PROVIDER_ID,
      signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
      idToken,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return GoogleAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({_tokenResponse: tokenResponse}) {
    if (!tokenResponse) {
      return null;
    }
    const {oauthIdToken, oauthAccessToken} = tokenResponse;
    if (!oauthIdToken && !oauthAccessToken) {
      return null;
    }
    try {
      return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
    } catch (_a2) {
      return null;
    }
  }
}
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com";
GoogleAuthProvider.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GithubAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("github.com");
  }
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: GithubAuthProvider.PROVIDER_ID,
      signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return GithubAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return GithubAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({_tokenResponse: tokenResponse}) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a2) {
      return null;
    }
  }
}
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com";
GithubAuthProvider.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI$1 = "http://localhost";
class SAMLAuthCredential extends AuthCredential {
  constructor(providerId, pendingToken) {
    super(providerId, providerId);
    this.pendingToken = pendingToken;
  }
  _getIdTokenResponse(auth2) {
    const request = this.buildRequest();
    return signInWithIdp(auth2, request);
  }
  _linkToIdToken(auth2, idToken) {
    const request = this.buildRequest();
    request.idToken = idToken;
    return signInWithIdp(auth2, request);
  }
  _getReauthenticationResolver(auth2) {
    const request = this.buildRequest();
    request.autoCreate = false;
    return signInWithIdp(auth2, request);
  }
  toJSON() {
    return {
      signInMethod: this.signInMethod,
      providerId: this.providerId,
      pendingToken: this.pendingToken
    };
  }
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    const {providerId, signInMethod, pendingToken} = obj;
    if (!providerId || !signInMethod || !pendingToken || providerId !== signInMethod) {
      return null;
    }
    return new SAMLAuthCredential(providerId, pendingToken);
  }
  static _create(providerId, pendingToken) {
    return new SAMLAuthCredential(providerId, pendingToken);
  }
  buildRequest() {
    return {
      requestUri: IDP_REQUEST_URI$1,
      returnSecureToken: true,
      pendingToken: this.pendingToken
    };
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TwitterAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("twitter.com");
  }
  static credential(token, secret) {
    return OAuthCredential._fromParams({
      providerId: TwitterAuthProvider.PROVIDER_ID,
      signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
      oauthToken: token,
      oauthTokenSecret: secret
    });
  }
  static credentialFromResult(userCredential) {
    return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return TwitterAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({_tokenResponse: tokenResponse}) {
    if (!tokenResponse) {
      return null;
    }
    const {oauthAccessToken, oauthTokenSecret} = tokenResponse;
    if (!oauthAccessToken || !oauthTokenSecret) {
      return null;
    }
    try {
      return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
    } catch (_a2) {
      return null;
    }
  }
}
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com";
TwitterAuthProvider.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signUp(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signUp", _addTidIfNecessary(auth2, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserCredentialImpl {
  constructor(params) {
    this.user = params.user;
    this.providerId = params.providerId;
    this._tokenResponse = params._tokenResponse;
    this.operationType = params.operationType;
  }
  static async _fromIdTokenResponse(auth2, operationType, idTokenResponse, isAnonymous = false) {
    const user = await UserImpl._fromIdTokenResponse(auth2, idTokenResponse, isAnonymous);
    const providerId = providerIdForResponse(idTokenResponse);
    const userCred = new UserCredentialImpl({
      user,
      providerId,
      _tokenResponse: idTokenResponse,
      operationType
    });
    return userCred;
  }
  static async _forOperation(user, operationType, response) {
    await user._updateTokensIfNecessary(response, true);
    const providerId = providerIdForResponse(response);
    return new UserCredentialImpl({
      user,
      providerId,
      _tokenResponse: response,
      operationType
    });
  }
}
function providerIdForResponse(response) {
  if (response.providerId) {
    return response.providerId;
  }
  if ("phoneNumber" in response) {
    return "phone";
  }
  return null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInAnonymously(auth2) {
  var _a2;
  const authInternal = _castAuth(auth2);
  if ((_a2 = authInternal.currentUser) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous) {
    return new UserCredentialImpl({
      user: authInternal.currentUser,
      providerId: null,
      operationType: "signIn"
    });
  }
  const response = await signUp(authInternal, {
    returnSecureToken: true
  });
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response, true);
  await authInternal._updateCurrentUser(userCredential.user);
  return userCredential;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorError extends FirebaseError {
  constructor(auth2, error2, operationType, user) {
    var _a2;
    super(error2.code, error2.message);
    this.operationType = operationType;
    this.user = user;
    this.name = "FirebaseError";
    Object.setPrototypeOf(this, MultiFactorError.prototype);
    this.appName = auth2.name;
    this.code = error2.code;
    this.tenantId = (_a2 = auth2.tenantId) !== null && _a2 !== void 0 ? _a2 : void 0;
    this.serverResponse = error2.customData.serverResponse;
  }
  static _fromErrorAndOperation(auth2, error2, operationType, user) {
    return new MultiFactorError(auth2, error2, operationType, user);
  }
}
function _processCredentialSavingMfaContextIfNecessary(auth2, operationType, credential, user) {
  const idTokenProvider = operationType === "reauthenticate" ? credential._getReauthenticationResolver(auth2) : credential._getIdTokenResponse(auth2);
  return idTokenProvider.catch((error2) => {
    if (error2.code === `auth/${"multi-factor-auth-required"}`) {
      throw MultiFactorError._fromErrorAndOperation(auth2, error2, operationType, user);
    }
    throw error2;
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function providerDataAsNames(providerData) {
  return new Set(providerData.map(({providerId}) => providerId).filter((pid) => !!pid));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function unlink(user, providerId) {
  const userInternal = getModularInstance(user);
  await _assertLinkedStatus(true, userInternal, providerId);
  const {providerUserInfo} = await deleteLinkedAccounts(userInternal.auth, {
    idToken: await userInternal.getIdToken(),
    deleteProvider: [providerId]
  });
  const providersLeft = providerDataAsNames(providerUserInfo || []);
  userInternal.providerData = userInternal.providerData.filter((pd2) => providersLeft.has(pd2.providerId));
  if (!providersLeft.has("phone")) {
    userInternal.phoneNumber = null;
  }
  await userInternal.auth._persistUserIfCurrent(userInternal);
  return userInternal;
}
async function _link(user, credential, bypassAuthState = false) {
  const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);
  return UserCredentialImpl._forOperation(user, "link", response);
}
async function _assertLinkedStatus(expected, user, provider) {
  await _reloadWithoutSaving(user);
  const providerIds = providerDataAsNames(user.providerData);
  const code = expected === false ? "provider-already-linked" : "no-such-provider";
  _assert$4(providerIds.has(provider) === expected, user.auth, code);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reauthenticate(user, credential, bypassAuthState = false) {
  const {auth: auth2} = user;
  const operationType = "reauthenticate";
  try {
    const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth2, operationType, credential, user), bypassAuthState);
    _assert$4(response.idToken, auth2, "internal-error");
    const parsed = _parseToken(response.idToken);
    _assert$4(parsed, auth2, "internal-error");
    const {sub: localId} = parsed;
    _assert$4(user.uid === localId, auth2, "user-mismatch");
    return UserCredentialImpl._forOperation(user, operationType, response);
  } catch (e) {
    if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${"user-not-found"}`) {
      _fail(auth2, "user-mismatch");
    }
    throw e;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _signInWithCredential(auth2, credential, bypassAuthState = false) {
  const operationType = "signIn";
  const response = await _processCredentialSavingMfaContextIfNecessary(auth2, operationType, credential);
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth2, operationType, response);
  if (!bypassAuthState) {
    await auth2._updateCurrentUser(userCredential.user);
  }
  return userCredential;
}
async function signInWithCredential(auth2, credential) {
  return _signInWithCredential(_castAuth(auth2), credential);
}
async function linkWithCredential(user, credential) {
  const userInternal = getModularInstance(user);
  await _assertLinkedStatus(false, userInternal, credential.providerId);
  return _link(userInternal, credential);
}
async function reauthenticateWithCredential(user, credential) {
  return _reauthenticate(getModularInstance(user), credential);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithCustomToken(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithCustomToken", _addTidIfNecessary(auth2, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithCustomToken$1(auth2, customToken) {
  const authInternal = _castAuth(auth2);
  const response = await signInWithCustomToken(authInternal, {
    token: customToken,
    returnSecureToken: true
  });
  const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response);
  await authInternal._updateCurrentUser(cred.user);
  return cred;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorInfoImpl {
  constructor(factorId, response) {
    this.factorId = factorId;
    this.uid = response.mfaEnrollmentId;
    this.enrollmentTime = new Date(response.enrolledAt).toUTCString();
    this.displayName = response.displayName;
  }
  static _fromServerResponse(auth2, enrollment) {
    if ("phoneInfo" in enrollment) {
      return PhoneMultiFactorInfo._fromServerResponse(auth2, enrollment);
    }
    return _fail(auth2, "internal-error");
  }
}
class PhoneMultiFactorInfo extends MultiFactorInfoImpl {
  constructor(response) {
    super("phone", response);
    this.phoneNumber = response.phoneInfo;
  }
  static _fromServerResponse(_auth, enrollment) {
    return new PhoneMultiFactorInfo(enrollment);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _setActionCodeSettingsOnRequest(auth2, request, actionCodeSettings) {
  var _a2;
  _assert$4(((_a2 = actionCodeSettings.url) === null || _a2 === void 0 ? void 0 : _a2.length) > 0, auth2, "invalid-continue-uri");
  _assert$4(typeof actionCodeSettings.dynamicLinkDomain === "undefined" || actionCodeSettings.dynamicLinkDomain.length > 0, auth2, "invalid-dynamic-link-domain");
  request.continueUrl = actionCodeSettings.url;
  request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
  request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;
  if (actionCodeSettings.iOS) {
    _assert$4(actionCodeSettings.iOS.bundleId.length > 0, auth2, "missing-ios-bundle-id");
    request.iosBundleId = actionCodeSettings.iOS.bundleId;
  }
  if (actionCodeSettings.android) {
    _assert$4(actionCodeSettings.android.packageName.length > 0, auth2, "missing-android-pkg-name");
    request.androidInstallApp = actionCodeSettings.android.installApp;
    request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;
    request.androidPackageName = actionCodeSettings.android.packageName;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendPasswordResetEmail$1(auth2, email, actionCodeSettings) {
  const authModular = getModularInstance(auth2);
  const request = {
    requestType: "PASSWORD_RESET",
    email
  };
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(authModular, request, actionCodeSettings);
  }
  await sendPasswordResetEmail(authModular, request);
}
async function confirmPasswordReset(auth2, oobCode, newPassword) {
  await resetPassword(getModularInstance(auth2), {
    oobCode,
    newPassword
  });
}
async function applyActionCode$1(auth2, oobCode) {
  await applyActionCode(getModularInstance(auth2), {oobCode});
}
async function checkActionCode(auth2, oobCode) {
  const authModular = getModularInstance(auth2);
  const response = await resetPassword(authModular, {oobCode});
  const operation = response.requestType;
  _assert$4(operation, authModular, "internal-error");
  switch (operation) {
    case "EMAIL_SIGNIN":
      break;
    case "VERIFY_AND_CHANGE_EMAIL":
      _assert$4(response.newEmail, authModular, "internal-error");
      break;
    case "REVERT_SECOND_FACTOR_ADDITION":
      _assert$4(response.mfaInfo, authModular, "internal-error");
    default:
      _assert$4(response.email, authModular, "internal-error");
  }
  let multiFactorInfo = null;
  if (response.mfaInfo) {
    multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);
  }
  return {
    data: {
      email: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" ? response.newEmail : response.email) || null,
      previousEmail: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" ? response.email : response.newEmail) || null,
      multiFactorInfo
    },
    operation
  };
}
async function verifyPasswordResetCode(auth2, code) {
  const {data} = await checkActionCode(getModularInstance(auth2), code);
  return data.email;
}
async function createUserWithEmailAndPassword(auth2, email, password) {
  const authInternal = _castAuth(auth2);
  const response = await signUp(authInternal, {
    returnSecureToken: true,
    email,
    password
  });
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response);
  await authInternal._updateCurrentUser(userCredential.user);
  return userCredential;
}
function signInWithEmailAndPassword(auth2, email, password) {
  return signInWithCredential(getModularInstance(auth2), EmailAuthProvider.credential(email, password));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendSignInLinkToEmail$1(auth2, email, actionCodeSettings) {
  const authModular = getModularInstance(auth2);
  const request = {
    requestType: "EMAIL_SIGNIN",
    email
  };
  _assert$4(actionCodeSettings.handleCodeInApp, authModular, "argument-error");
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(authModular, request, actionCodeSettings);
  }
  await sendSignInLinkToEmail(authModular, request);
}
function isSignInWithEmailLink(auth2, emailLink) {
  const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
  return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN";
}
async function signInWithEmailLink$1(auth2, email, emailLink) {
  const authModular = getModularInstance(auth2);
  const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());
  _assert$4(credential._tenantId === (authModular.tenantId || null), authModular, "tenant-id-mismatch");
  return signInWithCredential(authModular, credential);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function createAuthUri(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:createAuthUri", _addTidIfNecessary(auth2, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function fetchSignInMethodsForEmail(auth2, email) {
  const continueUri = _isHttpOrHttps$1() ? _getCurrentUrl() : "http://localhost";
  const request = {
    identifier: email,
    continueUri
  };
  const {signinMethods} = await createAuthUri(getModularInstance(auth2), request);
  return signinMethods || [];
}
async function sendEmailVerification$1(user, actionCodeSettings) {
  const userInternal = getModularInstance(user);
  const idToken = await user.getIdToken();
  const request = {
    requestType: "VERIFY_EMAIL",
    idToken
  };
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
  }
  const {email} = await sendEmailVerification(userInternal.auth, request);
  if (email !== user.email) {
    await user.reload();
  }
}
async function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {
  const userInternal = getModularInstance(user);
  const idToken = await user.getIdToken();
  const request = {
    requestType: "VERIFY_AND_CHANGE_EMAIL",
    idToken,
    newEmail
  };
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
  }
  const {email} = await verifyAndChangeEmail(userInternal.auth, request);
  if (email !== user.email) {
    await user.reload();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function updateProfile(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:update", request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function updateProfile$1(user, {displayName, photoURL: photoUrl}) {
  if (displayName === void 0 && photoUrl === void 0) {
    return;
  }
  const userInternal = getModularInstance(user);
  const idToken = await userInternal.getIdToken();
  const profileRequest = {
    idToken,
    displayName,
    photoUrl,
    returnSecureToken: true
  };
  const response = await _logoutIfInvalidated(userInternal, updateProfile(userInternal.auth, profileRequest));
  userInternal.displayName = response.displayName || null;
  userInternal.photoURL = response.photoUrl || null;
  const passwordProvider = userInternal.providerData.find(({providerId}) => providerId === "password");
  if (passwordProvider) {
    passwordProvider.displayName = userInternal.displayName;
    passwordProvider.photoURL = userInternal.photoURL;
  }
  await userInternal._updateTokensIfNecessary(response);
}
function updateEmail(user, newEmail) {
  return updateEmailOrPassword(getModularInstance(user), newEmail, null);
}
function updatePassword(user, newPassword) {
  return updateEmailOrPassword(getModularInstance(user), null, newPassword);
}
async function updateEmailOrPassword(user, email, password) {
  const {auth: auth2} = user;
  const idToken = await user.getIdToken();
  const request = {
    idToken,
    returnSecureToken: true
  };
  if (email) {
    request.email = email;
  }
  if (password) {
    request.password = password;
  }
  const response = await _logoutIfInvalidated(user, updateEmailPassword(auth2, request));
  await user._updateTokensIfNecessary(response, true);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _fromIdTokenResponse(idTokenResponse) {
  var _a2, _b;
  if (!idTokenResponse) {
    return null;
  }
  const {providerId} = idTokenResponse;
  const profile = idTokenResponse.rawUserInfo ? JSON.parse(idTokenResponse.rawUserInfo) : {};
  const isNewUser = idTokenResponse.isNewUser || idTokenResponse.kind === "identitytoolkit#SignupNewUserResponse";
  if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {
    const signInProvider = (_b = (_a2 = _parseToken(idTokenResponse.idToken)) === null || _a2 === void 0 ? void 0 : _a2.firebase) === null || _b === void 0 ? void 0 : _b["sign_in_provider"];
    if (signInProvider) {
      const filteredProviderId = signInProvider !== "anonymous" && signInProvider !== "custom" ? signInProvider : null;
      return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);
    }
  }
  if (!providerId) {
    return null;
  }
  switch (providerId) {
    case "facebook.com":
      return new FacebookAdditionalUserInfo(isNewUser, profile);
    case "github.com":
      return new GithubAdditionalUserInfo(isNewUser, profile);
    case "google.com":
      return new GoogleAdditionalUserInfo(isNewUser, profile);
    case "twitter.com":
      return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);
    case "custom":
    case "anonymous":
      return new GenericAdditionalUserInfo(isNewUser, null);
    default:
      return new GenericAdditionalUserInfo(isNewUser, providerId, profile);
  }
}
class GenericAdditionalUserInfo {
  constructor(isNewUser, providerId, profile = {}) {
    this.isNewUser = isNewUser;
    this.providerId = providerId;
    this.profile = profile;
  }
}
class FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {
  constructor(isNewUser, providerId, profile, username) {
    super(isNewUser, providerId, profile);
    this.username = username;
  }
}
class FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {
  constructor(isNewUser, profile) {
    super(isNewUser, "facebook.com", profile);
  }
}
class GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {
  constructor(isNewUser, profile) {
    super(isNewUser, "github.com", profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === "string" ? profile === null || profile === void 0 ? void 0 : profile.login : null);
  }
}
class GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {
  constructor(isNewUser, profile) {
    super(isNewUser, "google.com", profile);
  }
}
class TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {
  constructor(isNewUser, profile, screenName) {
    super(isNewUser, "twitter.com", profile, screenName);
  }
}
function getAdditionalUserInfo(userCredential) {
  const {user, _tokenResponse} = userCredential;
  if (user.isAnonymous && !_tokenResponse) {
    return {
      providerId: null,
      isNewUser: false,
      profile: null
    };
  }
  return _fromIdTokenResponse(_tokenResponse);
}
class MultiFactorSessionImpl {
  constructor(type, credential) {
    this.type = type;
    this.credential = credential;
  }
  static _fromIdtoken(idToken) {
    return new MultiFactorSessionImpl("enroll", idToken);
  }
  static _fromMfaPendingCredential(mfaPendingCredential) {
    return new MultiFactorSessionImpl("signin", mfaPendingCredential);
  }
  toJSON() {
    const key = this.type === "enroll" ? "idToken" : "pendingCredential";
    return {
      multiFactorSession: {
        [key]: this.credential
      }
    };
  }
  static fromJSON(obj) {
    var _a2, _b;
    if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {
      if ((_a2 = obj.multiFactorSession) === null || _a2 === void 0 ? void 0 : _a2.pendingCredential) {
        return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);
      } else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {
        return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);
      }
    }
    return null;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorResolverImpl {
  constructor(session2, hints, signInResolver) {
    this.session = session2;
    this.hints = hints;
    this.signInResolver = signInResolver;
  }
  static _fromError(authExtern, error2) {
    const auth2 = _castAuth(authExtern);
    const hints = (error2.serverResponse.mfaInfo || []).map((enrollment) => MultiFactorInfoImpl._fromServerResponse(auth2, enrollment));
    _assert$4(error2.serverResponse.mfaPendingCredential, auth2, "internal-error");
    const session2 = MultiFactorSessionImpl._fromMfaPendingCredential(error2.serverResponse.mfaPendingCredential);
    return new MultiFactorResolverImpl(session2, hints, async (assertion) => {
      const mfaResponse = await assertion._process(auth2, session2);
      delete error2.serverResponse.mfaInfo;
      delete error2.serverResponse.mfaPendingCredential;
      const idTokenResponse = Object.assign(Object.assign({}, error2.serverResponse), {idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken});
      switch (error2.operationType) {
        case "signIn":
          const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth2, error2.operationType, idTokenResponse);
          await auth2._updateCurrentUser(userCredential.user);
          return userCredential;
        case "reauthenticate":
          _assert$4(error2.user, auth2, "internal-error");
          return UserCredentialImpl._forOperation(error2.user, error2.operationType, idTokenResponse);
        default:
          _fail(auth2, "internal-error");
      }
    });
  }
  async resolveSignIn(assertionExtern) {
    const assertion = assertionExtern;
    return this.signInResolver(assertion);
  }
}
function getMultiFactorResolver(auth2, error2) {
  var _a2;
  const authModular = getModularInstance(auth2);
  const errorInternal = error2;
  _assert$4(error2.operationType, authModular, "argument-error");
  _assert$4((_a2 = errorInternal.serverResponse) === null || _a2 === void 0 ? void 0 : _a2.mfaPendingCredential, authModular, "argument-error");
  return MultiFactorResolverImpl._fromError(authModular, errorInternal);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startEnrollPhoneMfa(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v2/accounts/mfaEnrollment:start", Object.assign({tenantId: auth2.tenantId}, request));
}
function finalizeEnrollPhoneMfa(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v2/accounts/mfaEnrollment:finalize", Object.assign({tenantId: auth2.tenantId}, request));
}
function withdrawMfa(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v2/accounts/mfaEnrollment:withdraw", Object.assign({tenantId: auth2.tenantId}, request));
}
class MultiFactorUserImpl {
  constructor(user) {
    this.user = user;
    this.enrolledFactors = [];
    user._onReload((userInfo) => {
      if (userInfo.mfaInfo) {
        this.enrolledFactors = userInfo.mfaInfo.map((enrollment) => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));
      }
    });
  }
  static _fromUser(user) {
    return new MultiFactorUserImpl(user);
  }
  async getSession() {
    return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken());
  }
  async enroll(assertionExtern, displayName) {
    const assertion = assertionExtern;
    const session2 = await this.getSession();
    const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session2, displayName));
    await this.user._updateTokensIfNecessary(finalizeMfaResponse);
    return this.user.reload();
  }
  async unenroll(infoOrUid) {
    const mfaEnrollmentId = typeof infoOrUid === "string" ? infoOrUid : infoOrUid.uid;
    const idToken = await this.user.getIdToken();
    const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {
      idToken,
      mfaEnrollmentId
    }));
    this.enrolledFactors = this.enrolledFactors.filter(({uid}) => uid !== mfaEnrollmentId);
    await this.user._updateTokensIfNecessary(idTokenResponse);
    try {
      await this.user.reload();
    } catch (e) {
      if (e.code !== `auth/${"user-token-expired"}`) {
        throw e;
      }
    }
  }
}
const multiFactorUserCache = new WeakMap();
function multiFactor(user) {
  const userModular = getModularInstance(user);
  if (!multiFactorUserCache.has(userModular)) {
    multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));
  }
  return multiFactorUserCache.get(userModular);
}
var name$2 = "@firebase/auth-exp";
var version$3 = "0.0.900-exp.894b5da5a";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthInterop {
  constructor(auth2) {
    this.auth = auth2;
    this.internalListeners = new Map();
  }
  getUid() {
    var _a2;
    this.assertAuthConfigured();
    return ((_a2 = this.auth.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) || null;
  }
  async getToken(forceRefresh) {
    this.assertAuthConfigured();
    await this.auth._initializationPromise;
    if (!this.auth.currentUser) {
      return null;
    }
    const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
    return {accessToken};
  }
  addAuthTokenListener(listener) {
    this.assertAuthConfigured();
    if (this.internalListeners.has(listener)) {
      return;
    }
    const unsubscribe = this.auth.onIdTokenChanged((user) => {
      var _a2;
      listener(((_a2 = user) === null || _a2 === void 0 ? void 0 : _a2.stsTokenManager.accessToken) || null);
    });
    this.internalListeners.set(listener, unsubscribe);
    this.updateProactiveRefresh();
  }
  removeAuthTokenListener(listener) {
    this.assertAuthConfigured();
    const unsubscribe = this.internalListeners.get(listener);
    if (!unsubscribe) {
      return;
    }
    this.internalListeners.delete(listener);
    unsubscribe();
    this.updateProactiveRefresh();
  }
  assertAuthConfigured() {
    _assert$4(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
  }
  updateProactiveRefresh() {
    if (this.internalListeners.size > 0) {
      this.auth._startProactiveRefresh();
    } else {
      this.auth._stopProactiveRefresh();
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getVersionForPlatform(clientPlatform) {
  switch (clientPlatform) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    default:
      return void 0;
  }
}
function registerAuth(clientPlatform) {
  _registerComponent(new Component("auth-exp", (container, {options: deps}) => {
    const app = container.getProvider("app-exp").getImmediate();
    const {apiKey, authDomain} = app.options;
    return ((app2) => {
      _assert$4(apiKey && !apiKey.includes(":"), "invalid-api-key", {appName: app2.name});
      _assert$4(!(authDomain === null || authDomain === void 0 ? void 0 : authDomain.includes(":")), "argument-error", {
        appName: app2.name
      });
      const config2 = {
        apiKey,
        authDomain,
        clientPlatform,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: _getClientVersion(clientPlatform)
      };
      const authInstance = new AuthImpl(app2, config2);
      _initializeAuthInstance(authInstance, deps);
      return authInstance;
    })(app);
  }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
    const authInternalProvider = container.getProvider("auth-internal");
    authInternalProvider.initialize();
  }));
  _registerComponent(new Component("auth-internal", (container) => {
    const auth2 = _castAuth(container.getProvider("auth-exp").getImmediate());
    return ((auth3) => new AuthInterop(auth3))(auth2);
  }, "PRIVATE").setInstantiationMode("EXPLICIT"));
  registerVersion(name$2, version$3, getVersionForPlatform(clientPlatform));
}
const STORAGE_AVAILABLE_KEY = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserPersistenceClass {
  constructor(storage2, type) {
    this.storage = storage2;
    this.type = type;
  }
  _isAvailable() {
    try {
      if (!this.storage) {
        return Promise.resolve(false);
      }
      this.storage.setItem(STORAGE_AVAILABLE_KEY, "1");
      this.storage.removeItem(STORAGE_AVAILABLE_KEY);
      return Promise.resolve(true);
    } catch (_a2) {
      return Promise.resolve(false);
    }
  }
  _set(key, value) {
    this.storage.setItem(key, JSON.stringify(value));
    return Promise.resolve();
  }
  _get(key) {
    const json = this.storage.getItem(key);
    return Promise.resolve(json ? JSON.parse(json) : null);
  }
  _remove(key) {
    this.storage.removeItem(key);
    return Promise.resolve();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _iframeCannotSyncWebStorage() {
  const ua2 = getUA();
  return _isSafari(ua2) || _isIOS(ua2);
}
const _POLLING_INTERVAL_MS = 1e3;
const IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
class BrowserLocalPersistence extends BrowserPersistenceClass {
  constructor() {
    super(window.localStorage, "LOCAL");
    this.listeners = {};
    this.localCache = {};
    this.pollTimer = null;
    this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe();
    this.fallbackToPolling = _isMobileBrowser();
    this.boundEventHandler = this.onStorageEvent.bind(this);
  }
  forAllChangedKeys(cb2) {
    for (const key of Object.keys(this.listeners)) {
      const newValue = this.storage.getItem(key);
      const oldValue = this.localCache[key];
      if (newValue !== oldValue) {
        cb2(key, oldValue, newValue);
      }
    }
  }
  onStorageEvent(event, poll = false) {
    if (!event.key) {
      this.forAllChangedKeys((key2, _oldValue, newValue) => {
        this.notifyListeners(key2, newValue);
      });
      return;
    }
    const key = event.key;
    if (poll) {
      this.detachListener();
    } else {
      this.stopPolling();
    }
    if (this.safariLocalStorageNotSynced) {
      const storedValue2 = this.storage.getItem(key);
      if (event.newValue !== storedValue2) {
        if (event.newValue !== null) {
          this.storage.setItem(key, event.newValue);
        } else {
          this.storage.removeItem(key);
        }
      } else if (this.localCache[key] === event.newValue && !poll) {
        return;
      }
    }
    const triggerListeners = () => {
      const storedValue2 = this.storage.getItem(key);
      if (!poll && this.localCache[key] === storedValue2) {
        return;
      }
      this.notifyListeners(key, storedValue2);
    };
    const storedValue = this.storage.getItem(key);
    if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {
      setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
    } else {
      triggerListeners();
    }
  }
  notifyListeners(key, value) {
    this.localCache[key] = value;
    const listeners = this.listeners[key];
    if (listeners) {
      for (const listener of Array.from(listeners)) {
        listener(value ? JSON.parse(value) : value);
      }
    }
  }
  startPolling() {
    this.stopPolling();
    this.pollTimer = setInterval(() => {
      this.forAllChangedKeys((key, oldValue, newValue) => {
        this.onStorageEvent(new StorageEvent("storage", {
          key,
          oldValue,
          newValue
        }), true);
      });
    }, _POLLING_INTERVAL_MS);
  }
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  attachListener() {
    window.addEventListener("storage", this.boundEventHandler);
  }
  detachListener() {
    window.removeEventListener("storage", this.boundEventHandler);
  }
  _addListener(key, listener) {
    if (Object.keys(this.listeners).length === 0) {
      if (this.fallbackToPolling) {
        this.startPolling();
      } else {
        this.attachListener();
      }
    }
    if (!this.listeners[key]) {
      this.listeners[key] = new Set();
      this.localCache[key] = this.storage.getItem(key);
    }
    this.listeners[key].add(listener);
  }
  _removeListener(key, listener) {
    if (this.listeners[key]) {
      this.listeners[key].delete(listener);
      if (this.listeners[key].size === 0) {
        delete this.listeners[key];
      }
    }
    if (Object.keys(this.listeners).length === 0) {
      this.detachListener();
      this.stopPolling();
    }
  }
  async _set(key, value) {
    await super._set(key, value);
    this.localCache[key] = JSON.stringify(value);
  }
  async _get(key) {
    const value = await super._get(key);
    this.localCache[key] = JSON.stringify(value);
    return value;
  }
  async _remove(key) {
    await super._remove(key);
    delete this.localCache[key];
  }
}
BrowserLocalPersistence.type = "LOCAL";
const browserLocalPersistence = BrowserLocalPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _allSettled(promises) {
  return Promise.all(promises.map(async (promise) => {
    try {
      const value = await promise;
      return {
        fulfilled: true,
        value
      };
    } catch (reason) {
      return {
        fulfilled: false,
        reason
      };
    }
  }));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Receiver {
  constructor(eventTarget) {
    this.eventTarget = eventTarget;
    this.handlersMap = {};
    this.boundEventHandler = this.handleEvent.bind(this);
  }
  static _getInstance(eventTarget) {
    const existingInstance = this.receivers.find((receiver) => receiver.isListeningto(eventTarget));
    if (existingInstance) {
      return existingInstance;
    }
    const newInstance = new Receiver(eventTarget);
    this.receivers.push(newInstance);
    return newInstance;
  }
  isListeningto(eventTarget) {
    return this.eventTarget === eventTarget;
  }
  async handleEvent(event) {
    const messageEvent = event;
    const {eventId, eventType, data} = messageEvent.data;
    const handlers = this.handlersMap[eventType];
    if (!(handlers === null || handlers === void 0 ? void 0 : handlers.size)) {
      return;
    }
    messageEvent.ports[0].postMessage({
      status: "ack",
      eventId,
      eventType
    });
    const promises = Array.from(handlers).map(async (handler) => handler(messageEvent.origin, data));
    const response = await _allSettled(promises);
    messageEvent.ports[0].postMessage({
      status: "done",
      eventId,
      eventType,
      response
    });
  }
  _subscribe(eventType, eventHandler) {
    if (Object.keys(this.handlersMap).length === 0) {
      this.eventTarget.addEventListener("message", this.boundEventHandler);
    }
    if (!this.handlersMap[eventType]) {
      this.handlersMap[eventType] = new Set();
    }
    this.handlersMap[eventType].add(eventHandler);
  }
  _unsubscribe(eventType, eventHandler) {
    if (this.handlersMap[eventType] && eventHandler) {
      this.handlersMap[eventType].delete(eventHandler);
    }
    if (!eventHandler || this.handlersMap[eventType].size === 0) {
      delete this.handlersMap[eventType];
    }
    if (Object.keys(this.handlersMap).length === 0) {
      this.eventTarget.removeEventListener("message", this.boundEventHandler);
    }
  }
}
Receiver.receivers = [];
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function generateEventId(prefix = "", digits = 20) {
  return `${prefix}${Math.floor(Math.random() * Math.pow(10, digits))}`;
}
class Sender {
  constructor(target) {
    this.target = target;
    this.handlers = new Set();
  }
  removeMessageHandler(handler) {
    if (handler.messageChannel) {
      handler.messageChannel.port1.removeEventListener("message", handler.onMessage);
      handler.messageChannel.port1.close();
    }
    this.handlers.delete(handler);
  }
  async _send(eventType, data, timeout = 50) {
    const messageChannel = typeof MessageChannel !== "undefined" ? new MessageChannel() : null;
    if (!messageChannel) {
      throw new Error("connection_unavailable");
    }
    let completionTimer;
    let handler;
    return new Promise((resolve, reject) => {
      const eventId = generateEventId();
      messageChannel.port1.start();
      const ackTimer = setTimeout(() => {
        reject(new Error("unsupported_event"));
      }, timeout);
      handler = {
        messageChannel,
        onMessage(event) {
          const messageEvent = event;
          if (messageEvent.data.eventId !== eventId) {
            return;
          }
          switch (messageEvent.data.status) {
            case "ack":
              clearTimeout(ackTimer);
              completionTimer = setTimeout(() => {
                reject(new Error("timeout"));
              }, 3e3);
              break;
            case "done":
              clearTimeout(completionTimer);
              resolve(messageEvent.data.response);
              break;
            default:
              clearTimeout(ackTimer);
              clearTimeout(completionTimer);
              reject(new Error("invalid_response"));
              break;
          }
        }
      };
      this.handlers.add(handler);
      messageChannel.port1.addEventListener("message", handler.onMessage);
      this.target.postMessage({
        eventType,
        eventId,
        data
      }, [messageChannel.port2]);
    }).finally(() => {
      if (handler) {
        this.removeMessageHandler(handler);
      }
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _window() {
  return window;
}
function _setWindowLocation(url) {
  _window().location.href = url;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isWorker$1() {
  return typeof _window()["WorkerGlobalScope"] !== "undefined" && typeof _window()["importScripts"] === "function";
}
async function _getActiveServiceWorker() {
  if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
    return null;
  }
  try {
    const registration = await navigator.serviceWorker.ready;
    return registration.active;
  } catch (_a2) {
    return null;
  }
}
function _getServiceWorkerController() {
  var _a2;
  return ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a2 === void 0 ? void 0 : _a2.controller) || null;
}
function _getWorkerGlobalScope() {
  return _isWorker$1() ? self : null;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = "firebaseLocalStorageDb";
const DB_VERSION = 1;
const DB_OBJECTSTORE_NAME = "firebaseLocalStorage";
const DB_DATA_KEYPATH = "fbase_key";
class DBPromise {
  constructor(request) {
    this.request = request;
  }
  toPromise() {
    return new Promise((resolve, reject) => {
      this.request.addEventListener("success", () => {
        resolve(this.request.result);
      });
      this.request.addEventListener("error", () => {
        reject(this.request.error);
      });
    });
  }
}
function getObjectStore(db2, isReadWrite) {
  return db2.transaction([DB_OBJECTSTORE_NAME], isReadWrite ? "readwrite" : "readonly").objectStore(DB_OBJECTSTORE_NAME);
}
function _deleteDatabase() {
  const request = indexedDB.deleteDatabase(DB_NAME);
  return new DBPromise(request).toPromise();
}
function _openDatabase() {
  const request = indexedDB.open(DB_NAME, DB_VERSION);
  return new Promise((resolve, reject) => {
    request.addEventListener("error", () => {
      reject(request.error);
    });
    request.addEventListener("upgradeneeded", () => {
      const db2 = request.result;
      try {
        db2.createObjectStore(DB_OBJECTSTORE_NAME, {keyPath: DB_DATA_KEYPATH});
      } catch (e) {
        reject(e);
      }
    });
    request.addEventListener("success", async () => {
      const db2 = request.result;
      if (!db2.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
        await _deleteDatabase();
        return _openDatabase();
      } else {
        resolve(db2);
      }
    });
  });
}
async function _putObject(db2, key, value) {
  const request = getObjectStore(db2, true).put({
    [DB_DATA_KEYPATH]: key,
    value
  });
  return new DBPromise(request).toPromise();
}
async function getObject(db2, key) {
  const request = getObjectStore(db2, false).get(key);
  const data = await new DBPromise(request).toPromise();
  return data === void 0 ? null : data.value;
}
function _deleteObject(db2, key) {
  const request = getObjectStore(db2, true).delete(key);
  return new DBPromise(request).toPromise();
}
const _POLLING_INTERVAL_MS$1 = 800;
const _TRANSACTION_RETRY_COUNT = 3;
class IndexedDBLocalPersistence {
  constructor() {
    this.type = "LOCAL";
    this.listeners = {};
    this.localCache = {};
    this.pollTimer = null;
    this.pendingWrites = 0;
    this.receiver = null;
    this.sender = null;
    this.serviceWorkerReceiverAvailable = false;
    this.activeServiceWorker = null;
    this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
    }, () => {
    });
  }
  async _openDb() {
    if (this.db) {
      return this.db;
    }
    this.db = await _openDatabase();
    return this.db;
  }
  async _withRetries(op) {
    let numAttempts = 0;
    while (true) {
      try {
        const db2 = await this._openDb();
        return await op(db2);
      } catch (e) {
        if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
          throw e;
        }
        if (this.db) {
          this.db.close();
          this.db = void 0;
        }
      }
    }
  }
  async initializeServiceWorkerMessaging() {
    return _isWorker$1() ? this.initializeReceiver() : this.initializeSender();
  }
  async initializeReceiver() {
    this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
    this.receiver._subscribe("keyChanged", async (_origin, data) => {
      const keys = await this._poll();
      return {
        keyProcessed: keys.includes(data.key)
      };
    });
    this.receiver._subscribe("ping", async (_origin, _data) => {
      return ["keyChanged"];
    });
  }
  async initializeSender() {
    var _a2, _b;
    this.activeServiceWorker = await _getActiveServiceWorker();
    if (!this.activeServiceWorker) {
      return;
    }
    this.sender = new Sender(this.activeServiceWorker);
    const results = await this.sender._send("ping", {}, 800);
    if (!results) {
      return;
    }
    if (((_a2 = results[0]) === null || _a2 === void 0 ? void 0 : _a2.fulfilled) && ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes("keyChanged"))) {
      this.serviceWorkerReceiverAvailable = true;
    }
  }
  async notifyServiceWorker(key) {
    if (!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker) {
      return;
    }
    try {
      await this.sender._send("keyChanged", {key}, this.serviceWorkerReceiverAvailable ? 800 : 50);
    } catch (_a2) {
    }
  }
  async _isAvailable() {
    try {
      if (!indexedDB) {
        return false;
      }
      const db2 = await _openDatabase();
      await _putObject(db2, STORAGE_AVAILABLE_KEY, "1");
      await _deleteObject(db2, STORAGE_AVAILABLE_KEY);
      return true;
    } catch (_a2) {
    }
    return false;
  }
  async _withPendingWrite(write) {
    this.pendingWrites++;
    try {
      await write();
    } finally {
      this.pendingWrites--;
    }
  }
  async _set(key, value) {
    return this._withPendingWrite(async () => {
      await this._withRetries((db2) => _putObject(db2, key, value));
      this.localCache[key] = value;
      return this.notifyServiceWorker(key);
    });
  }
  async _get(key) {
    const obj = await this._withRetries((db2) => getObject(db2, key));
    this.localCache[key] = obj;
    return obj;
  }
  async _remove(key) {
    return this._withPendingWrite(async () => {
      await this._withRetries((db2) => _deleteObject(db2, key));
      delete this.localCache[key];
      return this.notifyServiceWorker(key);
    });
  }
  async _poll() {
    const result = await this._withRetries((db2) => {
      const getAllRequest = getObjectStore(db2, false).getAll();
      return new DBPromise(getAllRequest).toPromise();
    });
    if (!result) {
      return [];
    }
    if (this.pendingWrites !== 0) {
      return [];
    }
    const keys = [];
    const keysInResult = new Set();
    for (const {fbase_key: key, value} of result) {
      keysInResult.add(key);
      if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
        this.notifyListeners(key, value);
        keys.push(key);
      }
    }
    for (const localKey of Object.keys(this.localCache)) {
      if (this.localCache[localKey] && !keysInResult.has(localKey)) {
        this.notifyListeners(localKey, null);
        keys.push(localKey);
      }
    }
    return keys;
  }
  notifyListeners(key, newValue) {
    this.localCache[key] = newValue;
    const listeners = this.listeners[key];
    if (listeners) {
      for (const listener of Array.from(listeners)) {
        listener(newValue);
      }
    }
  }
  startPolling() {
    this.stopPolling();
    this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS$1);
  }
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  _addListener(key, listener) {
    if (Object.keys(this.listeners).length === 0) {
      this.startPolling();
    }
    if (!this.listeners[key]) {
      this.listeners[key] = new Set();
      void this._get(key);
    }
    this.listeners[key].add(listener);
  }
  _removeListener(key, listener) {
    if (this.listeners[key]) {
      this.listeners[key].delete(listener);
      if (this.listeners[key].size === 0) {
        delete this.listeners[key];
      }
    }
    if (Object.keys(this.listeners).length === 0) {
      this.stopPolling();
    }
  }
}
IndexedDBLocalPersistence.type = "LOCAL";
const indexedDBLocalPersistence = IndexedDBLocalPersistence;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1e3;
class AuthEventManager {
  constructor(auth2) {
    this.auth = auth2;
    this.cachedEventUids = new Set();
    this.consumers = new Set();
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
    this.lastProcessedEventTime = Date.now();
  }
  registerConsumer(authEventConsumer) {
    this.consumers.add(authEventConsumer);
    if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
      this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
      this.saveEventToCache(this.queuedRedirectEvent);
      this.queuedRedirectEvent = null;
    }
  }
  unregisterConsumer(authEventConsumer) {
    this.consumers.delete(authEventConsumer);
  }
  onEvent(event) {
    if (this.hasEventBeenHandled(event)) {
      return false;
    }
    let handled = false;
    this.consumers.forEach((consumer) => {
      if (this.isEventForConsumer(event, consumer)) {
        handled = true;
        this.sendToConsumer(event, consumer);
        this.saveEventToCache(event);
      }
    });
    if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
      return handled;
    }
    this.hasHandledPotentialRedirect = true;
    if (!handled) {
      this.queuedRedirectEvent = event;
      handled = true;
    }
    return handled;
  }
  sendToConsumer(event, consumer) {
    var _a2;
    if (event.error && !isNullRedirectEvent(event)) {
      const code = ((_a2 = event.error.code) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")[1]) || "internal-error";
      consumer.onError(_createError(this.auth, code));
    } else {
      consumer.onAuthEvent(event);
    }
  }
  isEventForConsumer(event, consumer) {
    const eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;
    return consumer.filter.includes(event.type) && eventIdMatches;
  }
  hasEventBeenHandled(event) {
    if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {
      this.cachedEventUids.clear();
    }
    return this.cachedEventUids.has(eventUid(event));
  }
  saveEventToCache(event) {
    this.cachedEventUids.add(eventUid(event));
    this.lastProcessedEventTime = Date.now();
  }
}
function eventUid(e) {
  return [e.type, e.eventId, e.sessionId, e.tenantId].filter((v3) => v3).join("-");
}
function isNullRedirectEvent({type, error: error2}) {
  return type === "unknown" && (error2 === null || error2 === void 0 ? void 0 : error2.code) === `auth/${"no-auth-event"}`;
}
function isRedirectEvent(event) {
  switch (event.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return true;
    case "unknown":
      return isNullRedirectEvent(event);
    default:
      return false;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _generateEventId(prefix) {
  return `${prefix ? prefix : ""}${Math.floor(Math.random() * 1e9)}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _getProjectConfig(auth2) {
  return _performApiRequest(auth2, "GET", "/v1/projects", {});
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
const HTTP_REGEX = /^https?/;
async function _validateOrigin(auth2) {
  if (auth2.config.emulator) {
    return;
  }
  const {authorizedDomains} = await _getProjectConfig(auth2);
  for (const domain of authorizedDomains) {
    try {
      if (matchDomain(domain)) {
        return;
      }
    } catch (_a2) {
    }
  }
  _fail(auth2, "unauthorized-domain");
}
function matchDomain(expected) {
  const currentUrl = _getCurrentUrl();
  const {protocol, hostname} = new URL(currentUrl);
  if (expected.startsWith("chrome-extension://")) {
    const ceUrl = new URL(expected);
    if (ceUrl.hostname === "" && hostname === "") {
      return protocol === "chrome-extension:" && expected.replace("chrome-extension://", "") === currentUrl.replace("chrome-extension://", "");
    }
    return protocol === "chrome-extension:" && ceUrl.hostname === hostname;
  }
  if (!HTTP_REGEX.test(protocol)) {
    return false;
  }
  if (IP_ADDRESS_REGEX.test(expected)) {
    return hostname === expected;
  }
  const escapedDomainPattern = expected.replace(/\./g, "\\.");
  const re2 = new RegExp("^(.+\\." + escapedDomainPattern + "|" + escapedDomainPattern + ")$", "i");
  return re2.test(hostname);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getScriptParentElement() {
  var _a2, _b;
  return (_b = (_a2 = document.getElementsByTagName("head")) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) {
  return new Promise((resolve, reject) => {
    const el = document.createElement("script");
    el.setAttribute("src", url);
    el.onload = resolve;
    el.onerror = reject;
    el.type = "text/javascript";
    el.charset = "UTF-8";
    getScriptParentElement().appendChild(el);
  });
}
function _generateCallbackName(prefix) {
  return `__${prefix}${Math.floor(Math.random() * 1e6)}`;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NETWORK_TIMEOUT = new Delay(3e4, 6e4);
function resetUnloadedGapiModules() {
  const beacon = _window().___jsl;
  if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
    for (const hint of Object.keys(beacon.H)) {
      beacon.H[hint].r = beacon.H[hint].r || [];
      beacon.H[hint].L = beacon.H[hint].L || [];
      beacon.H[hint].r = [...beacon.H[hint].L];
      if (beacon.CP) {
        for (let i = 0; i < beacon.CP.length; i++) {
          beacon.CP[i] = null;
        }
      }
    }
  }
}
function loadGapi(auth2) {
  return new Promise((resolve, reject) => {
    var _a2, _b, _c2;
    function loadGapiIframe() {
      resetUnloadedGapiModules();
      gapi.load("gapi.iframes", {
        callback: () => {
          resolve(gapi.iframes.getContext());
        },
        ontimeout: () => {
          resetUnloadedGapiModules();
          reject(_createError(auth2, "network-request-failed"));
        },
        timeout: NETWORK_TIMEOUT.get()
      });
    }
    if ((_b = (_a2 = _window().gapi) === null || _a2 === void 0 ? void 0 : _a2.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) {
      resolve(gapi.iframes.getContext());
    } else if (!!((_c2 = _window().gapi) === null || _c2 === void 0 ? void 0 : _c2.load)) {
      loadGapiIframe();
    } else {
      const cbName = _generateCallbackName("iframefcb");
      _window()[cbName] = () => {
        if (!!gapi.load) {
          loadGapiIframe();
        } else {
          reject(_createError(auth2, "network-request-failed"));
        }
      };
      return _loadJS(`https://apis.google.com/js/api.js?onload=${cbName}`);
    }
  }).catch((error2) => {
    cachedGApiLoader = null;
    throw error2;
  });
}
let cachedGApiLoader = null;
function _loadGapi(auth2) {
  cachedGApiLoader = cachedGApiLoader || loadGapi(auth2);
  return cachedGApiLoader;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PING_TIMEOUT = new Delay(5e3, 15e3);
const IFRAME_PATH = "__/auth/iframe";
const EMULATED_IFRAME_PATH = "emulator/auth/iframe";
const IFRAME_ATTRIBUTES = {
  style: {
    position: "absolute",
    top: "-100px",
    width: "1px",
    height: "1px"
  }
};
const EID_FROM_APIHOST = new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"]
]);
function getIframeUrl(auth2) {
  const config2 = auth2.config;
  _assert$4(config2.authDomain, auth2, "auth-domain-config-required");
  const url = config2.emulator ? _emulatorUrl(config2, EMULATED_IFRAME_PATH) : `https://${auth2.config.authDomain}/${IFRAME_PATH}`;
  const params = {
    apiKey: config2.apiKey,
    appName: auth2.name,
    v: SDK_VERSION
  };
  const eid = EID_FROM_APIHOST.get(auth2.config.apiHost);
  if (eid) {
    params.eid = eid;
  }
  const frameworks = auth2._getFrameworks();
  if (frameworks.length) {
    params.fw = frameworks.join(",");
  }
  return `${url}?${querystring(params).slice(1)}`;
}
async function _openIframe(auth2) {
  const context = await _loadGapi(auth2);
  const gapi2 = _window().gapi;
  _assert$4(gapi2, auth2, "internal-error");
  return context.open({
    where: document.body,
    url: getIframeUrl(auth2),
    messageHandlersFilter: gapi2.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: IFRAME_ATTRIBUTES,
    dontclear: true
  }, (iframe) => new Promise(async (resolve, reject) => {
    await iframe.restyle({
      setHideOnLeave: false
    });
    const networkError = _createError(auth2, "network-request-failed");
    const networkErrorTimer = _window().setTimeout(() => {
      reject(networkError);
    }, PING_TIMEOUT.get());
    function clearTimerAndResolve() {
      _window().clearTimeout(networkErrorTimer);
      resolve(iframe);
    }
    iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, () => {
      reject(networkError);
    });
  }));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserSessionPersistence extends BrowserPersistenceClass {
  constructor() {
    super(window.sessionStorage, "SESSION");
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
}
BrowserSessionPersistence.type = "SESSION";
const browserSessionPersistence = BrowserSessionPersistence;
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BASE_POPUP_OPTIONS = {
  location: "yes",
  resizable: "yes",
  statusbar: "yes",
  toolbar: "no"
};
const DEFAULT_WIDTH = 500;
const DEFAULT_HEIGHT = 600;
const TARGET_BLANK = "_blank";
const FIREFOX_EMPTY_URL = "http://localhost";
class AuthPopup {
  constructor(window2) {
    this.window = window2;
    this.associatedEvent = null;
  }
  close() {
    if (this.window) {
      try {
        this.window.close();
      } catch (e) {
      }
    }
  }
}
function _open(auth2, url, name2, width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT) {
  const top = Math.min((window.screen.availHeight - height) / 2, 0).toString();
  const left = Math.min((window.screen.availWidth - width) / 2, 0).toString();
  let target = "";
  const options2 = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), {
    width: width.toString(),
    height: height.toString(),
    top,
    left
  });
  const ua2 = getUA().toLowerCase();
  if (name2) {
    target = _isChromeIOS(ua2) ? TARGET_BLANK : name2;
  }
  if (_isFirefox(ua2)) {
    url = url || FIREFOX_EMPTY_URL;
    options2.scrollbars = "yes";
  }
  const optionsString = Object.entries(options2).reduce((accum, [key, value]) => `${accum}${key}=${value},`, "");
  if (_isIOSStandalone(ua2) && target !== "_self") {
    openAsNewWindowIOS(url || "", target);
    return new AuthPopup(null);
  }
  const newWin = window.open(url || "", target, optionsString);
  _assert$4(newWin, auth2, "popup-blocked");
  try {
    newWin.focus();
  } catch (e) {
  }
  return new AuthPopup(newWin);
}
function openAsNewWindowIOS(url, target) {
  const el = document.createElement("a");
  el.href = url;
  el.target = target;
  const click = document.createEvent("MouseEvent");
  click.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
  el.dispatchEvent(click);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _withDefaultResolver(auth2, resolverOverride) {
  if (resolverOverride) {
    return _getInstance(resolverOverride);
  }
  _assert$4(auth2._popupRedirectResolver, auth2, "argument-error");
  return auth2._popupRedirectResolver;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdpCredential extends AuthCredential {
  constructor(params) {
    super("custom", "custom");
    this.params = params;
  }
  _getIdTokenResponse(auth2) {
    return signInWithIdp(auth2, this._buildIdpRequest());
  }
  _linkToIdToken(auth2, idToken) {
    return signInWithIdp(auth2, this._buildIdpRequest(idToken));
  }
  _getReauthenticationResolver(auth2) {
    return signInWithIdp(auth2, this._buildIdpRequest());
  }
  _buildIdpRequest(idToken) {
    const request = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: true,
      returnIdpCredential: true
    };
    if (idToken) {
      request.idToken = idToken;
    }
    return request;
  }
}
function _signIn(params) {
  return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
}
function _reauth(params) {
  const {auth: auth2, user} = params;
  _assert$4(user, auth2, "internal-error");
  return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
}
async function _link$1(params) {
  const {auth: auth2, user} = params;
  _assert$4(user, auth2, "internal-error");
  return _link(user, new IdpCredential(params), params.bypassAuthState);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AbstractPopupRedirectOperation {
  constructor(auth2, filter, resolver, user, bypassAuthState = false) {
    this.auth = auth2;
    this.resolver = resolver;
    this.user = user;
    this.bypassAuthState = bypassAuthState;
    this.pendingPromise = null;
    this.eventManager = null;
    this.filter = Array.isArray(filter) ? filter : [filter];
  }
  execute() {
    return new Promise(async (resolve, reject) => {
      this.pendingPromise = {resolve, reject};
      try {
        this.eventManager = await this.resolver._initialize(this.auth);
        await this.onExecution();
        this.eventManager.registerConsumer(this);
      } catch (e) {
        this.reject(e);
      }
    });
  }
  async onAuthEvent(event) {
    const {urlResponse, sessionId, postBody, tenantId, error: error2, type} = event;
    if (error2) {
      this.reject(error2);
      return;
    }
    const params = {
      auth: this.auth,
      requestUri: urlResponse,
      sessionId,
      tenantId: tenantId || void 0,
      postBody: postBody || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    };
    try {
      this.resolve(await this.getIdpTask(type)(params));
    } catch (e) {
      this.reject(e);
    }
  }
  onError(error2) {
    this.reject(error2);
  }
  getIdpTask(type) {
    switch (type) {
      case "signInViaPopup":
      case "signInViaRedirect":
        return _signIn;
      case "linkViaPopup":
      case "linkViaRedirect":
        return _link$1;
      case "reauthViaPopup":
      case "reauthViaRedirect":
        return _reauth;
      default:
        _fail(this.auth, "internal-error");
    }
  }
  resolve(cred) {
    debugAssert(this.pendingPromise, "Pending promise was never set");
    this.pendingPromise.resolve(cred);
    this.unregisterAndCleanUp();
  }
  reject(error2) {
    debugAssert(this.pendingPromise, "Pending promise was never set");
    this.pendingPromise.reject(error2);
    this.unregisterAndCleanUp();
  }
  unregisterAndCleanUp() {
    if (this.eventManager) {
      this.eventManager.unregisterConsumer(this);
    }
    this.pendingPromise = null;
    this.cleanUp();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_REDIRECT_KEY = "pendingRedirect";
const redirectOutcomeMap = new Map();
class RedirectAction extends AbstractPopupRedirectOperation {
  constructor(auth2, resolver, bypassAuthState = false) {
    super(auth2, [
      "signInViaRedirect",
      "linkViaRedirect",
      "reauthViaRedirect",
      "unknown"
    ], resolver, void 0, bypassAuthState);
    this.eventId = null;
  }
  async execute() {
    let readyOutcome = redirectOutcomeMap.get(this.auth._key());
    if (!readyOutcome) {
      try {
        const hasPendingRedirect = await _getAndClearPendingRedirectStatus(this.resolver, this.auth);
        const result = hasPendingRedirect ? await super.execute() : null;
        readyOutcome = () => Promise.resolve(result);
      } catch (e) {
        readyOutcome = () => Promise.reject(e);
      }
      redirectOutcomeMap.set(this.auth._key(), readyOutcome);
    }
    return readyOutcome();
  }
  async onAuthEvent(event) {
    if (event.type === "signInViaRedirect") {
      return super.onAuthEvent(event);
    } else if (event.type === "unknown") {
      this.resolve(null);
      return;
    }
    if (event.eventId) {
      const user = await this.auth._redirectUserForId(event.eventId);
      if (user) {
        this.user = user;
        return super.onAuthEvent(event);
      } else {
        this.resolve(null);
      }
    }
  }
  async onExecution() {
  }
  cleanUp() {
  }
}
async function _getAndClearPendingRedirectStatus(resolver, auth2) {
  const key = pendingRedirectKey(auth2);
  const hasPendingRedirect = await resolverPersistence(resolver)._get(key) === "true";
  await resolverPersistence(resolver)._remove(key);
  return hasPendingRedirect;
}
async function _setPendingRedirectStatus(resolver, auth2) {
  return resolverPersistence(resolver)._set(pendingRedirectKey(auth2), "true");
}
function _clearRedirectOutcomes() {
  redirectOutcomeMap.clear();
}
function resolverPersistence(resolver) {
  return _getInstance(resolver._redirectPersistence);
}
function pendingRedirectKey(auth2) {
  return _persistenceKeyName(PENDING_REDIRECT_KEY, auth2.config.apiKey, auth2.name);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function signInWithRedirect(auth2, provider, resolver) {
  return _signInWithRedirect(auth2, provider, resolver);
}
async function _signInWithRedirect(auth2, provider, resolver) {
  const authInternal = _castAuth(auth2);
  _assert$4(provider instanceof FederatedAuthProvider, auth2, "argument-error");
  const resolverInternal = _withDefaultResolver(authInternal, resolver);
  await _setPendingRedirectStatus(resolverInternal, authInternal);
  return resolverInternal._openRedirect(authInternal, provider, "signInViaRedirect");
}
function reauthenticateWithRedirect(user, provider, resolver) {
  return _reauthenticateWithRedirect(user, provider, resolver);
}
async function _reauthenticateWithRedirect(user, provider, resolver) {
  const userInternal = getModularInstance(user);
  _assert$4(provider instanceof FederatedAuthProvider, userInternal.auth, "argument-error");
  const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
  await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
  const eventId = await prepareUserForRedirect(userInternal);
  return resolverInternal._openRedirect(userInternal.auth, provider, "reauthViaRedirect", eventId);
}
function linkWithRedirect(user, provider, resolver) {
  return _linkWithRedirect(user, provider, resolver);
}
async function _linkWithRedirect(user, provider, resolver) {
  const userInternal = getModularInstance(user);
  _assert$4(provider instanceof FederatedAuthProvider, userInternal.auth, "argument-error");
  const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
  await _assertLinkedStatus(false, userInternal, provider.providerId);
  await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
  const eventId = await prepareUserForRedirect(userInternal);
  return resolverInternal._openRedirect(userInternal.auth, provider, "linkViaRedirect", eventId);
}
async function getRedirectResult(auth2, resolver) {
  await _castAuth(auth2)._initializationPromise;
  return _getRedirectResult(auth2, resolver, false);
}
async function _getRedirectResult(auth2, resolverExtern, bypassAuthState = false) {
  const authInternal = _castAuth(auth2);
  const resolver = _withDefaultResolver(authInternal, resolverExtern);
  const action = new RedirectAction(authInternal, resolver, bypassAuthState);
  const result = await action.execute();
  if (result && !bypassAuthState) {
    delete result.user._redirectEventId;
    await authInternal._persistUserIfCurrent(result.user);
    await authInternal._setRedirectUser(null, resolverExtern);
  }
  return result;
}
async function prepareUserForRedirect(user) {
  const eventId = _generateEventId(`${user.uid}:::`);
  user._redirectEventId = eventId;
  await user.auth._setRedirectUser(user);
  await user.auth._persistUserIfCurrent(user);
  return eventId;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WIDGET_PATH = "__/auth/handler";
const EMULATOR_WIDGET_PATH = "emulator/auth/handler";
function _getRedirectUrl(auth2, provider, authType, redirectUrl, eventId, additionalParams) {
  _assert$4(auth2.config.authDomain, auth2, "auth-domain-config-required");
  _assert$4(auth2.config.apiKey, auth2, "invalid-api-key");
  const params = {
    apiKey: auth2.config.apiKey,
    appName: auth2.name,
    authType,
    redirectUrl,
    v: SDK_VERSION,
    eventId
  };
  if (provider instanceof FederatedAuthProvider) {
    provider.setDefaultLanguage(auth2.languageCode);
    params.providerId = provider.providerId || "";
    if (!isEmpty(provider.getCustomParameters())) {
      params.customParameters = JSON.stringify(provider.getCustomParameters());
    }
    for (const [key, value] of Object.entries(additionalParams || {})) {
      params[key] = value;
    }
  }
  if (provider instanceof BaseOAuthProvider) {
    const scopes = provider.getScopes().filter((scope) => scope !== "");
    if (scopes.length > 0) {
      params.scopes = scopes.join(",");
    }
  }
  if (auth2.tenantId) {
    params.tid = auth2.tenantId;
  }
  const paramsDict = params;
  for (const key of Object.keys(paramsDict)) {
    if (paramsDict[key] === void 0) {
      delete paramsDict[key];
    }
  }
  return `${getHandlerBase(auth2)}?${querystring(paramsDict).slice(1)}`;
}
function getHandlerBase({config: config2}) {
  if (!config2.emulator) {
    return `https://${config2.authDomain}/${WIDGET_PATH}`;
  }
  return _emulatorUrl(config2, EMULATOR_WIDGET_PATH);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WEB_STORAGE_SUPPORT_KEY = "webStorageSupport";
class BrowserPopupRedirectResolver {
  constructor() {
    this.eventManagers = {};
    this.iframes = {};
    this.originValidationPromises = {};
    this._redirectPersistence = browserSessionPersistence;
    this._completeRedirectFn = _getRedirectResult;
  }
  async _openPopup(auth2, provider, authType, eventId) {
    var _a2;
    debugAssert((_a2 = this.eventManagers[auth2._key()]) === null || _a2 === void 0 ? void 0 : _a2.manager, "_initialize() not called before _openPopup()");
    const url = _getRedirectUrl(auth2, provider, authType, _getCurrentUrl(), eventId);
    return _open(auth2, url, _generateEventId());
  }
  async _openRedirect(auth2, provider, authType, eventId) {
    await this._originValidation(auth2);
    _setWindowLocation(_getRedirectUrl(auth2, provider, authType, _getCurrentUrl(), eventId));
    return new Promise(() => {
    });
  }
  _initialize(auth2) {
    const key = auth2._key();
    if (this.eventManagers[key]) {
      const {manager, promise: promise2} = this.eventManagers[key];
      if (manager) {
        return Promise.resolve(manager);
      } else {
        debugAssert(promise2, "If manager is not set, promise should be");
        return promise2;
      }
    }
    const promise = this.initAndGetManager(auth2);
    this.eventManagers[key] = {promise};
    return promise;
  }
  async initAndGetManager(auth2) {
    const iframe = await _openIframe(auth2);
    const manager = new AuthEventManager(auth2);
    iframe.register("authEvent", (iframeEvent) => {
      _assert$4(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth2, "invalid-auth-event");
      const handled = manager.onEvent(iframeEvent.authEvent);
      return {status: handled ? "ACK" : "ERROR"};
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
    this.eventManagers[auth2._key()] = {manager};
    this.iframes[auth2._key()] = iframe;
    return manager;
  }
  _isIframeWebStorageSupported(auth2, cb2) {
    const iframe = this.iframes[auth2._key()];
    iframe.send(WEB_STORAGE_SUPPORT_KEY, {type: WEB_STORAGE_SUPPORT_KEY}, (result) => {
      var _a2;
      const isSupported = (_a2 = result === null || result === void 0 ? void 0 : result[0]) === null || _a2 === void 0 ? void 0 : _a2[WEB_STORAGE_SUPPORT_KEY];
      if (isSupported !== void 0) {
        cb2(!!isSupported);
      }
      _fail(auth2, "internal-error");
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  }
  _originValidation(auth2) {
    const key = auth2._key();
    if (!this.originValidationPromises[key]) {
      this.originValidationPromises[key] = _validateOrigin(auth2);
    }
    return this.originValidationPromises[key];
  }
  get _shouldInitProactively() {
    return _isMobileBrowser() || _isSafari() || _isIOS();
  }
}
const browserPopupRedirectResolver = BrowserPopupRedirectResolver;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startSignInPhoneMfa(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v2/accounts/mfaSignIn:start", Object.assign({tenantId: auth2.tenantId}, request));
}
function finalizeSignInPhoneMfa(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v2/accounts/mfaSignIn:finalize", Object.assign({tenantId: auth2.tenantId}, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getRecaptchaParams(auth2) {
  return (await _performApiRequest(auth2, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || "";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _SOLVE_TIME_MS = 500;
const _EXPIRATION_TIME_MS = 6e4;
const _WIDGET_ID_START = 1e12;
class MockReCaptcha {
  constructor(auth2) {
    this.auth = auth2;
    this.counter = _WIDGET_ID_START;
    this._widgets = new Map();
  }
  render(container, parameters) {
    const id2 = this.counter;
    this._widgets.set(id2, new MockWidget(container, this.auth.name, parameters || {}));
    this.counter++;
    return id2;
  }
  reset(optWidgetId) {
    var _a2;
    const id2 = optWidgetId || _WIDGET_ID_START;
    void ((_a2 = this._widgets.get(id2)) === null || _a2 === void 0 ? void 0 : _a2.delete());
    this._widgets.delete(id2);
  }
  getResponse(optWidgetId) {
    var _a2;
    const id2 = optWidgetId || _WIDGET_ID_START;
    return ((_a2 = this._widgets.get(id2)) === null || _a2 === void 0 ? void 0 : _a2.getResponse()) || "";
  }
  async execute(optWidgetId) {
    var _a2;
    const id2 = optWidgetId || _WIDGET_ID_START;
    void ((_a2 = this._widgets.get(id2)) === null || _a2 === void 0 ? void 0 : _a2.execute());
    return "";
  }
}
class MockWidget {
  constructor(containerOrId, appName, params) {
    this.params = params;
    this.timerId = null;
    this.deleted = false;
    this.responseToken = null;
    this.clickHandler = () => {
      this.execute();
    };
    const container = typeof containerOrId === "string" ? document.getElementById(containerOrId) : containerOrId;
    _assert$4(container, "argument-error", {appName});
    this.container = container;
    this.isVisible = this.params.size !== "invisible";
    if (this.isVisible) {
      this.execute();
    } else {
      this.container.addEventListener("click", this.clickHandler);
    }
  }
  getResponse() {
    this.checkIfDeleted();
    return this.responseToken;
  }
  delete() {
    this.checkIfDeleted();
    this.deleted = true;
    if (this.timerId) {
      clearTimeout(this.timerId);
      this.timerId = null;
    }
    this.container.removeEventListener("click", this.clickHandler);
  }
  execute() {
    this.checkIfDeleted();
    if (this.timerId) {
      return;
    }
    this.timerId = window.setTimeout(() => {
      this.responseToken = generateRandomAlphaNumericString(50);
      const {callback, "expired-callback": expiredCallback} = this.params;
      if (callback) {
        try {
          callback(this.responseToken);
        } catch (e) {
        }
      }
      this.timerId = window.setTimeout(() => {
        this.timerId = null;
        this.responseToken = null;
        if (expiredCallback) {
          try {
            expiredCallback();
          } catch (e) {
          }
        }
        if (this.isVisible) {
          this.execute();
        }
      }, _EXPIRATION_TIME_MS);
    }, _SOLVE_TIME_MS);
  }
  checkIfDeleted() {
    if (this.deleted) {
      throw new Error("reCAPTCHA mock was already deleted!");
    }
  }
}
function generateRandomAlphaNumericString(len) {
  const chars = [];
  const allowedChars = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let i = 0; i < len; i++) {
    chars.push(allowedChars.charAt(Math.floor(Math.random() * allowedChars.length)));
  }
  return chars.join("");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _JSLOAD_CALLBACK = _generateCallbackName("rcb");
const NETWORK_TIMEOUT_DELAY = new Delay(3e4, 6e4);
const RECAPTCHA_BASE = "https://www.google.com/recaptcha/api.js?";
class ReCaptchaLoaderImpl {
  constructor() {
    this.hostLanguage = "";
    this.counter = 0;
    this.librarySeparatelyLoaded = !!_window().grecaptcha;
  }
  load(auth2, hl = "") {
    _assert$4(isHostLanguageValid(hl), auth2, "argument-error");
    if (this.shouldResolveImmediately(hl)) {
      return Promise.resolve(_window().grecaptcha);
    }
    return new Promise((resolve, reject) => {
      const networkTimeout = _window().setTimeout(() => {
        reject(_createError(auth2, "network-request-failed"));
      }, NETWORK_TIMEOUT_DELAY.get());
      _window()[_JSLOAD_CALLBACK] = () => {
        _window().clearTimeout(networkTimeout);
        delete _window()[_JSLOAD_CALLBACK];
        const recaptcha = _window().grecaptcha;
        if (!recaptcha) {
          reject(_createError(auth2, "internal-error"));
          return;
        }
        const render2 = recaptcha.render;
        recaptcha.render = (container, params) => {
          const widgetId = render2(container, params);
          this.counter++;
          return widgetId;
        };
        this.hostLanguage = hl;
        resolve(recaptcha);
      };
      const url = `${RECAPTCHA_BASE}?${querystring({
        onload: _JSLOAD_CALLBACK,
        render: "explicit",
        hl
      })}`;
      _loadJS(url).catch(() => {
        clearTimeout(networkTimeout);
        reject(_createError(auth2, "internal-error"));
      });
    });
  }
  clearedOneInstance() {
    this.counter--;
  }
  shouldResolveImmediately(hl) {
    return !!_window().grecaptcha && (hl === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded);
  }
}
function isHostLanguageValid(hl) {
  return hl.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(hl);
}
class MockReCaptchaLoaderImpl {
  async load(auth2) {
    return new MockReCaptcha(auth2);
  }
  clearedOneInstance() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RECAPTCHA_VERIFIER_TYPE = "recaptcha";
const DEFAULT_PARAMS = {
  theme: "light",
  type: "image"
};
class RecaptchaVerifier$1 {
  constructor(containerOrId, parameters = Object.assign({}, DEFAULT_PARAMS), authExtern) {
    this.parameters = parameters;
    this.type = RECAPTCHA_VERIFIER_TYPE;
    this.destroyed = false;
    this.widgetId = null;
    this.tokenChangeListeners = new Set();
    this.renderPromise = null;
    this.recaptcha = null;
    this.auth = _castAuth(authExtern);
    this.isInvisible = this.parameters.size === "invisible";
    _assert$4(typeof document !== "undefined", this.auth, "operation-not-supported-in-this-environment");
    const container = typeof containerOrId === "string" ? document.getElementById(containerOrId) : containerOrId;
    _assert$4(container, this.auth, "argument-error");
    this.container = container;
    this.parameters.callback = this.makeTokenCallback(this.parameters.callback);
    this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new MockReCaptchaLoaderImpl() : new ReCaptchaLoaderImpl();
    this.validateStartingState();
  }
  async verify() {
    this.assertNotDestroyed();
    const id2 = await this.render();
    const recaptcha = this.getAssertedRecaptcha();
    const response = recaptcha.getResponse(id2);
    if (response) {
      return response;
    }
    return new Promise((resolve) => {
      const tokenChange = (token) => {
        if (!token) {
          return;
        }
        this.tokenChangeListeners.delete(tokenChange);
        resolve(token);
      };
      this.tokenChangeListeners.add(tokenChange);
      if (this.isInvisible) {
        recaptcha.execute(id2);
      }
    });
  }
  render() {
    try {
      this.assertNotDestroyed();
    } catch (e) {
      return Promise.reject(e);
    }
    if (this.renderPromise) {
      return this.renderPromise;
    }
    this.renderPromise = this.makeRenderPromise().catch((e) => {
      this.renderPromise = null;
      throw e;
    });
    return this.renderPromise;
  }
  _reset() {
    this.assertNotDestroyed();
    if (this.widgetId !== null) {
      this.getAssertedRecaptcha().reset(this.widgetId);
    }
  }
  clear() {
    this.assertNotDestroyed();
    this.destroyed = true;
    this._recaptchaLoader.clearedOneInstance();
    if (!this.isInvisible) {
      this.container.childNodes.forEach((node) => {
        this.container.removeChild(node);
      });
    }
  }
  validateStartingState() {
    _assert$4(!this.parameters.sitekey, this.auth, "argument-error");
    _assert$4(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error");
    _assert$4(typeof document !== "undefined", this.auth, "operation-not-supported-in-this-environment");
  }
  makeTokenCallback(existing) {
    return (token) => {
      this.tokenChangeListeners.forEach((listener) => listener(token));
      if (typeof existing === "function") {
        existing(token);
      } else if (typeof existing === "string") {
        const globalFunc = _window()[existing];
        if (typeof globalFunc === "function") {
          globalFunc(token);
        }
      }
    };
  }
  assertNotDestroyed() {
    _assert$4(!this.destroyed, this.auth, "internal-error");
  }
  async makeRenderPromise() {
    await this.init();
    if (!this.widgetId) {
      let container = this.container;
      if (!this.isInvisible) {
        const guaranteedEmpty = document.createElement("div");
        container.appendChild(guaranteedEmpty);
        container = guaranteedEmpty;
      }
      this.widgetId = this.getAssertedRecaptcha().render(container, this.parameters);
    }
    return this.widgetId;
  }
  async init() {
    _assert$4(_isHttpOrHttps$1() && !_isWorker$1(), this.auth, "internal-error");
    await domReady();
    this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0);
    const siteKey = await getRecaptchaParams(this.auth);
    _assert$4(siteKey, this.auth, "internal-error");
    this.parameters.sitekey = siteKey;
  }
  getAssertedRecaptcha() {
    _assert$4(this.recaptcha, this.auth, "internal-error");
    return this.recaptcha;
  }
}
function domReady() {
  let resolver = null;
  return new Promise((resolve) => {
    if (document.readyState === "complete") {
      resolve();
      return;
    }
    resolver = () => resolve();
    window.addEventListener("load", resolver);
  }).catch((e) => {
    if (resolver) {
      window.removeEventListener("load", resolver);
    }
    throw e;
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConfirmationResultImpl {
  constructor(verificationId, onConfirmation) {
    this.verificationId = verificationId;
    this.onConfirmation = onConfirmation;
  }
  confirm(verificationCode) {
    const authCredential = PhoneAuthCredential._fromVerification(this.verificationId, verificationCode);
    return this.onConfirmation(authCredential);
  }
}
async function signInWithPhoneNumber$1(auth2, phoneNumber, appVerifier) {
  const authInternal = _castAuth(auth2);
  const verificationId = await _verifyPhoneNumber(authInternal, phoneNumber, getModularInstance(appVerifier));
  return new ConfirmationResultImpl(verificationId, (cred) => signInWithCredential(authInternal, cred));
}
async function linkWithPhoneNumber$1(user, phoneNumber, appVerifier) {
  const userInternal = getModularInstance(user);
  await _assertLinkedStatus(false, userInternal, "phone");
  const verificationId = await _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier));
  return new ConfirmationResultImpl(verificationId, (cred) => linkWithCredential(userInternal, cred));
}
async function reauthenticateWithPhoneNumber(user, phoneNumber, appVerifier) {
  const userInternal = getModularInstance(user);
  const verificationId = await _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier));
  return new ConfirmationResultImpl(verificationId, (cred) => reauthenticateWithCredential(userInternal, cred));
}
async function _verifyPhoneNumber(auth2, options2, verifier) {
  var _a2;
  const recaptchaToken = await verifier.verify();
  try {
    _assert$4(typeof recaptchaToken === "string", auth2, "argument-error");
    _assert$4(verifier.type === RECAPTCHA_VERIFIER_TYPE, auth2, "argument-error");
    let phoneInfoOptions;
    if (typeof options2 === "string") {
      phoneInfoOptions = {
        phoneNumber: options2
      };
    } else {
      phoneInfoOptions = options2;
    }
    if ("session" in phoneInfoOptions) {
      const session2 = phoneInfoOptions.session;
      if ("phoneNumber" in phoneInfoOptions) {
        _assert$4(session2.type === "enroll", auth2, "internal-error");
        const response = await startEnrollPhoneMfa(auth2, {
          idToken: session2.credential,
          phoneEnrollmentInfo: {
            phoneNumber: phoneInfoOptions.phoneNumber,
            recaptchaToken
          }
        });
        return response.phoneSessionInfo.sessionInfo;
      } else {
        _assert$4(session2.type === "signin", auth2, "internal-error");
        const mfaEnrollmentId = ((_a2 = phoneInfoOptions.multiFactorHint) === null || _a2 === void 0 ? void 0 : _a2.uid) || phoneInfoOptions.multiFactorUid;
        _assert$4(mfaEnrollmentId, auth2, "missing-multi-factor-info");
        const response = await startSignInPhoneMfa(auth2, {
          mfaPendingCredential: session2.credential,
          mfaEnrollmentId,
          phoneSignInInfo: {
            recaptchaToken
          }
        });
        return response.phoneResponseInfo.sessionInfo;
      }
    } else {
      const {sessionInfo} = await sendPhoneVerificationCode(auth2, {
        phoneNumber: phoneInfoOptions.phoneNumber,
        recaptchaToken
      });
      return sessionInfo;
    }
  } finally {
    verifier._reset();
  }
}
async function updatePhoneNumber(user, credential) {
  await _link(getModularInstance(user), credential);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PhoneAuthProvider$1 {
  constructor(auth2) {
    this.providerId = PhoneAuthProvider$1.PROVIDER_ID;
    this.auth = _castAuth(auth2);
  }
  verifyPhoneNumber(phoneOptions, applicationVerifier) {
    return _verifyPhoneNumber(this.auth, phoneOptions, getModularInstance(applicationVerifier));
  }
  static credential(verificationId, verificationCode) {
    return PhoneAuthCredential._fromVerification(verificationId, verificationCode);
  }
  static credentialFromResult(userCredential) {
    const credential = userCredential;
    return PhoneAuthProvider$1.credentialFromTaggedObject(credential);
  }
  static credentialFromError(error2) {
    return PhoneAuthProvider$1.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({_tokenResponse: tokenResponse}) {
    if (!tokenResponse) {
      return null;
    }
    const {phoneNumber, temporaryProof} = tokenResponse;
    if (phoneNumber && temporaryProof) {
      return PhoneAuthCredential._fromTokenResponse(phoneNumber, temporaryProof);
    }
    return null;
  }
}
PhoneAuthProvider$1.PROVIDER_ID = "phone";
PhoneAuthProvider$1.PHONE_SIGN_IN_METHOD = "phone";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2e3, 1e4);
async function signInWithPopup(auth2, provider, resolver) {
  const authInternal = _castAuth(auth2);
  _assert$4(provider instanceof FederatedAuthProvider, auth2, "argument-error");
  const resolverInternal = _withDefaultResolver(authInternal, resolver);
  const action = new PopupOperation(authInternal, "signInViaPopup", provider, resolverInternal);
  return action.executeNotNull();
}
async function reauthenticateWithPopup(user, provider, resolver) {
  const userInternal = getModularInstance(user);
  _assert$4(provider instanceof FederatedAuthProvider, userInternal.auth, "argument-error");
  const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
  const action = new PopupOperation(userInternal.auth, "reauthViaPopup", provider, resolverInternal, userInternal);
  return action.executeNotNull();
}
async function linkWithPopup(user, provider, resolver) {
  const userInternal = getModularInstance(user);
  _assert$4(provider instanceof FederatedAuthProvider, userInternal.auth, "argument-error");
  const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
  const action = new PopupOperation(userInternal.auth, "linkViaPopup", provider, resolverInternal, userInternal);
  return action.executeNotNull();
}
class PopupOperation extends AbstractPopupRedirectOperation {
  constructor(auth2, filter, provider, resolver, user) {
    super(auth2, filter, resolver, user);
    this.provider = provider;
    this.authWindow = null;
    this.pollId = null;
    if (PopupOperation.currentPopupAction) {
      PopupOperation.currentPopupAction.cancel();
    }
    PopupOperation.currentPopupAction = this;
  }
  async executeNotNull() {
    const result = await this.execute();
    _assert$4(result, this.auth, "internal-error");
    return result;
  }
  async onExecution() {
    debugAssert(this.filter.length === 1, "Popup operations only handle one event");
    const eventId = _generateEventId();
    this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], eventId);
    this.authWindow.associatedEvent = eventId;
    this.resolver._originValidation(this.auth).catch((e) => {
      this.reject(e);
    });
    this.resolver._isIframeWebStorageSupported(this.auth, (isSupported) => {
      if (!isSupported) {
        this.reject(_createError(this.auth, "web-storage-unsupported"));
      }
    });
    this.pollUserCancellation();
  }
  get eventId() {
    var _a2;
    return ((_a2 = this.authWindow) === null || _a2 === void 0 ? void 0 : _a2.associatedEvent) || null;
  }
  cancel() {
    this.reject(_createError(this.auth, "cancelled-popup-request"));
  }
  cleanUp() {
    if (this.authWindow) {
      this.authWindow.close();
    }
    if (this.pollId) {
      window.clearTimeout(this.pollId);
    }
    this.authWindow = null;
    this.pollId = null;
    PopupOperation.currentPopupAction = null;
  }
  pollUserCancellation() {
    const poll = () => {
      var _a2, _b;
      if ((_b = (_a2 = this.authWindow) === null || _a2 === void 0 ? void 0 : _a2.window) === null || _b === void 0 ? void 0 : _b.closed) {
        this.pollId = window.setTimeout(() => {
          this.pollId = null;
          this.reject(_createError(this.auth, "popup-closed-by-user"));
        }, 2e3);
        return;
      }
      this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
    };
    poll();
  }
}
PopupOperation.currentPopupAction = null;
class MultiFactorAssertionImpl {
  constructor(factorId) {
    this.factorId = factorId;
  }
  _process(auth2, session2, displayName) {
    switch (session2.type) {
      case "enroll":
        return this._finalizeEnroll(auth2, session2.credential, displayName);
      case "signin":
        return this._finalizeSignIn(auth2, session2.credential);
      default:
        return debugFail("unexpected MultiFactorSessionType");
    }
  }
}
class PhoneMultiFactorAssertionImpl extends MultiFactorAssertionImpl {
  constructor(credential) {
    super("phone");
    this.credential = credential;
  }
  static _fromCredential(credential) {
    return new PhoneMultiFactorAssertionImpl(credential);
  }
  _finalizeEnroll(auth2, idToken, displayName) {
    return finalizeEnrollPhoneMfa(auth2, {
      idToken,
      displayName,
      phoneVerificationInfo: this.credential._makeVerificationRequest()
    });
  }
  _finalizeSignIn(auth2, mfaPendingCredential) {
    return finalizeSignInPhoneMfa(auth2, {
      mfaPendingCredential,
      phoneVerificationInfo: this.credential._makeVerificationRequest()
    });
  }
}
class PhoneMultiFactorGenerator {
  constructor() {
  }
  static assertion(credential) {
    return PhoneMultiFactorAssertionImpl._fromCredential(credential);
  }
}
registerAuth("Browser");
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _cordovaWindow() {
  return window;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const REDIRECT_TIMEOUT_MS = 2e3;
async function _generateHandlerUrl(auth2, event, provider) {
  var _a2;
  const {BuildInfo} = _cordovaWindow();
  debugAssert(event.sessionId, "AuthEvent did not contain a session ID");
  const sessionDigest = await computeSha256(event.sessionId);
  const additionalParams = {};
  if (_isIOS()) {
    additionalParams["ibi"] = BuildInfo.packageName;
  } else if (_isAndroid()) {
    additionalParams["apn"] = BuildInfo.packageName;
  } else {
    _fail(auth2, "operation-not-supported-in-this-environment");
  }
  if (BuildInfo.displayName) {
    additionalParams["appDisplayName"] = BuildInfo.displayName;
  }
  additionalParams["sessionId"] = sessionDigest;
  return _getRedirectUrl(auth2, provider, event.type, void 0, (_a2 = event.eventId) !== null && _a2 !== void 0 ? _a2 : void 0, additionalParams);
}
function _performRedirect(handlerUrl) {
  const {cordova} = _cordovaWindow();
  return new Promise((resolve) => {
    cordova.plugins.browsertab.isAvailable((browserTabIsAvailable) => {
      let iabRef = null;
      if (browserTabIsAvailable) {
        cordova.plugins.browsertab.openUrl(handlerUrl);
      } else {
        iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? "_blank" : "_system", "location=yes");
      }
      resolve(iabRef);
    });
  });
}
async function _waitForAppResume(auth2, eventListener, iabRef) {
  const {cordova} = _cordovaWindow();
  let cleanup = () => {
  };
  try {
    await new Promise((resolve, reject) => {
      let onCloseTimer = null;
      function authEventSeen() {
        var _a2;
        resolve();
        const closeBrowserTab = (_a2 = cordova.plugins.browsertab) === null || _a2 === void 0 ? void 0 : _a2.close;
        if (typeof closeBrowserTab === "function") {
          closeBrowserTab();
        }
        if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === "function") {
          iabRef.close();
        }
      }
      function resumed() {
        if (onCloseTimer) {
          return;
        }
        onCloseTimer = window.setTimeout(() => {
          reject(_createError(auth2, "redirect-cancelled-by-user"));
        }, REDIRECT_TIMEOUT_MS);
      }
      function visibilityChanged() {
        if ((document === null || document === void 0 ? void 0 : document.visibilityState) === "visible") {
          resumed();
        }
      }
      eventListener.addPassiveListener(authEventSeen);
      document.addEventListener("resume", resumed, false);
      if (_isAndroid()) {
        document.addEventListener("visibilitychange", visibilityChanged, false);
      }
      cleanup = () => {
        eventListener.removePassiveListener(authEventSeen);
        document.removeEventListener("resume", resumed, false);
        document.removeEventListener("visibilitychange", visibilityChanged, false);
        if (onCloseTimer) {
          window.clearTimeout(onCloseTimer);
        }
      };
    });
  } finally {
    cleanup();
  }
}
function _checkCordovaConfiguration(auth2) {
  var _a2, _b, _c2, _d, _e2, _f, _g, _h2, _j, _k;
  const win = _cordovaWindow();
  _assert$4(typeof ((_a2 = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a2 === void 0 ? void 0 : _a2.subscribe) === "function", auth2, "invalid-cordova-configuration", {
    missingPlugin: "cordova-universal-links-plugin-fix"
  });
  _assert$4(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== "undefined", auth2, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-buildInfo"
  });
  _assert$4(typeof ((_e2 = (_d = (_c2 = win === null || win === void 0 ? void 0 : win.cordova) === null || _c2 === void 0 ? void 0 : _c2.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e2 === void 0 ? void 0 : _e2.openUrl) === "function", auth2, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert$4(typeof ((_h2 = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h2 === void 0 ? void 0 : _h2.isAvailable) === "function", auth2, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-browsertab"
  });
  _assert$4(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === "function", auth2, "invalid-cordova-configuration", {
    missingPlugin: "cordova-plugin-inappbrowser"
  });
}
async function computeSha256(sessionId) {
  const bytes = stringToArrayBuffer(sessionId);
  const buf = await crypto.subtle.digest("SHA-256", bytes);
  const arr = Array.from(new Uint8Array(buf));
  return arr.map((num) => num.toString(16).padStart(2, "0")).join("");
}
function stringToArrayBuffer(str) {
  debugAssert(/[0-9a-zA-Z]+/.test(str), "Can only convert alpha-numeric strings");
  if (typeof TextEncoder !== "undefined") {
    return new TextEncoder().encode(str);
  }
  const buff = new ArrayBuffer(str.length);
  const view = new Uint8Array(buff);
  for (let i = 0; i < str.length; i++) {
    view[i] = str.charCodeAt(i);
  }
  return view;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SESSION_ID_LENGTH = 20;
class CordovaAuthEventManager extends AuthEventManager {
  constructor() {
    super(...arguments);
    this.passiveListeners = new Set();
    this.initPromise = new Promise((resolve) => {
      this.resolveInialized = resolve;
    });
  }
  addPassiveListener(cb2) {
    this.passiveListeners.add(cb2);
  }
  removePassiveListener(cb2) {
    this.passiveListeners.delete(cb2);
  }
  resetRedirect() {
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
  }
  onEvent(event) {
    this.resolveInialized();
    this.passiveListeners.forEach((cb2) => cb2(event));
    return super.onEvent(event);
  }
  async initialized() {
    await this.initPromise;
  }
}
function _generateNewEvent(auth2, type, eventId = null) {
  return {
    type,
    eventId,
    urlResponse: null,
    sessionId: generateSessionId(),
    postBody: null,
    tenantId: auth2.tenantId,
    error: _createError(auth2, "no-auth-event")
  };
}
function _savePartialEvent(auth2, event) {
  return storage()._set(persistenceKey(auth2), event);
}
async function _getAndRemoveEvent(auth2) {
  const event = await storage()._get(persistenceKey(auth2));
  if (event) {
    await storage()._remove(persistenceKey(auth2));
  }
  return event;
}
function _eventFromPartialAndUrl(partialEvent, url) {
  var _a2, _b;
  const callbackUrl = _getDeepLinkFromCallback(url);
  if (callbackUrl.includes("/__/auth/callback")) {
    const params = searchParamsOrEmpty(callbackUrl);
    const errorObject = params["firebaseError"] ? parseJsonOrNull(decodeURIComponent(params["firebaseError"])) : null;
    const code = (_b = (_a2 = errorObject === null || errorObject === void 0 ? void 0 : errorObject["code"]) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")) === null || _b === void 0 ? void 0 : _b[1];
    const error2 = code ? _createError(code) : null;
    if (error2) {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        error: error2,
        urlResponse: null,
        sessionId: null,
        postBody: null
      };
    } else {
      return {
        type: partialEvent.type,
        eventId: partialEvent.eventId,
        tenantId: partialEvent.tenantId,
        sessionId: partialEvent.sessionId,
        urlResponse: callbackUrl,
        postBody: null
      };
    }
  }
  return null;
}
function generateSessionId() {
  const chars = [];
  const allowedChars = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let i = 0; i < SESSION_ID_LENGTH; i++) {
    const idx = Math.floor(Math.random() * allowedChars.length);
    chars.push(allowedChars.charAt(idx));
  }
  return chars.join("");
}
function storage() {
  return _getInstance(browserLocalPersistence);
}
function persistenceKey(auth2) {
  return _persistenceKeyName("authEvent", auth2.config.apiKey, auth2.name);
}
function parseJsonOrNull(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
function _getDeepLinkFromCallback(url) {
  const params = searchParamsOrEmpty(url);
  const link = params["link"] ? decodeURIComponent(params["link"]) : void 0;
  const doubleDeepLink = searchParamsOrEmpty(link)["link"];
  const iOSDeepLink = params["deep_link_id"] ? decodeURIComponent(params["deep_link_id"]) : void 0;
  const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)["link"];
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
function searchParamsOrEmpty(url) {
  if (!(url === null || url === void 0 ? void 0 : url.includes("?"))) {
    return {};
  }
  const [_, ...rest] = url.split("?");
  return querystringDecode(rest.join("?"));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const INITIAL_EVENT_TIMEOUT_MS = 500;
class CordovaPopupRedirectResolver {
  constructor() {
    this._redirectPersistence = browserSessionPersistence;
    this._shouldInitProactively = true;
    this.eventManagers = new Map();
    this._completeRedirectFn = _getRedirectResult;
  }
  async _initialize(auth2) {
    const key = auth2._key();
    let manager = this.eventManagers.get(key);
    if (!manager) {
      manager = new CordovaAuthEventManager(auth2);
      this.eventManagers.set(key, manager);
      this.attachCallbackListeners(auth2, manager);
    }
    return manager;
  }
  _openPopup(auth2) {
    _fail(auth2, "operation-not-supported-in-this-environment");
  }
  async _openRedirect(auth2, provider, authType, eventId) {
    _checkCordovaConfiguration(auth2);
    const manager = await this._initialize(auth2);
    await manager.initialized();
    manager.resetRedirect();
    _clearRedirectOutcomes();
    const event = _generateNewEvent(auth2, authType, eventId);
    await _savePartialEvent(auth2, event);
    const url = await _generateHandlerUrl(auth2, event, provider);
    const iabRef = await _performRedirect(url);
    return _waitForAppResume(auth2, manager, iabRef);
  }
  _isIframeWebStorageSupported(_auth, _cb) {
    throw new Error("Method not implemented.");
  }
  _originValidation() {
    return Promise.resolve();
  }
  attachCallbackListeners(auth2, manager) {
    const {universalLinks, handleOpenURL, BuildInfo} = _cordovaWindow();
    const noEventTimeout = setTimeout(async () => {
      await _getAndRemoveEvent(auth2);
      manager.onEvent(generateNoEvent());
    }, INITIAL_EVENT_TIMEOUT_MS);
    const universalLinksCb = async (eventData) => {
      clearTimeout(noEventTimeout);
      const partialEvent = await _getAndRemoveEvent(auth2);
      let finalEvent = null;
      if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData["url"])) {
        finalEvent = _eventFromPartialAndUrl(partialEvent, eventData["url"]);
      }
      manager.onEvent(finalEvent || generateNoEvent());
    };
    if (typeof universalLinks !== "undefined" && typeof universalLinks.subscribe === "function") {
      universalLinks.subscribe(null, universalLinksCb);
    }
    const existingHandleOpenURL = handleOpenURL;
    const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;
    _cordovaWindow().handleOpenURL = async (url) => {
      if (url.toLowerCase().startsWith(packagePrefix)) {
        universalLinksCb({url});
      }
      if (typeof existingHandleOpenURL === "function") {
        try {
          existingHandleOpenURL(url);
        } catch (e) {
          console.error(e);
        }
      }
    };
  }
}
const cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;
function generateNoEvent() {
  return {
    type: "unknown",
    eventId: null,
    sessionId: null,
    urlResponse: null,
    postBody: null,
    tenantId: null,
    error: _createError("no-auth-event")
  };
}
var name$1 = "@firebase/auth-compat";
var version$2 = "0.0.900-exp.894b5da5a";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1e3;
function _getCurrentScheme() {
  var _a2;
  return ((_a2 = self === null || self === void 0 ? void 0 : self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _isAndroidOrIosCordovaScheme(ua2 = getUA()) {
  return !!((_getCurrentScheme() === "file:" || _getCurrentScheme() === "ionic:") && ua2.toLowerCase().match(/iphone|ipad|ipod|android/));
}
function _isNativeEnvironment() {
  return isReactNative() || isNode();
}
function _isIe11() {
  return isIE() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
function _isEdge(ua2 = getUA()) {
  return /Edge\/\d+/.test(ua2);
}
function _isLocalStorageNotSynchronized(ua2 = getUA()) {
  return _isIe11() || _isEdge(ua2);
}
function _isWebStorageSupported() {
  try {
    const storage2 = self.localStorage;
    const key = _generateEventId();
    if (storage2) {
      storage2["setItem"](key, "1");
      storage2["removeItem"](key);
      if (_isLocalStorageNotSynchronized()) {
        return isIndexedDBAvailable();
      }
      return true;
    }
  } catch (e) {
    return _isWorker() && isIndexedDBAvailable();
  }
  return false;
}
function _isWorker() {
  return typeof global !== "undefined" && "WorkerGlobalScope" in global && "importScripts" in global;
}
function _isPopupRedirectSupported() {
  return (_isHttpOrHttps() || isBrowserExtension() || _isAndroidOrIosCordovaScheme()) && !_isNativeEnvironment() && _isWebStorageSupported() && !_isWorker();
}
function _isLikelyCordova() {
  return _isAndroidOrIosCordovaScheme() && typeof document !== "undefined";
}
async function _isCordova() {
  if (!_isLikelyCordova()) {
    return false;
  }
  return new Promise((resolve) => {
    const timeoutId = setTimeout(() => {
      resolve(false);
    }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
    document.addEventListener("deviceready", () => {
      clearTimeout(timeoutId);
      resolve(true);
    });
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Persistence = {
  LOCAL: "local",
  NONE: "none",
  SESSION: "session"
};
const _assert = _assert$4;
const PERSISTENCE_KEY = "persistence";
function _validatePersistenceArgument(auth2, persistence) {
  _assert(Object.values(Persistence).includes(persistence), auth2, "invalid-persistence-type");
  if (isReactNative()) {
    _assert(persistence !== Persistence.SESSION, auth2, "unsupported-persistence-type");
    return;
  }
  if (isNode()) {
    _assert(persistence === Persistence.NONE, auth2, "unsupported-persistence-type");
    return;
  }
  if (_isWorker()) {
    _assert(persistence === Persistence.NONE || persistence === Persistence.LOCAL && isIndexedDBAvailable(), auth2, "unsupported-persistence-type");
    return;
  }
  _assert(persistence === Persistence.NONE || _isWebStorageSupported(), auth2, "unsupported-persistence-type");
}
async function _savePersistenceForRedirect(auth2) {
  await auth2._initializationPromise;
  const win = getSelfWindow();
  const key = _persistenceKeyName(PERSISTENCE_KEY, auth2.config.apiKey, auth2.name);
  if (win === null || win === void 0 ? void 0 : win.sessionStorage) {
    win.sessionStorage.setItem(key, auth2._getPersistence());
  }
}
function _getPersistencesFromRedirect(apiKey, appName) {
  const win = getSelfWindow();
  if (!(win === null || win === void 0 ? void 0 : win.sessionStorage)) {
    return [];
  }
  const key = _persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);
  const persistence = win.sessionStorage.getItem(key);
  switch (persistence) {
    case Persistence.NONE:
      return [inMemoryPersistence];
    case Persistence.LOCAL:
      return [indexedDBLocalPersistence, browserSessionPersistence];
    case Persistence.SESSION:
      return [browserSessionPersistence];
    default:
      return [];
  }
}
function getSelfWindow() {
  return typeof window !== "undefined" ? window : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$1 = _assert$4;
const BROWSER_RESOLVER = _getInstance(browserPopupRedirectResolver);
const CORDOVA_RESOLVER = _getInstance(cordovaPopupRedirectResolver);
class CompatPopupRedirectResolver {
  constructor() {
    this.underlyingResolver = null;
    this._redirectPersistence = browserSessionPersistence;
    this._completeRedirectFn = _getRedirectResult;
  }
  async _initialize(auth2) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._initialize(auth2);
  }
  async _openPopup(auth2, provider, authType, eventId) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._openPopup(auth2, provider, authType, eventId);
  }
  async _openRedirect(auth2, provider, authType, eventId) {
    await this.selectUnderlyingResolver();
    return this.assertedUnderlyingResolver._openRedirect(auth2, provider, authType, eventId);
  }
  _isIframeWebStorageSupported(auth2, cb2) {
    this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth2, cb2);
  }
  _originValidation(auth2) {
    return this.assertedUnderlyingResolver._originValidation(auth2);
  }
  get _shouldInitProactively() {
    return _isLikelyCordova() || BROWSER_RESOLVER._shouldInitProactively;
  }
  get assertedUnderlyingResolver() {
    _assert$1(this.underlyingResolver, "internal-error");
    return this.underlyingResolver;
  }
  async selectUnderlyingResolver() {
    if (this.underlyingResolver) {
      return;
    }
    const isCordova = await _isCordova();
    this.underlyingResolver = isCordova ? CORDOVA_RESOLVER : BROWSER_RESOLVER;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unwrap$1(object) {
  return object.unwrap();
}
function wrapped(object) {
  return object.wrapped();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function credentialFromResponse(userCredential) {
  return credentialFromObject(userCredential);
}
function attachExtraErrorFields(auth2, e) {
  var _a2;
  const response = (_a2 = e.customData) === null || _a2 === void 0 ? void 0 : _a2._tokenResponse;
  if (e.code === "auth/multi-factor-auth-required") {
    const mfaErr = e;
    mfaErr.resolver = new MultiFactorResolver(auth2, getMultiFactorResolver(auth2, e));
  } else if (response) {
    const credential = credentialFromObject(e);
    const credErr = e;
    if (credential) {
      credErr.credential = credential;
      credErr.tenantId = response.tenantId || void 0;
      credErr.email = response.email || void 0;
      credErr.phoneNumber = response.phoneNumber || void 0;
    }
  }
}
function credentialFromObject(object) {
  const {_tokenResponse} = object instanceof FirebaseError ? object.customData : object;
  if (!_tokenResponse) {
    return null;
  }
  if (!(object instanceof FirebaseError)) {
    if ("temporaryProof" in _tokenResponse && "phoneNumber" in _tokenResponse) {
      return PhoneAuthProvider$1.credentialFromResult(object);
    }
  }
  const providerId = _tokenResponse.providerId;
  if (!providerId || providerId === "password") {
    return null;
  }
  let provider;
  switch (providerId) {
    case "google.com":
      provider = GoogleAuthProvider;
      break;
    case "facebook.com":
      provider = FacebookAuthProvider;
      break;
    case "github.com":
      provider = GithubAuthProvider;
      break;
    case "twitter.com":
      provider = TwitterAuthProvider;
      break;
    default:
      const {oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce} = _tokenResponse;
      if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
        return null;
      }
      if (pendingToken) {
        if (providerId.startsWith("saml.")) {
          return SAMLAuthCredential._create(providerId, pendingToken);
        } else {
          return OAuthCredential._fromParams({
            providerId,
            signInMethod: providerId,
            pendingToken,
            idToken: oauthIdToken,
            accessToken: oauthAccessToken
          });
        }
      }
      return new OAuthProvider(providerId).credential({
        idToken: oauthIdToken,
        accessToken: oauthAccessToken,
        rawNonce: nonce
      });
  }
  return object instanceof FirebaseError ? provider.credentialFromError(object) : provider.credentialFromResult(object);
}
async function convertCredential(auth2, credentialPromise) {
  let credential;
  try {
    credential = await credentialPromise;
  } catch (e) {
    if (e instanceof FirebaseError) {
      attachExtraErrorFields(auth2, e);
    }
    throw e;
  }
  const {operationType, user} = credential;
  return {
    operationType,
    credential: credentialFromResponse(credential),
    additionalUserInfo: getAdditionalUserInfo(credential),
    user: User.getOrCreate(user)
  };
}
async function convertConfirmationResult(auth2, confirmationResultPromise) {
  const confirmationResultExp = await confirmationResultPromise;
  return {
    verificationId: confirmationResultExp.verificationId,
    confirm: (verificationCode) => convertCredential(auth2, confirmationResultExp.confirm(verificationCode))
  };
}
class MultiFactorResolver {
  constructor(auth2, resolver) {
    this.resolver = resolver;
    this.auth = wrapped(auth2);
  }
  get session() {
    return this.resolver.session;
  }
  get hints() {
    return this.resolver.hints;
  }
  resolveSignIn(assertion) {
    return convertCredential(unwrap$1(this.auth), this.resolver.resolveSignIn(assertion));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class User {
  constructor(_delegate) {
    this._delegate = _delegate;
    this.multiFactor = multiFactor(_delegate);
  }
  static getOrCreate(user) {
    if (!User.USER_MAP.has(user)) {
      User.USER_MAP.set(user, new User(user));
    }
    return User.USER_MAP.get(user);
  }
  delete() {
    return this._delegate.delete();
  }
  reload() {
    return this._delegate.reload();
  }
  toJSON() {
    return this._delegate.toJSON();
  }
  getIdTokenResult(forceRefresh) {
    return this._delegate.getIdTokenResult(forceRefresh);
  }
  getIdToken(forceRefresh) {
    return this._delegate.getIdToken(forceRefresh);
  }
  linkAndRetrieveDataWithCredential(credential) {
    return this.linkWithCredential(credential);
  }
  async linkWithCredential(credential) {
    return convertCredential(this.auth, linkWithCredential(this._delegate, credential));
  }
  async linkWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, linkWithPhoneNumber$1(this._delegate, phoneNumber, applicationVerifier));
  }
  async linkWithPopup(provider) {
    return convertCredential(this.auth, linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async linkWithRedirect(provider) {
    await _savePersistenceForRedirect(_castAuth(this.auth));
    return linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  reauthenticateAndRetrieveDataWithCredential(credential) {
    return this.reauthenticateWithCredential(credential);
  }
  async reauthenticateWithCredential(credential) {
    return convertCredential(this.auth, reauthenticateWithCredential(this._delegate, credential));
  }
  reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this.auth, reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  }
  reauthenticateWithPopup(provider) {
    return convertCredential(this.auth, reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async reauthenticateWithRedirect(provider) {
    await _savePersistenceForRedirect(_castAuth(this.auth));
    return reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  sendEmailVerification(actionCodeSettings) {
    return sendEmailVerification$1(this._delegate, actionCodeSettings);
  }
  async unlink(providerId) {
    await unlink(this._delegate, providerId);
    return this;
  }
  updateEmail(newEmail) {
    return updateEmail(this._delegate, newEmail);
  }
  updatePassword(newPassword) {
    return updatePassword(this._delegate, newPassword);
  }
  updatePhoneNumber(phoneCredential) {
    return updatePhoneNumber(this._delegate, phoneCredential);
  }
  updateProfile(profile) {
    return updateProfile$1(this._delegate, profile);
  }
  verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
    return verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
  }
  get emailVerified() {
    return this._delegate.emailVerified;
  }
  get isAnonymous() {
    return this._delegate.isAnonymous;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get phoneNumber() {
    return this._delegate.phoneNumber;
  }
  get providerData() {
    return this._delegate.providerData;
  }
  get refreshToken() {
    return this._delegate.refreshToken;
  }
  get tenantId() {
    return this._delegate.tenantId;
  }
  get displayName() {
    return this._delegate.displayName;
  }
  get email() {
    return this._delegate.email;
  }
  get photoURL() {
    return this._delegate.photoURL;
  }
  get providerId() {
    return this._delegate.providerId;
  }
  get uid() {
    return this._delegate.uid;
  }
  get auth() {
    return this._delegate.auth;
  }
}
User.USER_MAP = new WeakMap();
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$2 = _assert$4;
class Auth$1 {
  constructor(app, provider) {
    this.app = app;
    if (provider.isInitialized()) {
      this._delegate = provider.getImmediate();
      this.linkUnderlyingAuth();
      return;
    }
    const {apiKey} = app.options;
    _assert$2(apiKey, "invalid-api-key", {
      appName: app.name
    });
    let persistences = [inMemoryPersistence];
    if (typeof window !== "undefined") {
      persistences = _getPersistencesFromRedirect(apiKey, app.name);
      for (const persistence of [
        indexedDBLocalPersistence,
        browserLocalPersistence
      ]) {
        if (!persistences.includes(persistence)) {
          persistences.push(persistence);
        }
      }
    }
    _assert$2(apiKey, "invalid-api-key", {
      appName: app.name
    });
    const resolver = typeof window !== "undefined" ? CompatPopupRedirectResolver : void 0;
    this._delegate = provider.initialize({
      options: {
        persistence: persistences,
        popupRedirectResolver: resolver
      }
    });
    this._delegate._updateErrorMap(debugErrorMap);
    this.linkUnderlyingAuth();
  }
  get emulatorConfig() {
    return this._delegate.emulatorConfig;
  }
  get currentUser() {
    if (!this._delegate.currentUser) {
      return null;
    }
    return User.getOrCreate(this._delegate.currentUser);
  }
  get languageCode() {
    return this._delegate.languageCode;
  }
  get settings() {
    return this._delegate.settings;
  }
  get tenantId() {
    return this._delegate.tenantId;
  }
  useDeviceLanguage() {
    this._delegate.useDeviceLanguage();
  }
  signOut() {
    return this._delegate.signOut();
  }
  useEmulator(url, options2) {
    useAuthEmulator(this._delegate, url, options2);
  }
  applyActionCode(code) {
    return applyActionCode$1(this._delegate, code);
  }
  checkActionCode(code) {
    return checkActionCode(this._delegate, code);
  }
  confirmPasswordReset(code, newPassword) {
    return confirmPasswordReset(this._delegate, code, newPassword);
  }
  async createUserWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, createUserWithEmailAndPassword(this._delegate, email, password));
  }
  fetchProvidersForEmail(email) {
    return this.fetchSignInMethodsForEmail(email);
  }
  fetchSignInMethodsForEmail(email) {
    return fetchSignInMethodsForEmail(this._delegate, email);
  }
  isSignInWithEmailLink(emailLink) {
    return isSignInWithEmailLink(this._delegate, emailLink);
  }
  async getRedirectResult() {
    _assert$2(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    const credential = await getRedirectResult(this._delegate, CompatPopupRedirectResolver);
    if (!credential) {
      return {
        credential: null,
        user: null
      };
    }
    return convertCredential(this._delegate, Promise.resolve(credential));
  }
  onAuthStateChanged(nextOrObserver, errorFn, completed) {
    const {next, error: error2, complete} = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onAuthStateChanged(next, error2, complete);
  }
  onIdTokenChanged(nextOrObserver, errorFn, completed) {
    const {next, error: error2, complete} = wrapObservers(nextOrObserver, errorFn, completed);
    return this._delegate.onIdTokenChanged(next, error2, complete);
  }
  sendSignInLinkToEmail(email, actionCodeSettings) {
    return sendSignInLinkToEmail$1(this._delegate, email, actionCodeSettings);
  }
  sendPasswordResetEmail(email, actionCodeSettings) {
    return sendPasswordResetEmail$1(this._delegate, email, actionCodeSettings || void 0);
  }
  async setPersistence(persistence) {
    _validatePersistenceArgument(this._delegate, persistence);
    let converted;
    switch (persistence) {
      case Persistence.SESSION:
        converted = browserSessionPersistence;
        break;
      case Persistence.LOCAL:
        const isIndexedDBFullySupported = await _getInstance(indexedDBLocalPersistence)._isAvailable();
        converted = isIndexedDBFullySupported ? indexedDBLocalPersistence : browserLocalPersistence;
        break;
      case Persistence.NONE:
        converted = inMemoryPersistence;
        break;
      default:
        return _fail("argument-error", {
          appName: this._delegate.name
        });
    }
    return this._delegate.setPersistence(converted);
  }
  signInAndRetrieveDataWithCredential(credential) {
    return this.signInWithCredential(credential);
  }
  signInAnonymously() {
    return convertCredential(this._delegate, signInAnonymously(this._delegate));
  }
  signInWithCredential(credential) {
    return convertCredential(this._delegate, signInWithCredential(this._delegate, credential));
  }
  signInWithCustomToken(token) {
    return convertCredential(this._delegate, signInWithCustomToken$1(this._delegate, token));
  }
  signInWithEmailAndPassword(email, password) {
    return convertCredential(this._delegate, signInWithEmailAndPassword(this._delegate, email, password));
  }
  signInWithEmailLink(email, emailLink) {
    return convertCredential(this._delegate, signInWithEmailLink$1(this._delegate, email, emailLink));
  }
  signInWithPhoneNumber(phoneNumber, applicationVerifier) {
    return convertConfirmationResult(this._delegate, signInWithPhoneNumber$1(this._delegate, phoneNumber, applicationVerifier));
  }
  async signInWithPopup(provider) {
    _assert$2(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    return convertCredential(this._delegate, signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  }
  async signInWithRedirect(provider) {
    _assert$2(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment");
    await _savePersistenceForRedirect(this._delegate);
    return signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  }
  updateCurrentUser(user) {
    return this._delegate.updateCurrentUser(user);
  }
  verifyPasswordResetCode(code) {
    return verifyPasswordResetCode(this._delegate, code);
  }
  unwrap() {
    return this._delegate;
  }
  _delete() {
    return this._delegate._delete();
  }
  linkUnderlyingAuth() {
    this._delegate.wrapped = () => this;
  }
}
function wrapObservers(nextOrObserver, error2, complete) {
  let next = nextOrObserver;
  if (typeof nextOrObserver !== "function") {
    ({next, error: error2, complete} = nextOrObserver);
  }
  const oldNext = next;
  const newNext = (user) => oldNext(user && User.getOrCreate(user));
  return {
    next: newNext,
    error: error2,
    complete
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PhoneAuthProvider {
  constructor() {
    this.providerId = "phone";
    this._delegate = new PhoneAuthProvider$1(unwrap(firebase$1.auth()));
  }
  static credential(verificationId, verificationCode) {
    return PhoneAuthProvider$1.credential(verificationId, verificationCode);
  }
  verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
    return this._delegate.verifyPhoneNumber(phoneInfoOptions, applicationVerifier);
  }
  unwrap() {
    return this._delegate;
  }
}
PhoneAuthProvider.PHONE_SIGN_IN_METHOD = PhoneAuthProvider$1.PHONE_SIGN_IN_METHOD;
PhoneAuthProvider.PROVIDER_ID = PhoneAuthProvider$1.PROVIDER_ID;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$3 = _assert$4;
class RecaptchaVerifier {
  constructor(container, parameters, app = firebase$1.app()) {
    var _a2;
    _assert$3((_a2 = app.options) === null || _a2 === void 0 ? void 0 : _a2.apiKey, "invalid-api-key", {
      appName: app.name
    });
    this._delegate = new RecaptchaVerifier$1(container, parameters, app.auth());
    this.type = this._delegate.type;
  }
  clear() {
    this._delegate.clear();
  }
  render() {
    return this._delegate.render();
  }
  verify() {
    return this._delegate.verify();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AUTH_TYPE = "auth-compat";
function registerAuthCompat(instance) {
  instance.INTERNAL.registerComponent(new Component(AUTH_TYPE, (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const authProvider = container.getProvider("auth-exp");
    return new Auth$1(app, authProvider);
  }, "PUBLIC").setServiceProps({
    ActionCodeInfo: {
      Operation: {
        EMAIL_SIGNIN: "EMAIL_SIGNIN",
        PASSWORD_RESET: "PASSWORD_RESET",
        RECOVER_EMAIL: "RECOVER_EMAIL",
        REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION",
        VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL",
        VERIFY_EMAIL: "VERIFY_EMAIL"
      }
    },
    EmailAuthProvider,
    FacebookAuthProvider,
    GithubAuthProvider,
    GoogleAuthProvider,
    OAuthProvider,
    PhoneAuthProvider,
    PhoneMultiFactorGenerator,
    RecaptchaVerifier,
    TwitterAuthProvider,
    Auth: {
      Persistence
    },
    AuthCredential
  }).setInstantiationMode("LAZY").setMultipleInstances(false));
  instance.registerVersion(name$1, version$2);
}
registerAuthCompat(firebase$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var h, goog = goog || {}, k$1 = commonjsGlobal || self;
function aa$1() {
}
function ba$1(a) {
  var b2 = typeof a;
  b2 = b2 != "object" ? b2 : a ? Array.isArray(a) ? "array" : b2 : "null";
  return b2 == "array" || b2 == "object" && typeof a.length == "number";
}
function n(a) {
  var b2 = typeof a;
  return b2 == "object" && a != null || b2 == "function";
}
function ca$1(a) {
  return Object.prototype.hasOwnProperty.call(a, da$1) && a[da$1] || (a[da$1] = ++ea$1);
}
var da$1 = "closure_uid_" + (1e9 * Math.random() >>> 0), ea$1 = 0;
function fa$1(a, b2, c) {
  return a.call.apply(a.bind, arguments);
}
function ha$1(a, b2, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d2 = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d2);
      return a.apply(b2, e);
    };
  }
  return function() {
    return a.apply(b2, arguments);
  };
}
function p(a, b2, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? p = fa$1 : p = ha$1;
  return p.apply(null, arguments);
}
function ja$1(a, b2) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d2 = c.slice();
    d2.push.apply(d2, arguments);
    return a.apply(this, d2);
  };
}
function q$1() {
  return Date.now();
}
function r(a, b2) {
  function c() {
  }
  c.prototype = b2.prototype;
  a.X = b2.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Kb = function(d2, e, f) {
    for (var g = Array(arguments.length - 2), m = 2; m < arguments.length; m++)
      g[m - 2] = arguments[m];
    return b2.prototype[e].apply(d2, g);
  };
}
function t() {
  this.j = this.j;
  this.i = this.i;
}
var ka$1 = 0;
t.prototype.j = false;
t.prototype.ja = function() {
  if (!this.j && (this.j = true, this.G(), ka$1 != 0)) {
    ca$1(this);
  }
};
t.prototype.G = function() {
  if (this.i)
    for (; this.i.length; )
      this.i.shift()();
};
var ma$1 = Array.prototype.indexOf ? function(a, b2) {
  return Array.prototype.indexOf.call(a, b2, void 0);
} : function(a, b2) {
  if (typeof a === "string")
    return typeof b2 !== "string" || b2.length != 1 ? -1 : a.indexOf(b2, 0);
  for (var c = 0; c < a.length; c++)
    if (c in a && a[c] === b2)
      return c;
  return -1;
}, na$1 = Array.prototype.forEach ? function(a, b2, c) {
  Array.prototype.forEach.call(a, b2, c);
} : function(a, b2, c) {
  for (var d2 = a.length, e = typeof a === "string" ? a.split("") : a, f = 0; f < d2; f++)
    f in e && b2.call(c, e[f], f, a);
};
function oa$1(a) {
  a: {
    var b2 = pa$1;
    for (var c = a.length, d2 = typeof a === "string" ? a.split("") : a, e = 0; e < c; e++)
      if (e in d2 && b2.call(void 0, d2[e], e, a)) {
        b2 = e;
        break a;
      }
    b2 = -1;
  }
  return 0 > b2 ? null : typeof a === "string" ? a.charAt(b2) : a[b2];
}
function qa$1(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra$1(a) {
  var b2 = a.length;
  if (0 < b2) {
    for (var c = Array(b2), d2 = 0; d2 < b2; d2++)
      c[d2] = a[d2];
    return c;
  }
  return [];
}
function sa$1(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta$1 = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function v$1(a, b2) {
  return a.indexOf(b2) != -1;
}
function ua$1(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
}
var w;
a: {
  var va$1 = k$1.navigator;
  if (va$1) {
    var wa$1 = va$1.userAgent;
    if (wa$1) {
      w = wa$1;
      break a;
    }
  }
  w = "";
}
function za$1(a, b2, c) {
  for (var d2 in a)
    b2.call(c, a[d2], d2, a);
}
function Aa$1(a) {
  var b2 = {};
  for (var c in a)
    b2[c] = a[c];
  return b2;
}
var Ba$1 = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Ca$1(a, b2) {
  var c, d2;
  for (var e = 1; e < arguments.length; e++) {
    d2 = arguments[e];
    for (c in d2)
      a[c] = d2[c];
    for (var f = 0; f < Ba$1.length; f++)
      c = Ba$1[f], Object.prototype.hasOwnProperty.call(d2, c) && (a[c] = d2[c]);
  }
}
function Da$1(a) {
  Da$1[" "](a);
  return a;
}
Da$1[" "] = aa$1;
function Ea$1(a, b2) {
  var c = Fa$1;
  return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b2(a);
}
var Ga$1 = v$1(w, "Opera"), x$1 = v$1(w, "Trident") || v$1(w, "MSIE"), Ha$1 = v$1(w, "Edge"), Ia$1 = Ha$1 || x$1, Ja$1 = v$1(w, "Gecko") && !(v$1(w.toLowerCase(), "webkit") && !v$1(w, "Edge")) && !(v$1(w, "Trident") || v$1(w, "MSIE")) && !v$1(w, "Edge"), Ka$1 = v$1(w.toLowerCase(), "webkit") && !v$1(w, "Edge");
function La$1() {
  var a = k$1.document;
  return a ? a.documentMode : void 0;
}
var Ma$1;
a: {
  var Na$1 = "", Oa$1 = function() {
    var a = w;
    if (Ja$1)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ha$1)
      return /Edge\/([\d\.]+)/.exec(a);
    if (x$1)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (Ka$1)
      return /WebKit\/(\S+)/.exec(a);
    if (Ga$1)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Oa$1 && (Na$1 = Oa$1 ? Oa$1[1] : "");
  if (x$1) {
    var Pa$1 = La$1();
    if (Pa$1 != null && Pa$1 > parseFloat(Na$1)) {
      Ma$1 = String(Pa$1);
      break a;
    }
  }
  Ma$1 = Na$1;
}
var Fa$1 = {};
function Qa$1(a) {
  return Ea$1(a, function() {
    {
      var b2 = 0;
      var e = ta$1(String(Ma$1)).split("."), f = ta$1(String(a)).split("."), g = Math.max(e.length, f.length);
      for (var m = 0; b2 == 0 && m < g; m++) {
        var c = e[m] || "", d2 = f[m] || "";
        do {
          c = /(\d*)(\D*)(.*)/.exec(c) || ["", "", "", ""];
          d2 = /(\d*)(\D*)(.*)/.exec(d2) || ["", "", "", ""];
          if (c[0].length == 0 && d2[0].length == 0)
            break;
          b2 = ua$1(c[1].length == 0 ? 0 : parseInt(c[1], 10), d2[1].length == 0 ? 0 : parseInt(d2[1], 10)) || ua$1(c[2].length == 0, d2[2].length == 0) || ua$1(c[2], d2[2]);
          c = c[3];
          d2 = d2[3];
        } while (b2 == 0);
      }
    }
    return 0 <= b2;
  });
}
var Ra$1;
if (k$1.document && x$1) {
  var Sa$1 = La$1();
  Ra$1 = Sa$1 ? Sa$1 : parseInt(Ma$1, 10) || void 0;
} else
  Ra$1 = void 0;
var Ta$1 = Ra$1;
var Ua$1 = !x$1 || 9 <= Number(Ta$1), Va$1 = x$1 && !Qa$1("9"), Wa$1 = function() {
  if (!k$1.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b2 = Object.defineProperty({}, "passive", {get: function() {
    a = true;
  }});
  try {
    k$1.addEventListener("test", aa$1, b2), k$1.removeEventListener("test", aa$1, b2);
  } catch (c) {
  }
  return a;
}();
function y(a, b2) {
  this.type = a;
  this.a = this.target = b2;
  this.defaultPrevented = false;
}
y.prototype.b = function() {
  this.defaultPrevented = true;
};
function z$1(a, b2) {
  y.call(this, a ? a.type : "");
  this.relatedTarget = this.a = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.pointerId = 0;
  this.pointerType = "";
  this.c = null;
  if (a) {
    var c = this.type = a.type, d2 = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.a = b2;
    if (b2 = a.relatedTarget) {
      if (Ja$1) {
        a: {
          try {
            Da$1(b2.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b2 = null);
      }
    } else
      c == "mouseover" ? b2 = a.fromElement : c == "mouseout" && (b2 = a.toElement);
    this.relatedTarget = b2;
    d2 ? (this.clientX = d2.clientX !== void 0 ? d2.clientX : d2.pageX, this.clientY = d2.clientY !== void 0 ? d2.clientY : d2.pageY, this.screenX = d2.screenX || 0, this.screenY = d2.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Xa$1[a.pointerType] || "";
    this.c = a;
    a.defaultPrevented && this.b();
  }
}
r(z$1, y);
var Xa$1 = {2: "touch", 3: "pen", 4: "mouse"};
z$1.prototype.b = function() {
  z$1.X.b.call(this);
  var a = this.c;
  if (a.preventDefault)
    a.preventDefault();
  else if (a.returnValue = false, Va$1)
    try {
      if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode)
        a.keyCode = -1;
    } catch (b2) {
    }
};
var A = "closure_listenable_" + (1e6 * Math.random() | 0), Ya$1 = 0;
function Za$1(a, b2, c, d2, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b2;
  this.type = c;
  this.capture = !!d2;
  this.ca = e;
  this.key = ++Ya$1;
  this.Y = this.Z = false;
}
function $a$1(a) {
  a.Y = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ca = null;
}
function ab(a) {
  this.src = a;
  this.a = {};
  this.b = 0;
}
ab.prototype.add = function(a, b2, c, d2, e) {
  var f = a.toString();
  a = this.a[f];
  a || (a = this.a[f] = [], this.b++);
  var g = bb(a, b2, d2, e);
  -1 < g ? (b2 = a[g], c || (b2.Z = false)) : (b2 = new Za$1(b2, this.src, f, !!d2, e), b2.Z = c, a.push(b2));
  return b2;
};
function cb(a, b2) {
  var c = b2.type;
  if (c in a.a) {
    var d2 = a.a[c], e = ma$1(d2, b2), f;
    (f = 0 <= e) && Array.prototype.splice.call(d2, e, 1);
    f && ($a$1(b2), a.a[c].length == 0 && (delete a.a[c], a.b--));
  }
}
function bb(a, b2, c, d2) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.Y && f.listener == b2 && f.capture == !!c && f.ca == d2)
      return e;
  }
  return -1;
}
var db = "closure_lm_" + (1e6 * Math.random() | 0), eb = {};
function gb(a, b2, c, d2, e) {
  if (d2 && d2.once)
    return hb(a, b2, c, d2, e);
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      gb(a, b2[f], c, d2, e);
    return null;
  }
  c = ib(c);
  return a && a[A] ? a.va(b2, c, n(d2) ? !!d2.capture : !!d2, e) : jb(a, b2, c, false, d2, e);
}
function jb(a, b2, c, d2, e, f) {
  if (!b2)
    throw Error("Invalid event type");
  var g = n(e) ? !!e.capture : !!e;
  if (g && !Ua$1)
    return null;
  var m = kb(a);
  m || (a[db] = m = new ab(a));
  c = m.add(b2, c, d2, g, f);
  if (c.proxy)
    return c;
  d2 = lb();
  c.proxy = d2;
  d2.src = a;
  d2.listener = c;
  if (a.addEventListener)
    Wa$1 || (e = g), e === void 0 && (e = false), a.addEventListener(b2.toString(), d2, e);
  else if (a.attachEvent)
    a.attachEvent(mb(b2.toString()), d2);
  else if (a.addListener && a.removeListener)
    a.addListener(d2);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function lb() {
  var a = nb, b2 = Ua$1 ? function(c) {
    return a.call(b2.src, b2.listener, c);
  } : function(c) {
    c = a.call(b2.src, b2.listener, c);
    if (!c)
      return c;
  };
  return b2;
}
function hb(a, b2, c, d2, e) {
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      hb(a, b2[f], c, d2, e);
    return null;
  }
  c = ib(c);
  return a && a[A] ? a.wa(b2, c, n(d2) ? !!d2.capture : !!d2, e) : jb(a, b2, c, true, d2, e);
}
function ob(a, b2, c, d2, e) {
  if (Array.isArray(b2))
    for (var f = 0; f < b2.length; f++)
      ob(a, b2[f], c, d2, e);
  else
    (d2 = n(d2) ? !!d2.capture : !!d2, c = ib(c), a && a[A]) ? (a = a.c, b2 = String(b2).toString(), b2 in a.a && (f = a.a[b2], c = bb(f, c, d2, e), -1 < c && ($a$1(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.a[b2], a.b--)))) : a && (a = kb(a)) && (b2 = a.a[b2.toString()], a = -1, b2 && (a = bb(b2, c, d2, e)), (c = -1 < a ? b2[a] : null) && pb(c));
}
function pb(a) {
  if (typeof a !== "number" && a && !a.Y) {
    var b2 = a.src;
    if (b2 && b2[A])
      cb(b2.c, a);
    else {
      var c = a.type, d2 = a.proxy;
      b2.removeEventListener ? b2.removeEventListener(c, d2, a.capture) : b2.detachEvent ? b2.detachEvent(mb(c), d2) : b2.addListener && b2.removeListener && b2.removeListener(d2);
      (c = kb(b2)) ? (cb(c, a), c.b == 0 && (c.src = null, b2[db] = null)) : $a$1(a);
    }
  }
}
function mb(a) {
  return a in eb ? eb[a] : eb[a] = "on" + a;
}
function qb(a, b2) {
  var c = a.listener, d2 = a.ca || a.src;
  a.Z && pb(a);
  return c.call(d2, b2);
}
function nb(a, b2) {
  if (a.Y)
    return true;
  if (!Ua$1) {
    if (!b2)
      a: {
        b2 = ["window", "event"];
        for (var c = k$1, d2 = 0; d2 < b2.length; d2++)
          if (c = c[b2[d2]], c == null) {
            b2 = null;
            break a;
          }
        b2 = c;
      }
    b2 = new z$1(b2, this);
    return qb(a, b2);
  }
  return qb(a, new z$1(b2, this));
}
function kb(a) {
  a = a[db];
  return a instanceof ab ? a : null;
}
var sb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function ib(a) {
  if (typeof a === "function")
    return a;
  a[sb] || (a[sb] = function(b2) {
    return a.handleEvent(b2);
  });
  return a[sb];
}
function D$1() {
  t.call(this);
  this.c = new ab(this);
  this.J = this;
  this.C = null;
}
r(D$1, t);
D$1.prototype[A] = true;
h = D$1.prototype;
h.addEventListener = function(a, b2, c, d2) {
  gb(this, a, b2, c, d2);
};
h.removeEventListener = function(a, b2, c, d2) {
  ob(this, a, b2, c, d2);
};
function E(a, b2) {
  var c, d2 = a.C;
  if (d2)
    for (c = []; d2; d2 = d2.C)
      c.push(d2);
  a = a.J;
  d2 = b2.type || b2;
  if (typeof b2 === "string")
    b2 = new y(b2, a);
  else if (b2 instanceof y)
    b2.target = b2.target || a;
  else {
    var e = b2;
    b2 = new y(d2, a);
    Ca$1(b2, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var g = b2.a = c[f];
      e = tb(g, d2, true, b2) && e;
    }
  g = b2.a = a;
  e = tb(g, d2, true, b2) && e;
  e = tb(g, d2, false, b2) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      g = b2.a = c[f], e = tb(g, d2, false, b2) && e;
}
h.G = function() {
  D$1.X.G.call(this);
  if (this.c) {
    var a = this.c, c;
    for (c in a.a) {
      for (var d2 = a.a[c], e = 0; e < d2.length; e++)
        $a$1(d2[e]);
      delete a.a[c];
      a.b--;
    }
  }
  this.C = null;
};
h.va = function(a, b2, c, d2) {
  return this.c.add(String(a), b2, false, c, d2);
};
h.wa = function(a, b2, c, d2) {
  return this.c.add(String(a), b2, true, c, d2);
};
function tb(a, b2, c, d2) {
  b2 = a.c.a[String(b2)];
  if (!b2)
    return true;
  b2 = b2.concat();
  for (var e = true, f = 0; f < b2.length; ++f) {
    var g = b2[f];
    if (g && !g.Y && g.capture == c) {
      var m = g.listener, l = g.ca || g.src;
      g.Z && cb(a.c, g);
      e = m.call(l, d2) !== false && e;
    }
  }
  return e && !d2.defaultPrevented;
}
var ub = k$1.JSON.stringify;
function vb() {
  this.b = this.a = null;
}
var xb = new (function() {
  function class_1(a, b2) {
    this.c = a;
    this.f = b2;
    this.b = 0;
    this.a = null;
  }
  class_1.prototype.get = function() {
    var a;
    0 < this.b ? (this.b--, a = this.a, this.a = a.next, a.next = null) : a = this.c();
    return a;
  };
  return class_1;
}())(function() {
  return new wb();
}, function(a) {
  a.reset();
});
vb.prototype.add = function(a, b2) {
  var c = xb.get();
  c.set(a, b2);
  this.b ? this.b.next = c : this.a = c;
  this.b = c;
};
function yb() {
  var a = zb, b2 = null;
  a.a && (b2 = a.a, a.a = a.a.next, a.a || (a.b = null), b2.next = null);
  return b2;
}
function wb() {
  this.next = this.b = this.a = null;
}
wb.prototype.set = function(a, b2) {
  this.a = a;
  this.b = b2;
  this.next = null;
};
wb.prototype.reset = function() {
  this.next = this.b = this.a = null;
};
function Ab(a) {
  k$1.setTimeout(function() {
    throw a;
  }, 0);
}
function Bb(a, b2) {
  Cb || Db();
  Eb || (Cb(), Eb = true);
  zb.add(a, b2);
}
var Cb;
function Db() {
  var a = k$1.Promise.resolve(void 0);
  Cb = function() {
    a.then(Fb);
  };
}
var Eb = false, zb = new vb();
function Fb() {
  for (var a; a = yb(); ) {
    try {
      a.a.call(a.b);
    } catch (c) {
      Ab(c);
    }
    var b2 = xb;
    b2.f(a);
    100 > b2.b && (b2.b++, a.next = b2.a, b2.a = a);
  }
  Eb = false;
}
function Gb(a, b2) {
  D$1.call(this);
  this.b = a || 1;
  this.a = b2 || k$1;
  this.f = p(this.Za, this);
  this.g = q$1();
}
r(Gb, D$1);
h = Gb.prototype;
h.aa = false;
h.M = null;
h.Za = function() {
  if (this.aa) {
    var a = q$1() - this.g;
    0 < a && a < 0.8 * this.b ? this.M = this.a.setTimeout(this.f, this.b - a) : (this.M && (this.a.clearTimeout(this.M), this.M = null), E(this, "tick"), this.aa && (Hb(this), this.start()));
  }
};
h.start = function() {
  this.aa = true;
  this.M || (this.M = this.a.setTimeout(this.f, this.b), this.g = q$1());
};
function Hb(a) {
  a.aa = false;
  a.M && (a.a.clearTimeout(a.M), a.M = null);
}
h.G = function() {
  Gb.X.G.call(this);
  Hb(this);
  delete this.a;
};
function Ib(a, b2, c) {
  if (typeof a === "function")
    c && (a = p(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = p(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b2) ? -1 : k$1.setTimeout(a, b2 || 0);
}
function Jb(a) {
  a.a = Ib(function() {
    a.a = null;
    a.c && (a.c = false, Jb(a));
  }, a.h);
  var b2 = a.b;
  a.b = null;
  a.g.apply(null, b2);
}
var Kb = function(_super) {
  __extends(Kb2, _super);
  function Kb2(a, b2) {
    var _this = _super.call(this) || this;
    _this.g = a;
    _this.h = b2;
    _this.b = null;
    _this.c = false;
    _this.a = null;
    return _this;
  }
  Kb2.prototype.f = function(a) {
    this.b = arguments;
    this.a ? this.c = true : Jb(this);
  };
  Kb2.prototype.G = function() {
    _super.prototype.G.call(this);
    this.a && (k$1.clearTimeout(this.a), this.a = null, this.c = false, this.b = null);
  };
  return Kb2;
}(t);
function F$1(a) {
  t.call(this);
  this.b = a;
  this.a = {};
}
r(F$1, t);
var Lb = [];
function Mb(a, b2, c, d2) {
  Array.isArray(c) || (c && (Lb[0] = c.toString()), c = Lb);
  for (var e = 0; e < c.length; e++) {
    var f = gb(b2, c[e], d2 || a.handleEvent, false, a.b || a);
    if (!f)
      break;
    a.a[f.key] = f;
  }
}
function Nb(a) {
  za$1(a.a, function(b2, c) {
    this.a.hasOwnProperty(c) && pb(b2);
  }, a);
  a.a = {};
}
F$1.prototype.G = function() {
  F$1.X.G.call(this);
  Nb(this);
};
F$1.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Ob() {
  this.a = true;
}
function Pb(a, b2, c, d2, e, f) {
  a.info(function() {
    if (a.a)
      if (f) {
        var g = "";
        for (var m = f.split("&"), l = 0; l < m.length; l++) {
          var u = m[l].split("=");
          if (1 < u.length) {
            var C2 = u[0];
            u = u[1];
            var B2 = C2.split("_");
            g = 2 <= B2.length && B2[1] == "type" ? g + (C2 + "=" + u + "&") : g + (C2 + "=redacted&");
          }
        }
      } else
        g = null;
    else
      g = f;
    return "XMLHTTP REQ (" + d2 + ") [attempt " + e + "]: " + b2 + "\n" + c + "\n" + g;
  });
}
function Qb(a, b2, c, d2, e, f, g) {
  a.info(function() {
    return "XMLHTTP RESP (" + d2 + ") [ attempt " + e + "]: " + b2 + "\n" + c + "\n" + f + " " + g;
  });
}
function G$1(a, b2, c, d2) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b2 + "): " + Rb(a, c) + (d2 ? " " + d2 : "");
  });
}
function Sb(a, b2) {
  a.info(function() {
    return "TIMEOUT: " + b2;
  });
}
Ob.prototype.info = function() {
};
function Rb(a, b2) {
  if (!a.a)
    return b2;
  if (!b2)
    return null;
  try {
    var c = JSON.parse(b2);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d2 = c[a];
          if (!(2 > d2.length)) {
            var e = d2[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var g = 1; g < e.length; g++)
                  e[g] = "";
            }
          }
        }
    }
    return ub(c);
  } catch (m) {
    return b2;
  }
}
var H$1 = {}, Tb = null;
function Ub() {
  return Tb = Tb || new D$1();
}
H$1.Fa = "serverreachability";
function Vb(a) {
  y.call(this, H$1.Fa, a);
}
r(Vb, y);
function I(a) {
  var b2 = Ub();
  E(b2, new Vb(b2, a));
}
H$1.STAT_EVENT = "statevent";
function Wb(a, b2) {
  y.call(this, H$1.STAT_EVENT, a);
  this.stat = b2;
}
r(Wb, y);
function J$1(a) {
  var b2 = Ub();
  E(b2, new Wb(b2, a));
}
H$1.Ga = "timingevent";
function Xb(a) {
  y.call(this, H$1.Ga, a);
}
r(Xb, y);
function K$1(a, b2) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return k$1.setTimeout(function() {
    a();
  }, b2);
}
var Yb = {NO_ERROR: 0, $a: 1, nb: 2, mb: 3, hb: 4, lb: 5, ob: 6, Da: 7, TIMEOUT: 8, rb: 9};
var Zb = {fb: "complete", Bb: "success", Ea: "error", Da: "abort", tb: "ready", ub: "readystatechange", TIMEOUT: "timeout", pb: "incrementaldata", sb: "progress", ib: "downloadprogress", Jb: "uploadprogress"};
function $b() {
}
$b.prototype.a = null;
function ac$1(a) {
  var b2;
  (b2 = a.a) || (b2 = a.a = {});
  return b2;
}
function bc$1() {
}
var L$1 = {OPEN: "a", eb: "b", Ea: "c", qb: "d"};
function cc$1() {
  y.call(this, "d");
}
r(cc$1, y);
function dc$1() {
  y.call(this, "c");
}
r(dc$1, y);
var ec$1;
function fc$1() {
}
r(fc$1, $b);
ec$1 = new fc$1();
function M$1(a, b2, c, d2) {
  this.g = a;
  this.c = b2;
  this.f = c;
  this.S = d2 || 1;
  this.J = new F$1(this);
  this.P = gc$1;
  a = Ia$1 ? 125 : void 0;
  this.R = new Gb(a);
  this.B = null;
  this.b = false;
  this.j = this.l = this.i = this.H = this.u = this.T = this.o = null;
  this.s = [];
  this.a = null;
  this.D = 0;
  this.h = this.m = null;
  this.N = -1;
  this.A = false;
  this.O = 0;
  this.F = null;
  this.V = this.C = this.U = this.I = false;
}
var gc$1 = 45e3, hc$1 = {}, ic$1 = {};
h = M$1.prototype;
h.setTimeout = function(a) {
  this.P = a;
};
function jc$1(a, b2, c) {
  a.H = 1;
  a.i = kc$1(N$1(b2));
  a.j = c;
  a.I = true;
  lc$1(a, null);
}
function lc$1(a, b2) {
  a.u = q$1();
  mc$1(a);
  a.l = N$1(a.i);
  var c = a.l, d2 = a.S;
  Array.isArray(d2) || (d2 = [String(d2)]);
  nc$1(c.b, "t", d2);
  a.D = 0;
  a.a = oc$1(a.g, a.g.C ? b2 : null);
  0 < a.O && (a.F = new Kb(p(a.Ca, a, a.a), a.O));
  Mb(a.J, a.a, "readystatechange", a.Xa);
  b2 = a.B ? Aa$1(a.B) : {};
  a.j ? (a.m || (a.m = "POST"), b2["Content-Type"] = "application/x-www-form-urlencoded", a.a.ba(a.l, a.m, a.j, b2)) : (a.m = "GET", a.a.ba(a.l, a.m, null, b2));
  I(1);
  Pb(a.c, a.m, a.l, a.f, a.S, a.j);
}
h.Xa = function(a) {
  a = a.target;
  var b2 = this.F;
  b2 && O$1(a) == 3 ? b2.f() : this.Ca(a);
};
h.Ca = function(a) {
  try {
    if (a == this.a)
      a: {
        var b2 = O$1(this.a), c = this.a.ua(), d2 = this.a.W();
        if (!(3 > b2 || b2 == 3 && !Ia$1 && !this.a.$())) {
          this.A || b2 != 4 || c == 7 || (c == 8 || 0 >= d2 ? I(3) : I(2));
          pc$1(this);
          var e = this.a.W();
          this.N = e;
          var f = this.a.$();
          this.b = e == 200;
          Qb(this.c, this.m, this.l, this.f, this.S, b2, e);
          if (this.b) {
            if (this.U && !this.C) {
              b: {
                if (this.a) {
                  var g, m = this.a;
                  if ((g = m.a ? m.a.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa$1(g)) {
                    var l = g;
                    break b;
                  }
                }
                l = null;
              }
              if (l)
                G$1(this.c, this.f, l, "Initial handshake response via X-HTTP-Initial-Response"), this.C = true, qc$1(this, l);
              else {
                this.b = false;
                this.h = 3;
                J$1(12);
                P$1(this);
                rc$1(this);
                break a;
              }
            }
            this.I ? (sc$1(this, b2, f), Ia$1 && this.b && b2 == 3 && (Mb(this.J, this.R, "tick", this.Wa), this.R.start())) : (G$1(this.c, this.f, f, null), qc$1(this, f));
            b2 == 4 && P$1(this);
            this.b && !this.A && (b2 == 4 ? uc$1(this.g, this) : (this.b = false, mc$1(this)));
          } else
            e == 400 && 0 < f.indexOf("Unknown SID") ? (this.h = 3, J$1(12)) : (this.h = 0, J$1(13)), P$1(this), rc$1(this);
        }
      }
  } catch (u) {
  } finally {
  }
};
function sc$1(a, b2, c) {
  for (var d2 = true; !a.A && a.D < c.length; ) {
    var e = vc$1(a, c);
    if (e == ic$1) {
      b2 == 4 && (a.h = 4, J$1(14), d2 = false);
      G$1(a.c, a.f, null, "[Incomplete Response]");
      break;
    } else if (e == hc$1) {
      a.h = 4;
      J$1(15);
      G$1(a.c, a.f, c, "[Invalid Chunk]");
      d2 = false;
      break;
    } else
      G$1(a.c, a.f, e, null), qc$1(a, e);
  }
  b2 == 4 && c.length == 0 && (a.h = 1, J$1(16), d2 = false);
  a.b = a.b && d2;
  d2 ? 0 < c.length && !a.V && (a.V = true, b2 = a.g, b2.a == a && b2.U && !b2.F && (b2.c.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc$1(b2), b2.F = true, J$1(11))) : (G$1(a.c, a.f, c, "[Invalid Chunked Response]"), P$1(a), rc$1(a));
}
h.Wa = function() {
  if (this.a) {
    var a = O$1(this.a), b2 = this.a.$();
    this.D < b2.length && (pc$1(this), sc$1(this, a, b2), this.b && a != 4 && mc$1(this));
  }
};
function vc$1(a, b2) {
  var c = a.D, d2 = b2.indexOf("\n", c);
  if (d2 == -1)
    return ic$1;
  c = Number(b2.substring(c, d2));
  if (isNaN(c))
    return hc$1;
  d2 += 1;
  if (d2 + c > b2.length)
    return ic$1;
  b2 = b2.substr(d2, c);
  a.D = d2 + c;
  return b2;
}
h.cancel = function() {
  this.A = true;
  P$1(this);
};
function mc$1(a) {
  a.T = q$1() + a.P;
  yc$1(a, a.P);
}
function yc$1(a, b2) {
  if (a.o != null)
    throw Error("WatchDog timer not null");
  a.o = K$1(p(a.Va, a), b2);
}
function pc$1(a) {
  a.o && (k$1.clearTimeout(a.o), a.o = null);
}
h.Va = function() {
  this.o = null;
  var a = q$1();
  0 <= a - this.T ? (Sb(this.c, this.l), this.H != 2 && (I(3), J$1(17)), P$1(this), this.h = 2, rc$1(this)) : yc$1(this, this.T - a);
};
function rc$1(a) {
  a.g.v == 0 || a.A || uc$1(a.g, a);
}
function P$1(a) {
  pc$1(a);
  var b2 = a.F;
  b2 && typeof b2.ja == "function" && b2.ja();
  a.F = null;
  Hb(a.R);
  Nb(a.J);
  a.a && (b2 = a.a, a.a = null, b2.abort(), b2.ja());
}
function qc$1(a, b2) {
  try {
    var c = a.g;
    if (c.v != 0 && (c.a == a || zc$1(c.b, a))) {
      if (c.I = a.N, !a.C && zc$1(c.b, a) && c.v == 3) {
        try {
          var d2 = c.ka.a.parse(b2);
        } catch (tc2) {
          d2 = null;
        }
        if (Array.isArray(d2) && d2.length == 3) {
          var e = d2;
          if (e[0] == 0)
            a: {
              if (!c.j) {
                if (c.a)
                  if (c.a.u + 3e3 < a.u)
                    Ac$1(c), Bc$1(c);
                  else
                    break a;
                Cc$1(c);
                J$1(18);
              }
            }
          else
            c.oa = e[1], 0 < c.oa - c.P && 37500 > e[2] && c.H && c.o == 0 && !c.m && (c.m = K$1(p(c.Sa, c), 6e3));
          if (1 >= Dc$1(c.b) && c.ea) {
            try {
              c.ea();
            } catch (tc2) {
            }
            c.ea = void 0;
          }
        } else
          Q$1(c, 11);
      } else if ((a.C || c.a == a) && Ac$1(c), !sa$1(b2))
        for (b2 = d2 = c.ka.a.parse(b2), d2 = 0; d2 < b2.length; d2++)
          if (e = b2[d2], c.P = e[0], e = e[1], c.v == 2)
            if (e[0] == "c") {
              c.J = e[1];
              c.ga = e[2];
              var f = e[3];
              f != null && (c.ha = f, c.c.info("VER=" + c.ha));
              var g = e[4];
              g != null && (c.pa = g, c.c.info("SVER=" + c.pa));
              var m = e[5];
              if (m != null && typeof m === "number" && 0 < m) {
                var l = 1.5 * m;
                c.D = l;
                c.c.info("backChannelRequestTimeoutMs_=" + l);
              }
              l = c;
              var u = a.a;
              if (u) {
                var C2 = u.a ? u.a.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (C2) {
                  var B2 = l.b;
                  !B2.a && (v$1(C2, "spdy") || v$1(C2, "quic") || v$1(C2, "h2")) && (B2.f = B2.g, B2.a = new Set(), B2.b && (Ec$1(B2, B2.b), B2.b = null));
                }
                if (l.A) {
                  var rb = u.a ? u.a.getResponseHeader("X-HTTP-Session-Id") : null;
                  rb && (l.na = rb, R$1(l.B, l.A, rb));
                }
              }
              c.v = 3;
              c.f && c.f.ta();
              c.U && (c.N = q$1() - a.u, c.c.info("Handshake RTT: " + c.N + "ms"));
              l = c;
              var xa2 = a;
              l.la = Fc$1(l, l.C ? l.ga : null, l.fa);
              if (xa2.C) {
                Gc$1(l.b, xa2);
                var ya2 = xa2, xc2 = l.D;
                xc2 && ya2.setTimeout(xc2);
                ya2.o && (pc$1(ya2), mc$1(ya2));
                l.a = xa2;
              } else
                Hc$1(l);
              0 < c.g.length && Ic$1(c);
            } else
              e[0] != "stop" && e[0] != "close" || Q$1(c, 7);
          else
            c.v == 3 && (e[0] == "stop" || e[0] == "close" ? e[0] == "stop" ? Q$1(c, 7) : Jc$1(c) : e[0] != "noop" && c.f && c.f.sa(e), c.o = 0);
    }
    I(4);
  } catch (tc2) {
  }
}
function Kc$1(a) {
  if (a.K && typeof a.K == "function")
    return a.K();
  if (typeof a === "string")
    return a.split("");
  if (ba$1(a)) {
    for (var b2 = [], c = a.length, d2 = 0; d2 < c; d2++)
      b2.push(a[d2]);
    return b2;
  }
  b2 = [];
  c = 0;
  for (d2 in a)
    b2[c++] = a[d2];
  return a = b2;
}
function Lc$1(a, b2) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b2, void 0);
  else if (ba$1(a) || typeof a === "string")
    na$1(a, b2, void 0);
  else {
    if (a.L && typeof a.L == "function")
      var c = a.L();
    else if (a.K && typeof a.K == "function")
      c = void 0;
    else if (ba$1(a) || typeof a === "string") {
      c = [];
      for (var d2 = a.length, e = 0; e < d2; e++)
        c.push(e);
    } else
      for (e in c = [], d2 = 0, a)
        c[d2++] = e;
    d2 = Kc$1(a);
    e = d2.length;
    for (var f = 0; f < e; f++)
      b2.call(void 0, d2[f], c && c[f], a);
  }
}
function S(a, b2) {
  this.b = {};
  this.a = [];
  this.c = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d2 = 0; d2 < c; d2 += 2)
      this.set(arguments[d2], arguments[d2 + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.L(), d2 = 0; d2 < c.length; d2++)
        this.set(c[d2], a.get(c[d2]));
    else
      for (d2 in a)
        this.set(d2, a[d2]);
}
h = S.prototype;
h.K = function() {
  Mc$1(this);
  for (var a = [], b2 = 0; b2 < this.a.length; b2++)
    a.push(this.b[this.a[b2]]);
  return a;
};
h.L = function() {
  Mc$1(this);
  return this.a.concat();
};
function Mc$1(a) {
  if (a.c != a.a.length) {
    for (var b2 = 0, c = 0; b2 < a.a.length; ) {
      var d2 = a.a[b2];
      T(a.b, d2) && (a.a[c++] = d2);
      b2++;
    }
    a.a.length = c;
  }
  if (a.c != a.a.length) {
    var e = {};
    for (c = b2 = 0; b2 < a.a.length; )
      d2 = a.a[b2], T(e, d2) || (a.a[c++] = d2, e[d2] = 1), b2++;
    a.a.length = c;
  }
}
h.get = function(a, b2) {
  return T(this.b, a) ? this.b[a] : b2;
};
h.set = function(a, b2) {
  T(this.b, a) || (this.c++, this.a.push(a));
  this.b[a] = b2;
};
h.forEach = function(a, b2) {
  for (var c = this.L(), d2 = 0; d2 < c.length; d2++) {
    var e = c[d2], f = this.get(e);
    a.call(b2, f, e, this);
  }
};
function T(a, b2) {
  return Object.prototype.hasOwnProperty.call(a, b2);
}
var Nc$1 = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Oc$1(a, b2) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d2 = a[c].indexOf("="), e = null;
      if (0 <= d2) {
        var f = a[c].substring(0, d2);
        e = a[c].substring(d2 + 1);
      } else
        f = a[c];
      b2(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U$1(a, b2) {
  this.c = this.j = this.f = "";
  this.h = null;
  this.i = this.g = "";
  this.a = false;
  if (a instanceof U$1) {
    this.a = b2 !== void 0 ? b2 : a.a;
    Pc$1(this, a.f);
    this.j = a.j;
    Qc$1(this, a.c);
    Rc$1(this, a.h);
    this.g = a.g;
    b2 = a.b;
    var c = new Sc$1();
    c.c = b2.c;
    b2.a && (c.a = new S(b2.a), c.b = b2.b);
    Tc$1(this, c);
    this.i = a.i;
  } else
    a && (c = String(a).match(Nc$1)) ? (this.a = !!b2, Pc$1(this, c[1] || "", true), this.j = Uc$1(c[2] || ""), Qc$1(this, c[3] || "", true), Rc$1(this, c[4]), this.g = Uc$1(c[5] || "", true), Tc$1(this, c[6] || "", true), this.i = Uc$1(c[7] || "")) : (this.a = !!b2, this.b = new Sc$1(null, this.a));
}
U$1.prototype.toString = function() {
  var a = [], b2 = this.f;
  b2 && a.push(Vc$1(b2, Wc$1, true), ":");
  var c = this.c;
  if (c || b2 == "file")
    a.push("//"), (b2 = this.j) && a.push(Vc$1(b2, Wc$1, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.h, c != null && a.push(":", String(c));
  if (c = this.g)
    this.c && c.charAt(0) != "/" && a.push("/"), a.push(Vc$1(c, c.charAt(0) == "/" ? Xc$1 : Yc$1, true));
  (c = this.b.toString()) && a.push("?", c);
  (c = this.i) && a.push("#", Vc$1(c, Zc$1));
  return a.join("");
};
function N$1(a) {
  return new U$1(a);
}
function Pc$1(a, b2, c) {
  a.f = c ? Uc$1(b2, true) : b2;
  a.f && (a.f = a.f.replace(/:$/, ""));
}
function Qc$1(a, b2, c) {
  a.c = c ? Uc$1(b2, true) : b2;
}
function Rc$1(a, b2) {
  if (b2) {
    b2 = Number(b2);
    if (isNaN(b2) || 0 > b2)
      throw Error("Bad port number " + b2);
    a.h = b2;
  } else
    a.h = null;
}
function Tc$1(a, b2, c) {
  b2 instanceof Sc$1 ? (a.b = b2, $c$1(a.b, a.a)) : (c || (b2 = Vc$1(b2, ad)), a.b = new Sc$1(b2, a.a));
}
function R$1(a, b2, c) {
  a.b.set(b2, c);
}
function kc$1(a) {
  R$1(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ q$1()).toString(36));
  return a;
}
function bd(a) {
  return a instanceof U$1 ? N$1(a) : new U$1(a, void 0);
}
function cd(a, b2, c, d2) {
  var e = new U$1(null, void 0);
  a && Pc$1(e, a);
  b2 && Qc$1(e, b2);
  c && Rc$1(e, c);
  d2 && (e.g = d2);
  return e;
}
function Uc$1(a, b2) {
  return a ? b2 ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Vc$1(a, b2, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b2, dd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function dd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Wc$1 = /[#\/\?@]/g, Yc$1 = /[#\?:]/g, Xc$1 = /[#\?]/g, ad = /[#\?@]/g, Zc$1 = /#/g;
function Sc$1(a, b2) {
  this.b = this.a = null;
  this.c = a || null;
  this.f = !!b2;
}
function V$1(a) {
  a.a || (a.a = new S(), a.b = 0, a.c && Oc$1(a.c, function(b2, c) {
    a.add(decodeURIComponent(b2.replace(/\+/g, " ")), c);
  }));
}
h = Sc$1.prototype;
h.add = function(a, b2) {
  V$1(this);
  this.c = null;
  a = W$1(this, a);
  var c = this.a.get(a);
  c || this.a.set(a, c = []);
  c.push(b2);
  this.b += 1;
  return this;
};
function ed(a, b2) {
  V$1(a);
  b2 = W$1(a, b2);
  T(a.a.b, b2) && (a.c = null, a.b -= a.a.get(b2).length, a = a.a, T(a.b, b2) && (delete a.b[b2], a.c--, a.a.length > 2 * a.c && Mc$1(a)));
}
function fd(a, b2) {
  V$1(a);
  b2 = W$1(a, b2);
  return T(a.a.b, b2);
}
h.forEach = function(a, b2) {
  V$1(this);
  this.a.forEach(function(c, d2) {
    na$1(c, function(e) {
      a.call(b2, e, d2, this);
    }, this);
  }, this);
};
h.L = function() {
  V$1(this);
  for (var a = this.a.K(), b2 = this.a.L(), c = [], d2 = 0; d2 < b2.length; d2++)
    for (var e = a[d2], f = 0; f < e.length; f++)
      c.push(b2[d2]);
  return c;
};
h.K = function(a) {
  V$1(this);
  var b2 = [];
  if (typeof a === "string")
    fd(this, a) && (b2 = qa$1(b2, this.a.get(W$1(this, a))));
  else {
    a = this.a.K();
    for (var c = 0; c < a.length; c++)
      b2 = qa$1(b2, a[c]);
  }
  return b2;
};
h.set = function(a, b2) {
  V$1(this);
  this.c = null;
  a = W$1(this, a);
  fd(this, a) && (this.b -= this.a.get(a).length);
  this.a.set(a, [b2]);
  this.b += 1;
  return this;
};
h.get = function(a, b2) {
  if (!a)
    return b2;
  a = this.K(a);
  return 0 < a.length ? String(a[0]) : b2;
};
function nc$1(a, b2, c) {
  ed(a, b2);
  0 < c.length && (a.c = null, a.a.set(W$1(a, b2), ra$1(c)), a.b += c.length);
}
h.toString = function() {
  if (this.c)
    return this.c;
  if (!this.a)
    return "";
  for (var a = [], b2 = this.a.L(), c = 0; c < b2.length; c++) {
    var d2 = b2[c], e = encodeURIComponent(String(d2));
    d2 = this.K(d2);
    for (var f = 0; f < d2.length; f++) {
      var g = e;
      d2[f] !== "" && (g += "=" + encodeURIComponent(String(d2[f])));
      a.push(g);
    }
  }
  return this.c = a.join("&");
};
function W$1(a, b2) {
  b2 = String(b2);
  a.f && (b2 = b2.toLowerCase());
  return b2;
}
function $c$1(a, b2) {
  b2 && !a.f && (V$1(a), a.c = null, a.a.forEach(function(c, d2) {
    var e = d2.toLowerCase();
    d2 != e && (ed(this, d2), nc$1(this, e, c));
  }, a));
  a.f = b2;
}
var gd = function() {
  function gd2(a, b2) {
    this.b = a;
    this.a = b2;
  }
  return gd2;
}();
function hd(a) {
  this.g = a || id;
  k$1.PerformanceNavigationTiming ? (a = k$1.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(k$1.ia && k$1.ia.ya && k$1.ia.ya() && k$1.ia.ya().Lb);
  this.f = a ? this.g : 1;
  this.a = null;
  1 < this.f && (this.a = new Set());
  this.b = null;
  this.c = [];
}
var id = 10;
function jd(a) {
  return a.b ? true : a.a ? a.a.size >= a.f : false;
}
function Dc$1(a) {
  return a.b ? 1 : a.a ? a.a.size : 0;
}
function zc$1(a, b2) {
  return a.b ? a.b == b2 : a.a ? a.a.has(b2) : false;
}
function Ec$1(a, b2) {
  a.a ? a.a.add(b2) : a.b = b2;
}
function Gc$1(a, b2) {
  a.b && a.b == b2 ? a.b = null : a.a && a.a.has(b2) && a.a.delete(b2);
}
hd.prototype.cancel = function() {
  var e_1, _a2;
  this.c = kd(this);
  if (this.b)
    this.b.cancel(), this.b = null;
  else if (this.a && this.a.size !== 0) {
    try {
      for (var _b = __values(this.a.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var a = _c2.value;
        a.cancel();
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.a.clear();
  }
};
function kd(a) {
  var e_2, _a2;
  if (a.b != null)
    return a.c.concat(a.b.s);
  if (a.a != null && a.a.size !== 0) {
    var b2 = a.c;
    try {
      for (var _b = __values(a.a.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var c = _c2.value;
        b2 = b2.concat(c.s);
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return b2;
  }
  return ra$1(a.c);
}
function ld() {
}
ld.prototype.stringify = function(a) {
  return k$1.JSON.stringify(a, void 0);
};
ld.prototype.parse = function(a) {
  return k$1.JSON.parse(a, void 0);
};
function md() {
  this.a = new ld();
}
function nd(a, b2, c) {
  var d2 = c || "";
  try {
    Lc$1(a, function(e, f) {
      var g = e;
      n(e) && (g = ub(e));
      b2.push(d2 + f + "=" + encodeURIComponent(g));
    });
  } catch (e) {
    throw b2.push(d2 + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function od(a, b2) {
  var c = new Ob();
  if (k$1.Image) {
    var d2 = new Image();
    d2.onload = ja$1(pd, c, d2, "TestLoadImage: loaded", true, b2);
    d2.onerror = ja$1(pd, c, d2, "TestLoadImage: error", false, b2);
    d2.onabort = ja$1(pd, c, d2, "TestLoadImage: abort", false, b2);
    d2.ontimeout = ja$1(pd, c, d2, "TestLoadImage: timeout", false, b2);
    k$1.setTimeout(function() {
      if (d2.ontimeout)
        d2.ontimeout();
    }, 1e4);
    d2.src = a;
  } else
    b2(false);
}
function pd(a, b2, c, d2, e) {
  try {
    b2.onload = null, b2.onerror = null, b2.onabort = null, b2.ontimeout = null, e(d2);
  } catch (f) {
  }
}
var qd = k$1.JSON.parse;
function X$1(a) {
  D$1.call(this);
  this.headers = new S();
  this.H = a || null;
  this.b = false;
  this.s = this.a = null;
  this.B = "";
  this.h = 0;
  this.f = "";
  this.g = this.A = this.l = this.u = false;
  this.o = 0;
  this.m = null;
  this.I = rd;
  this.D = this.F = false;
}
r(X$1, D$1);
var rd = "", sd = /^https?$/i, td = ["POST", "PUT"];
h = X$1.prototype;
h.ba = function(a, b2, c, d2) {
  if (this.a)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.B + "; newUri=" + a);
  b2 = b2 ? b2.toUpperCase() : "GET";
  this.B = a;
  this.f = "";
  this.h = 0;
  this.u = false;
  this.b = true;
  this.a = new XMLHttpRequest();
  this.s = this.H ? ac$1(this.H) : ac$1(ec$1);
  this.a.onreadystatechange = p(this.za, this);
  try {
    this.A = true, this.a.open(b2, String(a), true), this.A = false;
  } catch (f) {
    ud(this, f);
    return;
  }
  a = c || "";
  var e = new S(this.headers);
  d2 && Lc$1(d2, function(f, g) {
    e.set(g, f);
  });
  d2 = oa$1(e.L());
  c = k$1.FormData && a instanceof k$1.FormData;
  !(0 <= ma$1(td, b2)) || d2 || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, g) {
    this.a.setRequestHeader(g, f);
  }, this);
  this.I && (this.a.responseType = this.I);
  "withCredentials" in this.a && this.a.withCredentials !== this.F && (this.a.withCredentials = this.F);
  try {
    vd(this), 0 < this.o && ((this.D = wd(this.a)) ? (this.a.timeout = this.o, this.a.ontimeout = p(this.xa, this)) : this.m = Ib(this.xa, this.o, this)), this.l = true, this.a.send(a), this.l = false;
  } catch (f) {
    ud(this, f);
  }
};
function wd(a) {
  return x$1 && Qa$1(9) && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa$1(a) {
  return a.toLowerCase() == "content-type";
}
h.xa = function() {
  typeof goog != "undefined" && this.a && (this.f = "Timed out after " + this.o + "ms, aborting", this.h = 8, E(this, "timeout"), this.abort(8));
};
function ud(a, b2) {
  a.b = false;
  a.a && (a.g = true, a.a.abort(), a.g = false);
  a.f = b2;
  a.h = 5;
  xd(a);
  yd(a);
}
function xd(a) {
  a.u || (a.u = true, E(a, "complete"), E(a, "error"));
}
h.abort = function(a) {
  this.a && this.b && (this.b = false, this.g = true, this.a.abort(), this.g = false, this.h = a || 7, E(this, "complete"), E(this, "abort"), yd(this));
};
h.G = function() {
  this.a && (this.b && (this.b = false, this.g = true, this.a.abort(), this.g = false), yd(this, true));
  X$1.X.G.call(this);
};
h.za = function() {
  this.j || (this.A || this.l || this.g ? zd(this) : this.Ua());
};
h.Ua = function() {
  zd(this);
};
function zd(a) {
  if (a.b && typeof goog != "undefined" && (!a.s[1] || O$1(a) != 4 || a.W() != 2)) {
    if (a.l && O$1(a) == 4)
      Ib(a.za, 0, a);
    else if (E(a, "readystatechange"), O$1(a) == 4) {
      a.b = false;
      try {
        {
          var l = a.W();
          a:
            switch (l) {
              case 200:
              case 201:
              case 202:
              case 204:
              case 206:
              case 304:
              case 1223:
                var b2 = true;
                break a;
              default:
                b2 = false;
            }
          var c;
          if (!(c = b2)) {
            var d2;
            if (d2 = l === 0) {
              var e = String(a.B).match(Nc$1)[1] || null;
              if (!e && k$1.self && k$1.self.location) {
                var f = k$1.self.location.protocol;
                e = f.substr(0, f.length - 1);
              }
              d2 = !sd.test(e ? e.toLowerCase() : "");
            }
            c = d2;
          }
          var g = c;
        }
        if (g)
          E(a, "complete"), E(a, "success");
        else {
          a.h = 6;
          try {
            var m = 2 < O$1(a) ? a.a.statusText : "";
          } catch (l2) {
            m = "";
          }
          a.f = m + " [" + a.W() + "]";
          xd(a);
        }
      } finally {
        yd(a);
      }
    }
  }
}
function yd(a, b2) {
  if (a.a) {
    vd(a);
    var c = a.a, d2 = a.s[0] ? aa$1 : null;
    a.a = null;
    a.s = null;
    b2 || E(a, "ready");
    try {
      c.onreadystatechange = d2;
    } catch (e) {
    }
  }
}
function vd(a) {
  a.a && a.D && (a.a.ontimeout = null);
  a.m && (k$1.clearTimeout(a.m), a.m = null);
}
function O$1(a) {
  return a.a ? a.a.readyState : 0;
}
h.W = function() {
  try {
    return 2 < O$1(this) ? this.a.status : -1;
  } catch (a) {
    return -1;
  }
};
h.$ = function() {
  try {
    return this.a ? this.a.responseText : "";
  } catch (a) {
    return "";
  }
};
h.Pa = function(a) {
  if (this.a) {
    var b2 = this.a.responseText;
    a && b2.indexOf(a) == 0 && (b2 = b2.substring(a.length));
    return qd(b2);
  }
};
h.ua = function() {
  return this.h;
};
h.Qa = function() {
  return typeof this.f === "string" ? this.f : String(this.f);
};
function Ad(a) {
  var b2 = "";
  za$1(a, function(c, d2) {
    b2 += d2;
    b2 += ":";
    b2 += c;
    b2 += "\r\n";
  });
  return b2;
}
function Bd(a, b2, c) {
  a: {
    for (d2 in c) {
      var d2 = false;
      break a;
    }
    d2 = true;
  }
  d2 || (c = Ad(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R$1(a, b2, c));
}
function Cd(a, b2, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b2 : b2;
}
function Dd(a) {
  this.pa = 0;
  this.g = [];
  this.c = new Ob();
  this.ga = this.la = this.B = this.fa = this.a = this.na = this.A = this.V = this.i = this.O = this.l = null;
  this.Oa = this.R = 0;
  this.La = Cd("failFast", false, a);
  this.H = this.m = this.j = this.h = this.f = null;
  this.S = true;
  this.I = this.oa = this.P = -1;
  this.T = this.o = this.u = 0;
  this.Ha = Cd("baseRetryDelayMs", 5e3, a);
  this.Ra = Cd("retryDelaySeedMs", 1e4, a);
  this.Ma = Cd("forwardChannelMaxRetries", 2, a);
  this.ma = Cd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.Na = a && a.g || void 0;
  this.D = void 0;
  this.C = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.b = new hd(a && a.concurrentRequestLimit);
  this.ka = new md();
  this.da = a && a.fastHandshake || false;
  this.Ia = a && a.b || false;
  a && a.f && (this.c.a = false);
  a && a.forceLongPolling && (this.S = false);
  this.U = !this.da && this.S && a && a.detectBufferingProxy || false;
  this.ea = void 0;
  this.N = 0;
  this.F = false;
  this.s = null;
  (this.Ka = a && a.c || false) && this.c.info("Opt-in to enable Chrome Origin Trials.");
}
h = Dd.prototype;
h.ha = 8;
h.v = 1;
function Jc$1(a) {
  Ed(a);
  if (a.v == 3) {
    var b2 = a.R++, c = N$1(a.B);
    R$1(c, "SID", a.J);
    R$1(c, "RID", b2);
    R$1(c, "TYPE", "terminate");
    Fd(a, c);
    b2 = new M$1(a, a.c, b2, void 0);
    b2.H = 2;
    b2.i = kc$1(N$1(c));
    c = false;
    k$1.navigator && k$1.navigator.sendBeacon && (c = k$1.navigator.sendBeacon(b2.i.toString(), ""));
    !c && k$1.Image && (new Image().src = b2.i, c = true);
    c || (b2.a = oc$1(b2.g, null), b2.a.ba(b2.i));
    b2.u = q$1();
    mc$1(b2);
  }
  Gd(a);
}
function Bc$1(a) {
  a.a && (wc$1(a), a.a.cancel(), a.a = null);
}
function Ed(a) {
  Bc$1(a);
  a.j && (k$1.clearTimeout(a.j), a.j = null);
  Ac$1(a);
  a.b.cancel();
  a.h && (typeof a.h === "number" && k$1.clearTimeout(a.h), a.h = null);
}
function Hd(a, b2) {
  a.g.push(new gd(a.Oa++, b2));
  a.v == 3 && Ic$1(a);
}
function Ic$1(a) {
  jd(a.b) || a.h || (a.h = true, Bb(a.Ba, a), a.u = 0);
}
function Id(a, b2) {
  if (Dc$1(a.b) >= a.b.f - (a.h ? 1 : 0))
    return false;
  if (a.h)
    return a.g = b2.s.concat(a.g), true;
  if (a.v == 1 || a.v == 2 || a.u >= (a.La ? 0 : a.Ma))
    return false;
  a.h = K$1(p(a.Ba, a, b2), Jd(a, a.u));
  a.u++;
  return true;
}
h.Ba = function(a) {
  if (this.h)
    if (this.h = null, this.v == 1) {
      if (!a) {
        this.R = Math.floor(1e5 * Math.random());
        a = this.R++;
        var b2 = new M$1(this, this.c, a, void 0), c = this.l;
        this.O && (c ? (c = Aa$1(c), Ca$1(c, this.O)) : c = this.O);
        this.i === null && (b2.B = c);
        var d2;
        if (this.da)
          a: {
            for (var e = d2 = 0; e < this.g.length; e++) {
              b: {
                var f = this.g[e];
                if ("__data__" in f.a && (f = f.a.__data__, typeof f === "string")) {
                  f = f.length;
                  break b;
                }
                f = void 0;
              }
              if (f === void 0)
                break;
              d2 += f;
              if (4096 < d2) {
                d2 = e;
                break a;
              }
              if (d2 === 4096 || e === this.g.length - 1) {
                d2 = e + 1;
                break a;
              }
            }
            d2 = 1e3;
          }
        else
          d2 = 1e3;
        d2 = Kd(this, b2, d2);
        e = N$1(this.B);
        R$1(e, "RID", a);
        R$1(e, "CVER", 22);
        this.A && R$1(e, "X-HTTP-Session-Id", this.A);
        Fd(this, e);
        this.i && c && Bd(e, this.i, c);
        Ec$1(this.b, b2);
        this.Ia && R$1(e, "TYPE", "init");
        this.da ? (R$1(e, "$req", d2), R$1(e, "SID", "null"), b2.U = true, jc$1(b2, e, null)) : jc$1(b2, e, d2);
        this.v = 2;
      }
    } else
      this.v == 3 && (a ? Ld(this, a) : this.g.length == 0 || jd(this.b) || Ld(this));
};
function Ld(a, b2) {
  var c;
  b2 ? c = b2.f : c = a.R++;
  var d2 = N$1(a.B);
  R$1(d2, "SID", a.J);
  R$1(d2, "RID", c);
  R$1(d2, "AID", a.P);
  Fd(a, d2);
  a.i && a.l && Bd(d2, a.i, a.l);
  c = new M$1(a, a.c, c, a.u + 1);
  a.i === null && (c.B = a.l);
  b2 && (a.g = b2.s.concat(a.g));
  b2 = Kd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ma) + Math.round(0.5 * a.ma * Math.random()));
  Ec$1(a.b, c);
  jc$1(c, d2, b2);
}
function Fd(a, b2) {
  a.f && Lc$1({}, function(c, d2) {
    R$1(b2, d2, c);
  });
}
function Kd(a, b2, c) {
  c = Math.min(a.g.length, c);
  var d2 = a.f ? p(a.f.Ja, a.f, a) : null;
  a:
    for (var e = a.g, f = -1; ; ) {
      var g = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].b, g.push("ofs=" + f)) : f = 0 : g.push("ofs=" + f);
      for (var m = true, l = 0; l < c; l++) {
        var u = e[l].b, C2 = e[l].a;
        u -= f;
        if (0 > u)
          f = Math.max(0, e[l].b - 100), m = false;
        else
          try {
            nd(C2, g, "req" + u + "_");
          } catch (B2) {
            d2 && d2(C2);
          }
      }
      if (m) {
        d2 = g.join("&");
        break a;
      }
    }
  a = a.g.splice(0, c);
  b2.s = a;
  return d2;
}
function Hc$1(a) {
  a.a || a.j || (a.T = 1, Bb(a.Aa, a), a.o = 0);
}
function Cc$1(a) {
  if (a.a || a.j || 3 <= a.o)
    return false;
  a.T++;
  a.j = K$1(p(a.Aa, a), Jd(a, a.o));
  a.o++;
  return true;
}
h.Aa = function() {
  this.j = null;
  Md(this);
  if (this.U && !(this.F || this.a == null || 0 >= this.N)) {
    var a = 2 * this.N;
    this.c.info("BP detection timer enabled: " + a);
    this.s = K$1(p(this.Ta, this), a);
  }
};
h.Ta = function() {
  this.s && (this.s = null, this.c.info("BP detection timeout reached."), this.c.info("Buffering proxy detected and switch to long-polling!"), this.H = false, this.F = true, J$1(10), Bc$1(this), Md(this));
};
function wc$1(a) {
  a.s != null && (k$1.clearTimeout(a.s), a.s = null);
}
function Md(a) {
  a.a = new M$1(a, a.c, "rpc", a.T);
  a.i === null && (a.a.B = a.l);
  a.a.O = 0;
  var b2 = N$1(a.la);
  R$1(b2, "RID", "rpc");
  R$1(b2, "SID", a.J);
  R$1(b2, "CI", a.H ? "0" : "1");
  R$1(b2, "AID", a.P);
  Fd(a, b2);
  R$1(b2, "TYPE", "xmlhttp");
  a.i && a.l && Bd(b2, a.i, a.l);
  a.D && a.a.setTimeout(a.D);
  var c = a.a;
  a = a.ga;
  c.H = 1;
  c.i = kc$1(N$1(b2));
  c.j = null;
  c.I = true;
  lc$1(c, a);
}
h.Sa = function() {
  this.m != null && (this.m = null, Bc$1(this), Cc$1(this), J$1(19));
};
function Ac$1(a) {
  a.m != null && (k$1.clearTimeout(a.m), a.m = null);
}
function uc$1(a, b2) {
  var c = null;
  if (a.a == b2) {
    Ac$1(a);
    wc$1(a);
    a.a = null;
    var d2 = 2;
  } else if (zc$1(a.b, b2))
    c = b2.s, Gc$1(a.b, b2), d2 = 1;
  else
    return;
  a.I = b2.N;
  if (a.v != 0) {
    if (b2.b)
      if (d2 == 1) {
        c = b2.j ? b2.j.length : 0;
        b2 = q$1() - b2.u;
        var e = a.u;
        d2 = Ub();
        E(d2, new Xb(d2, c, b2, e));
        Ic$1(a);
      } else
        Hc$1(a);
    else if (e = b2.h, e == 3 || e == 0 && 0 < a.I || !(d2 == 1 && Id(a, b2) || d2 == 2 && Cc$1(a)))
      switch (c && 0 < c.length && (b2 = a.b, b2.c = b2.c.concat(c)), e) {
        case 1:
          Q$1(a, 5);
          break;
        case 4:
          Q$1(a, 10);
          break;
        case 3:
          Q$1(a, 6);
          break;
        default:
          Q$1(a, 2);
      }
  }
}
function Jd(a, b2) {
  var c = a.Ha + Math.floor(Math.random() * a.Ra);
  a.f || (c *= 2);
  return c * b2;
}
function Q$1(a, b2) {
  a.c.info("Error code " + b2);
  if (b2 == 2) {
    var c = null;
    a.f && (c = null);
    var d2 = p(a.Ya, a);
    c || (c = new U$1("//www.google.com/images/cleardot.gif"), k$1.location && k$1.location.protocol == "http" || Pc$1(c, "https"), kc$1(c));
    od(c.toString(), d2);
  } else
    J$1(2);
  a.v = 0;
  a.f && a.f.ra(b2);
  Gd(a);
  Ed(a);
}
h.Ya = function(a) {
  a ? (this.c.info("Successfully pinged google.com"), J$1(2)) : (this.c.info("Failed to ping google.com"), J$1(1));
};
function Gd(a) {
  a.v = 0;
  a.I = -1;
  if (a.f) {
    if (kd(a.b).length != 0 || a.g.length != 0)
      a.b.c.length = 0, ra$1(a.g), a.g.length = 0;
    a.f.qa();
  }
}
function Fc$1(a, b2, c) {
  var d2 = bd(c);
  if (d2.c != "")
    b2 && Qc$1(d2, b2 + "." + d2.c), Rc$1(d2, d2.h);
  else {
    var e = k$1.location;
    d2 = cd(e.protocol, b2 ? b2 + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.V && za$1(a.V, function(f, g) {
    R$1(d2, g, f);
  });
  b2 = a.A;
  c = a.na;
  b2 && c && R$1(d2, b2, c);
  R$1(d2, "VER", a.ha);
  Fd(a, d2);
  return d2;
}
function oc$1(a, b2) {
  if (b2 && !a.C)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b2 = new X$1(a.Na);
  b2.F = a.C;
  return b2;
}
function Nd() {
}
h = Nd.prototype;
h.ta = function() {
};
h.sa = function() {
};
h.ra = function() {
};
h.qa = function() {
};
h.Ja = function() {
};
function Od() {
  if (x$1 && !(10 <= Number(Ta$1)))
    throw Error("Environmental error: no available transport.");
}
Od.prototype.a = function(a, b2) {
  return new Y$1(a, b2);
};
function Y$1(a, b2) {
  D$1.call(this);
  this.a = new Dd(b2);
  this.o = a;
  this.b = b2 && b2.messageUrlParams || null;
  a = b2 && b2.messageHeaders || null;
  b2 && b2.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = {"X-Client-Protocol": "webchannel"});
  this.a.l = a;
  a = b2 && b2.initMessageHeaders || null;
  b2 && b2.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b2.messageContentType : a = {"X-WebChannel-Content-Type": b2.messageContentType});
  b2 && b2.a && (a ? a["X-WebChannel-Client-Profile"] = b2.a : a = {"X-WebChannel-Client-Profile": b2.a});
  this.a.O = a;
  (a = b2 && b2.httpHeadersOverwriteParam) && !sa$1(a) && (this.a.i = a);
  this.m = b2 && b2.supportsCrossDomainXhr || false;
  this.l = b2 && b2.sendRawJson || false;
  (b2 = b2 && b2.httpSessionIdParam) && !sa$1(b2) && (this.a.A = b2, a = this.b, a !== null && b2 in a && (a = this.b, b2 in a && delete a[b2]));
  this.f = new Z$1(this);
}
r(Y$1, D$1);
Y$1.prototype.g = function() {
  this.a.f = this.f;
  this.m && (this.a.C = true);
  var a = this.a, b2 = this.o, c = this.b || void 0;
  J$1(0);
  a.fa = b2;
  a.V = c || {};
  a.H = a.S;
  a.B = Fc$1(a, null, a.fa);
  Ic$1(a);
};
Y$1.prototype.close = function() {
  Jc$1(this.a);
};
Y$1.prototype.h = function(a) {
  if (typeof a === "string") {
    var b2 = {};
    b2.__data__ = a;
    Hd(this.a, b2);
  } else
    this.l ? (b2 = {}, b2.__data__ = ub(a), Hd(this.a, b2)) : Hd(this.a, a);
};
Y$1.prototype.G = function() {
  this.a.f = null;
  delete this.f;
  Jc$1(this.a);
  delete this.a;
  Y$1.X.G.call(this);
};
function Pd(a) {
  cc$1.call(this);
  var b2 = a.__sm__;
  if (b2) {
    a: {
      for (var c in b2) {
        a = c;
        break a;
      }
      a = void 0;
    }
    (this.c = a) ? (a = this.c, this.data = b2 !== null && a in b2 ? b2[a] : void 0) : this.data = b2;
  } else
    this.data = a;
}
r(Pd, cc$1);
function Qd() {
  dc$1.call(this);
  this.status = 1;
}
r(Qd, dc$1);
function Z$1(a) {
  this.a = a;
}
r(Z$1, Nd);
Z$1.prototype.ta = function() {
  E(this.a, "a");
};
Z$1.prototype.sa = function(a) {
  E(this.a, new Pd(a));
};
Z$1.prototype.ra = function(a) {
  E(this.a, new Qd(a));
};
Z$1.prototype.qa = function() {
  E(this.a, "b");
};
Od.prototype.createWebChannel = Od.prototype.a;
Y$1.prototype.send = Y$1.prototype.h;
Y$1.prototype.open = Y$1.prototype.g;
Y$1.prototype.close = Y$1.prototype.close;
Yb.NO_ERROR = 0;
Yb.TIMEOUT = 8;
Yb.HTTP_ERROR = 6;
Zb.COMPLETE = "complete";
bc$1.EventType = L$1;
L$1.OPEN = "a";
L$1.CLOSE = "b";
L$1.ERROR = "c";
L$1.MESSAGE = "d";
D$1.prototype.listen = D$1.prototype.va;
X$1.prototype.listenOnce = X$1.prototype.wa;
X$1.prototype.getLastError = X$1.prototype.Qa;
X$1.prototype.getLastErrorCode = X$1.prototype.ua;
X$1.prototype.getStatus = X$1.prototype.W;
X$1.prototype.getResponseJson = X$1.prototype.Pa;
X$1.prototype.getResponseText = X$1.prototype.$;
X$1.prototype.send = X$1.prototype.ba;
var createWebChannelTransport = function() {
  return new Od();
};
var getStatEventTarget = function() {
  return Ub();
};
var ErrorCode = Yb;
var EventType = Zb;
var Event = H$1;
var Stat = {gb: 0, jb: 1, kb: 2, Db: 3, Ib: 4, Fb: 5, Gb: 6, Eb: 7, Cb: 8, Hb: 9, PROXY: 10, NOPROXY: 11, Ab: 12, wb: 13, xb: 14, vb: 15, yb: 16, zb: 17, bb: 18, ab: 19, cb: 20};
var WebChannel = bc$1;
var XhrIo = X$1;
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class R {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.t(t3), this.i = (t3) => e.writeSequenceNumber(t3));
  }
  t(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.i && this.i(t2), t2;
  }
}
R.o = -1;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const P = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
class b extends Error {
  constructor(t2, e) {
    super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const v = new Logger("@firebase/firestore");
function V() {
  return v.logLevel;
}
function D(t2, ...e) {
  if (v.logLevel <= LogLevel.DEBUG) {
    const n2 = e.map(x);
    v.debug(`Firestore (8.4.1): ${t2}`, ...n2);
  }
}
function C(t2, ...e) {
  if (v.logLevel <= LogLevel.ERROR) {
    const n2 = e.map(x);
    v.error(`Firestore (8.4.1): ${t2}`, ...n2);
  }
}
function N(t2, ...e) {
  if (v.logLevel <= LogLevel.WARN) {
    const n2 = e.map(x);
    v.warn(`Firestore (8.4.1): ${t2}`, ...n2);
  }
}
function x(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  /**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function k(t2 = "Unexpected state") {
  const e = "FIRESTORE (8.4.1) INTERNAL ASSERTION FAILED: " + t2;
  throw C(e), new Error(e);
}
function O(t2, e) {
  t2 || k();
}
function $(t2, e) {
  return t2;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function M(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n2 = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n2);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n2[e2] = Math.floor(256 * Math.random());
  return n2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class F {
  static u() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n2 = "";
    for (; n2.length < 20; ) {
      const s = M(40);
      for (let i = 0; i < s.length; ++i)
        n2.length < 20 && s[i] < e && (n2 += t2.charAt(s[i] % t2.length));
    }
    return n2;
  }
}
function L(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function B(t2, e, n2) {
  return t2.length === e.length && t2.every((t3, s) => n2(t3, e[s]));
}
function q(t2) {
  return t2 + "\0";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class U {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new b(P.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new b(P.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new b(P.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new b(P.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return U.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return U.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n2 = Math.floor(1e6 * (t2 - 1e3 * e));
    return new U(e, n2);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? L(this.nanoseconds, t2.nanoseconds) : L(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class K {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new K(t2);
  }
  static min() {
    return new K(new U(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Q(t2) {
  let e = 0;
  for (const n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e++;
  return e;
}
function j(t2, e) {
  for (const n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e(n2, t2[n2]);
}
function W(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class G {
  constructor(t2, e, n2) {
    e === void 0 ? e = 0 : e > t2.length && k(), n2 === void 0 ? n2 = t2.length - e : n2 > t2.length - e && k(), this.segments = t2, this.offset = e, this.len = n2;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return G.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof G ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n2 = this.limit(); e < n2; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n2 = Math.min(t2.length, e.length);
    for (let s = 0; s < n2; s++) {
      const n3 = t2.get(s), i = e.get(s);
      if (n3 < i)
        return -1;
      if (n3 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
}
class z extends G {
  construct(t2, e, n2) {
    return new z(t2, e, n2);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n2 of t2) {
      if (n2.indexOf("//") >= 0)
        throw new b(P.INVALID_ARGUMENT, `Invalid segment (${n2}). Paths must not contain // in them.`);
      e.push(...n2.split("/").filter((t3) => t3.length > 0));
    }
    return new z(e);
  }
  static emptyPath() {
    return new z([]);
  }
}
const H = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class J extends G {
  construct(t2, e, n2) {
    return new J(t2, e, n2);
  }
  static isValidIdentifier(t2) {
    return H.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), J.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new J(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n2 = "", s = 0;
    const i = () => {
      if (n2.length === 0)
        throw new b(P.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n2), n2 = "";
    };
    let r2 = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new b(P.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new b(P.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n2 += e3, s += 2;
      } else
        e2 === "`" ? (r2 = !r2, s++) : e2 !== "." || r2 ? (n2 += e2, s++) : (i(), s++);
    }
    if (i(), r2)
      throw new b(P.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new J(e);
  }
  static emptyPath() {
    return new J([]);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Y {
  constructor(t2) {
    this.fields = t2, t2.sort(J.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return B(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class X {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new X(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n2 = 0; n2 < t3.length; ++n2)
        e2 += String.fromCharCode(t3[n2]);
      return e2;
    }(t2);
    return new X(e);
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n2 = 0; n2 < t2.length; n2++)
        e[n2] = t2.charCodeAt(n2);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return L(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
}
X.EMPTY_BYTE_STRING = new X("");
const Z = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function tt(t2) {
  if (O(!!t2), typeof t2 == "string") {
    let e = 0;
    const n2 = Z.exec(t2);
    if (O(!!n2), n2[1]) {
      let t3 = n2[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: et(t2.seconds),
    nanos: et(t2.nanos)
  };
}
function et(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function nt(t2) {
  return typeof t2 == "string" ? X.fromBase64String(t2) : X.fromUint8Array(t2);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function st(t2) {
  var e, n2;
  return ((n2 = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n2 === void 0 ? void 0 : n2.stringValue) === "server_timestamp";
}
function it(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return st(e) ? it(e) : e;
}
function rt(t2) {
  const e = tt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new U(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ot(t2) {
  return t2 == null;
}
function ct(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function ut(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !ct(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class at {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new at(z.fromString(t2));
  }
  static fromName(t2) {
    return new at(z.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && z.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return z.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new at(new z(t2.slice()));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ht(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? st(t2) ? 4 : 10 : k();
}
function lt(t2, e) {
  const n2 = ht(t2);
  if (n2 !== ht(e))
    return false;
  switch (n2) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return rt(t2).isEqual(rt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n3 = tt(t3.timestampValue), s = tt(e2.timestampValue);
        return n3.seconds === s.seconds && n3.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return nt(t3.bytesValue).isEqual(nt(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return et(t3.geoPointValue.latitude) === et(e2.geoPointValue.latitude) && et(t3.geoPointValue.longitude) === et(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return et(t3.integerValue) === et(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n3 = et(t3.doubleValue), s = et(e2.doubleValue);
          return n3 === s ? ct(n3) === ct(s) : isNaN(n3) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return B(t2.arrayValue.values || [], e.arrayValue.values || [], lt);
    case 10:
      return function(t3, e2) {
        const n3 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (Q(n3) !== Q(s))
          return false;
        for (const t4 in n3)
          if (n3.hasOwnProperty(t4) && (s[t4] === void 0 || !lt(n3[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return k();
  }
}
function ft(t2, e) {
  return (t2.values || []).find((t3) => lt(t3, e)) !== void 0;
}
function dt(t2, e) {
  const n2 = ht(t2), s = ht(e);
  if (n2 !== s)
    return L(n2, s);
  switch (n2) {
    case 0:
      return 0;
    case 1:
      return L(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n3 = et(t3.integerValue || t3.doubleValue), s2 = et(e2.integerValue || e2.doubleValue);
        return n3 < s2 ? -1 : n3 > s2 ? 1 : n3 === s2 ? 0 : isNaN(n3) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return wt(t2.timestampValue, e.timestampValue);
    case 4:
      return wt(rt(t2), rt(e));
    case 5:
      return L(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n3 = nt(t3), s2 = nt(e2);
        return n3.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n3 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n3.length && t4 < s2.length; t4++) {
          const e3 = L(n3[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return L(n3.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n3 = L(et(t3.latitude), et(e2.latitude));
        if (n3 !== 0)
          return n3;
        return L(et(t3.longitude), et(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n3 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n3.length && t4 < s2.length; ++t4) {
          const e3 = dt(n3[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return L(n3.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n3 = t3.fields || {}, s2 = Object.keys(n3), i = e2.fields || {}, r2 = Object.keys(i);
        s2.sort(), r2.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r2.length; ++t4) {
          const e3 = L(s2[t4], r2[t4]);
          if (e3 !== 0)
            return e3;
          const o = dt(n3[s2[t4]], i[r2[t4]]);
          if (o !== 0)
            return o;
        }
        return L(s2.length, r2.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw k();
  }
}
function wt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return L(t2, e);
  const n2 = tt(t2), s = tt(e), i = L(n2.seconds, s.seconds);
  return i !== 0 ? i : L(n2.nanos, s.nanos);
}
function _t(t2) {
  return mt(t2);
}
function mt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = tt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? nt(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n2 = t2.referenceValue, at.fromName(n2).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n3 = true;
    for (const s of t3.values || [])
      n3 ? n3 = false : e2 += ",", e2 += mt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n3 = "{", s = true;
    for (const i of e2)
      s ? s = false : n3 += ",", n3 += `${i}:${mt(t3.fields[i])}`;
    return n3 + "}";
  }(t2.mapValue) : k();
  var e, n2;
}
function gt(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function yt(t2) {
  return !!t2 && "integerValue" in t2;
}
function pt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Et(t2) {
  return !!t2 && "nullValue" in t2;
}
function Tt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function It(t2) {
  return !!t2 && "mapValue" in t2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class At {
  constructor(t2) {
    this.overlayMap = new Map(), this.partialValue = t2;
  }
  static empty() {
    return new At({
      mapValue: {}
    });
  }
  field(t2) {
    return At.extractNestedValue(this.buildProto(), t2);
  }
  toProto() {
    return this.field(J.emptyPath());
  }
  set(t2, e) {
    this.setOverlay(t2, e);
  }
  setAll(t2) {
    t2.forEach((t3, e) => {
      t3 ? this.set(e, t3) : this.delete(e);
    });
  }
  delete(t2) {
    this.setOverlay(t2, null);
  }
  isEqual(t2) {
    return lt(this.buildProto(), t2.buildProto());
  }
  setOverlay(t2, e) {
    let n2 = this.overlayMap;
    for (let e2 = 0; e2 < t2.length - 1; ++e2) {
      const s = t2.get(e2);
      let i = n2.get(s);
      i instanceof Map ? n2 = i : i && ht(i) === 10 ? (i = new Map(Object.entries(i.mapValue.fields || {})), n2.set(s, i), n2 = i) : (i = new Map(), n2.set(s, i), n2 = i);
    }
    n2.set(t2.lastSegment(), e);
  }
  applyOverlay(t2, e) {
    let n2 = false;
    const s = At.extractNestedValue(this.partialValue, t2), i = It(s) ? Object.assign({}, s.mapValue.fields) : {};
    return e.forEach((e2, s2) => {
      if (e2 instanceof Map) {
        const r2 = this.applyOverlay(t2.child(s2), e2);
        r2 != null && (i[s2] = r2, n2 = true);
      } else
        e2 !== null ? (i[s2] = e2, n2 = true) : i.hasOwnProperty(s2) && (delete i[s2], n2 = true);
    }), n2 ? {
      mapValue: {
        fields: i
      }
    } : null;
  }
  buildProto() {
    const t2 = this.applyOverlay(J.emptyPath(), this.overlayMap);
    return t2 != null && (this.partialValue = t2, this.overlayMap.clear()), this.partialValue;
  }
  static extractNestedValue(t2, e) {
    if (e.isEmpty())
      return t2;
    {
      let n2 = t2;
      for (let t3 = 0; t3 < e.length - 1; ++t3) {
        if (!n2.mapValue.fields)
          return null;
        if (n2 = n2.mapValue.fields[e.get(t3)], !It(n2))
          return null;
      }
      return n2 = (n2.mapValue.fields || {})[e.lastSegment()], n2 || null;
    }
  }
  clone() {
    return new At(this.buildProto());
  }
}
function Rt(t2) {
  const e = [];
  return j(t2.fields || {}, (t3, n2) => {
    const s = new J([t3]);
    if (It(n2)) {
      const t4 = Rt(n2.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n3 of t4)
          e.push(s.child(n3));
    } else
      e.push(s);
  }), new Y(e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pt {
  constructor(t2, e, n2, s, i) {
    this.key = t2, this.documentType = e, this.version = n2, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new Pt(t2, 0, K.min(), At.empty(), 0);
  }
  static newFoundDocument(t2, e, n2) {
    return new Pt(t2, 1, e, n2, 0);
  }
  static newNoDocument(t2, e) {
    return new Pt(t2, 2, e, At.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Pt(t2, 3, e, At.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = At.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = At.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Pt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  clone() {
    return new Pt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.toProto())}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bt {
  constructor(t2, e = null, n2 = [], s = [], i = null, r2 = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n2, this.filters = s, this.limit = i, this.startAt = r2, this.endAt = o, this.h = null;
  }
}
function vt(t2, e = null, n2 = [], s = [], i = null, r2 = null, o = null) {
  return new bt(t2, e, n2, s, i, r2, o);
}
function Vt(t2) {
  const e = $(t2);
  if (e.h === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => xt(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), ot(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += Kt(e.startAt)), e.endAt && (t3 += "|ub:", t3 += Kt(e.endAt)), e.h = t3;
  }
  return e.h;
}
function St(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${_t(e2.value)}`;
    var e2;
  }).join(", ")}]`), ot(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + Kt(t2.startAt)), t2.endAt && (e += ", endAt: " + Kt(t2.endAt)), `Target(${e})`;
}
function Dt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n3 = 0; n3 < t2.orderBy.length; n3++)
    if (!jt(t2.orderBy[n3], e.orderBy[n3]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n2 = t2.filters[i], s = e.filters[i], n2.op !== s.op || !n2.field.isEqual(s.field) || !lt(n2.value, s.value))
      return false;
  var n2, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!Gt(t2.startAt, e.startAt) && Gt(t2.endAt, e.endAt)));
}
function Ct(t2) {
  return at.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
class Nt extends class {
} {
  constructor(t2, e, n2) {
    super(), this.field = t2, this.op = e, this.value = n2;
  }
  static create(t2, e, n2) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.l(t2, e, n2) : new kt(t2, e, n2) : e === "array-contains" ? new Ft(t2, n2) : e === "in" ? new Lt(t2, n2) : e === "not-in" ? new Bt(t2, n2) : e === "array-contains-any" ? new qt(t2, n2) : new Nt(t2, e, n2);
  }
  static l(t2, e, n2) {
    return e === "in" ? new Ot(t2, n2) : new $t(t2, n2);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.m(dt(e, this.value)) : e !== null && ht(this.value) === ht(e) && this.m(dt(e, this.value));
  }
  m(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return k();
    }
  }
  g() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
}
function xt(t2) {
  return t2.field.canonicalString() + t2.op.toString() + _t(t2.value);
}
class kt extends Nt {
  constructor(t2, e, n2) {
    super(t2, e, n2), this.key = at.fromName(n2.referenceValue);
  }
  matches(t2) {
    const e = at.comparator(t2.key, this.key);
    return this.m(e);
  }
}
class Ot extends Nt {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = Mt("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
}
class $t extends Nt {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = Mt("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
}
function Mt(t2, e) {
  var n2;
  return (((n2 = e.arrayValue) === null || n2 === void 0 ? void 0 : n2.values) || []).map((t3) => at.fromName(t3.referenceValue));
}
class Ft extends Nt {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return pt(e) && ft(e.arrayValue, this.value);
  }
}
class Lt extends Nt {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && ft(this.value.arrayValue, e);
  }
}
class Bt extends Nt {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (ft(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !ft(this.value.arrayValue, e);
  }
}
class qt extends Nt {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!pt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => ft(this.value.arrayValue, t3));
  }
}
class Ut {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
}
function Kt(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => _t(t3)).join(",")}`;
}
class Qt {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
}
function jt(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function Wt(t2, e, n2) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r2 = e[i], o = t2.position[i];
    if (r2.field.isKeyField())
      s = at.comparator(at.fromName(o.referenceValue), n2.key);
    else {
      s = dt(o, n2.data.field(r2.field));
    }
    if (r2.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function Gt(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n2 = 0; n2 < t2.position.length; n2++) {
    if (!lt(t2.position[n2], e.position[n2]))
      return false;
  }
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zt {
  constructor(t2, e = null, n2 = [], s = [], i = null, r2 = "F", o = null, c = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n2, this.filters = s, this.limit = i, this.limitType = r2, this.startAt = o, this.endAt = c, this.p = null, this.T = null, this.startAt, this.endAt;
  }
}
function Ht(t2, e, n2, s, i, r2, o, c) {
  return new zt(t2, e, n2, s, i, r2, o, c);
}
function Jt(t2) {
  return new zt(t2);
}
function Yt(t2) {
  return !ot(t2.limit) && t2.limitType === "F";
}
function Xt(t2) {
  return !ot(t2.limit) && t2.limitType === "L";
}
function Zt(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function te(t2) {
  for (const e of t2.filters)
    if (e.g())
      return e.field;
  return null;
}
function ee(t2) {
  return t2.collectionGroup !== null;
}
function ne(t2) {
  const e = $(t2);
  if (e.p === null) {
    e.p = [];
    const t3 = te(e), n2 = Zt(e);
    if (t3 !== null && n2 === null)
      t3.isKeyField() || e.p.push(new Qt(t3)), e.p.push(new Qt(J.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n3 of e.explicitOrderBy)
        e.p.push(n3), n3.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.p.push(new Qt(J.keyField(), t5));
      }
    }
  }
  return e.p;
}
function se(t2) {
  const e = $(t2);
  if (!e.T)
    if (e.limitType === "F")
      e.T = vt(e.path, e.collectionGroup, ne(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n3 of ne(e)) {
        const e2 = n3.dir === "desc" ? "asc" : "desc";
        t3.push(new Qt(n3.field, e2));
      }
      const n2 = e.endAt ? new Ut(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new Ut(e.startAt.position, !e.startAt.before) : null;
      e.T = vt(e.path, e.collectionGroup, t3, e.filters, e.limit, n2, s);
    }
  return e.T;
}
function ie(t2, e, n2) {
  return new zt(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n2, t2.startAt, t2.endAt);
}
function re(t2, e) {
  return Dt(se(t2), se(e)) && t2.limitType === e.limitType;
}
function oe(t2) {
  return `${Vt(se(t2))}|lt:${t2.limitType}`;
}
function ce(t2) {
  return `Query(target=${St(se(t2))}; limitType=${t2.limitType})`;
}
function ue(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n2 = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n2) : at.isDocumentKey(t3.path) ? t3.path.isEqual(n2) : t3.path.isImmediateParentOf(n2);
  }(t2, e) && function(t3, e2) {
    for (const n2 of t3.explicitOrderBy)
      if (!n2.field.isKeyField() && e2.data.field(n2.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n2 of t3.filters)
      if (!n2.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !Wt(t3.startAt, ne(t3), e2))
      return false;
    if (t3.endAt && Wt(t3.endAt, ne(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function ae(t2) {
  return (e, n2) => {
    let s = false;
    for (const i of ne(t2)) {
      const t3 = he(i, e, n2);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function he(t2, e, n2) {
  const s = t2.field.isKeyField() ? at.comparator(e.key, n2.key) : function(t3, e2, n3) {
    const s2 = e2.data.field(t3), i = n3.data.field(t3);
    return s2 !== null && i !== null ? dt(s2, i) : k();
  }(t2.field, e, n2);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return k();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function le(t2, e) {
  if (t2.I) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: ct(e) ? "-0" : e
  };
}
function fe(t2) {
  return {
    integerValue: "" + t2
  };
}
function de(t2, e) {
  return ut(e) ? fe(e) : le(t2, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class we {
  constructor() {
    this._ = void 0;
  }
}
function _e(t2, e, n2) {
  return t2 instanceof ye ? function(t3, e2) {
    const n3 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n3.fields.__previous_value__ = e2), {
      mapValue: n3
    };
  }(n2, e) : t2 instanceof pe ? Ee(t2, e) : t2 instanceof Te ? Ie(t2, e) : function(t3, e2) {
    const n3 = ge(t3, e2), s = Re(n3) + Re(t3.A);
    return yt(n3) && yt(t3.A) ? fe(s) : le(t3.R, s);
  }(t2, e);
}
function me(t2, e, n2) {
  return t2 instanceof pe ? Ee(t2, e) : t2 instanceof Te ? Ie(t2, e) : n2;
}
function ge(t2, e) {
  return t2 instanceof Ae ? yt(n2 = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n2) ? e : {
    integerValue: 0
  } : null;
  var n2;
}
class ye extends we {
}
class pe extends we {
  constructor(t2) {
    super(), this.elements = t2;
  }
}
function Ee(t2, e) {
  const n2 = Pe(e);
  for (const e2 of t2.elements)
    n2.some((t3) => lt(t3, e2)) || n2.push(e2);
  return {
    arrayValue: {
      values: n2
    }
  };
}
class Te extends we {
  constructor(t2) {
    super(), this.elements = t2;
  }
}
function Ie(t2, e) {
  let n2 = Pe(e);
  for (const e2 of t2.elements)
    n2 = n2.filter((t3) => !lt(t3, e2));
  return {
    arrayValue: {
      values: n2
    }
  };
}
class Ae extends we {
  constructor(t2, e) {
    super(), this.R = t2, this.A = e;
  }
}
function Re(t2) {
  return et(t2.integerValue || t2.doubleValue);
}
function Pe(t2) {
  return pt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class be {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
}
function ve(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof pe && e2 instanceof pe || t3 instanceof Te && e2 instanceof Te ? B(t3.elements, e2.elements, lt) : t3 instanceof Ae && e2 instanceof Ae ? lt(t3.A, e2.A) : t3 instanceof ye && e2 instanceof ye;
  }(t2.transform, e.transform);
}
class Ve {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
}
class Se {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new Se();
  }
  static exists(t2) {
    return new Se(void 0, t2);
  }
  static updateTime(t2) {
    return new Se(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
}
function De(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
class Ce {
}
function Ne(t2, e, n2) {
  t2 instanceof Me ? function(t3, e2, n3) {
    const s = t3.value.clone(), i = Be(t3.fieldTransforms, e2, n3.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n3.version, s).setHasCommittedMutations();
  }(t2, e, n2) : t2 instanceof Fe ? function(t3, e2, n3) {
    if (!De(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n3.version);
    const s = Be(t3.fieldTransforms, e2, n3.transformResults), i = e2.data;
    i.setAll(Le(t3)), i.setAll(s), e2.convertToFoundDocument(n3.version, i).setHasCommittedMutations();
  }(t2, e, n2) : function(t3, e2, n3) {
    e2.convertToNoDocument(n3.version).setHasCommittedMutations();
  }(0, e, n2);
}
function xe(t2, e, n2) {
  t2 instanceof Me ? function(t3, e2, n3) {
    if (!De(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = qe(t3.fieldTransforms, n3, e2);
    s.setAll(i), e2.convertToFoundDocument($e(e2), s).setHasLocalMutations();
  }(t2, e, n2) : t2 instanceof Fe ? function(t3, e2, n3) {
    if (!De(t3.precondition, e2))
      return;
    const s = qe(t3.fieldTransforms, n3, e2), i = e2.data;
    i.setAll(Le(t3)), i.setAll(s), e2.convertToFoundDocument($e(e2), i).setHasLocalMutations();
  }(t2, e, n2) : function(t3, e2) {
    De(t3.precondition, e2) && e2.convertToNoDocument(K.min());
  }(t2, e);
}
function ke(t2, e) {
  let n2 = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = ge(s.transform, t3 || null);
    i != null && (n2 == null && (n2 = At.empty()), n2.set(s.field, i));
  }
  return n2 || null;
}
function Oe(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && B(t3, e2, (t4, e3) => ve(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function $e(t2) {
  return t2.isFoundDocument() ? t2.version : K.min();
}
class Me extends Ce {
  constructor(t2, e, n2, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n2, this.fieldTransforms = s, this.type = 0;
  }
}
class Fe extends Ce {
  constructor(t2, e, n2, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n2, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
}
function Le(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n2) => {
    if (!n2.isEmpty()) {
      const s = t2.data.field(n2);
      e.set(n2, s);
    }
  }), e;
}
function Be(t2, e, n2) {
  const s = new Map();
  O(t2.length === n2.length);
  for (let i = 0; i < n2.length; i++) {
    const r2 = t2[i], o = r2.transform, c = e.data.field(r2.field);
    s.set(r2.field, me(o, c, n2[i]));
  }
  return s;
}
function qe(t2, e, n2) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r2 = n2.data.field(i.field);
    s.set(i.field, _e(t3, r2, e));
  }
  return s;
}
class Ue extends Ce {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
}
class Ke extends Ce {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qe {
  constructor(t2) {
    this.count = t2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var je, We;
function Ge(t2) {
  switch (t2) {
    case P.OK:
      return k();
    case P.CANCELLED:
    case P.UNKNOWN:
    case P.DEADLINE_EXCEEDED:
    case P.RESOURCE_EXHAUSTED:
    case P.INTERNAL:
    case P.UNAVAILABLE:
    case P.UNAUTHENTICATED:
      return false;
    case P.INVALID_ARGUMENT:
    case P.NOT_FOUND:
    case P.ALREADY_EXISTS:
    case P.PERMISSION_DENIED:
    case P.FAILED_PRECONDITION:
    case P.ABORTED:
    case P.OUT_OF_RANGE:
    case P.UNIMPLEMENTED:
    case P.DATA_LOSS:
      return true;
    default:
      return k();
  }
}
function ze(t2) {
  if (t2 === void 0)
    return C("GRPC error has no .code"), P.UNKNOWN;
  switch (t2) {
    case je.OK:
      return P.OK;
    case je.CANCELLED:
      return P.CANCELLED;
    case je.UNKNOWN:
      return P.UNKNOWN;
    case je.DEADLINE_EXCEEDED:
      return P.DEADLINE_EXCEEDED;
    case je.RESOURCE_EXHAUSTED:
      return P.RESOURCE_EXHAUSTED;
    case je.INTERNAL:
      return P.INTERNAL;
    case je.UNAVAILABLE:
      return P.UNAVAILABLE;
    case je.UNAUTHENTICATED:
      return P.UNAUTHENTICATED;
    case je.INVALID_ARGUMENT:
      return P.INVALID_ARGUMENT;
    case je.NOT_FOUND:
      return P.NOT_FOUND;
    case je.ALREADY_EXISTS:
      return P.ALREADY_EXISTS;
    case je.PERMISSION_DENIED:
      return P.PERMISSION_DENIED;
    case je.FAILED_PRECONDITION:
      return P.FAILED_PRECONDITION;
    case je.ABORTED:
      return P.ABORTED;
    case je.OUT_OF_RANGE:
      return P.OUT_OF_RANGE;
    case je.UNIMPLEMENTED:
      return P.UNIMPLEMENTED;
    case je.DATA_LOSS:
      return P.DATA_LOSS;
    default:
      return k();
  }
}
(We = je || (je = {}))[We.OK = 0] = "OK", We[We.CANCELLED = 1] = "CANCELLED", We[We.UNKNOWN = 2] = "UNKNOWN", We[We.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", We[We.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", We[We.NOT_FOUND = 5] = "NOT_FOUND", We[We.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", We[We.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", We[We.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", We[We.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", We[We.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", We[We.ABORTED = 10] = "ABORTED", We[We.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", We[We.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", We[We.INTERNAL = 13] = "INTERNAL", We[We.UNAVAILABLE = 14] = "UNAVAILABLE", We[We.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class He {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Ye.EMPTY;
  }
  insert(t2, e) {
    return new He(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Ye.BLACK, null, null));
  }
  remove(t2) {
    return new He(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Ye.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n2 = this.comparator(t2, e.key);
      if (n2 === 0)
        return e.value;
      n2 < 0 ? e = e.left : n2 > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n2 = this.root;
    for (; !n2.isEmpty(); ) {
      const s = this.comparator(t2, n2.key);
      if (s === 0)
        return e + n2.left.size;
      s < 0 ? n2 = n2.left : (e += n2.left.size + 1, n2 = n2.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n2) => (t2(e, n2), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n2) => (t2.push(`${e}:${n2}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new Je(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new Je(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new Je(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new Je(this.root, t2, this.comparator, true);
  }
}
class Je {
  constructor(t2, e, n2, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n2(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
}
class Ye {
  constructor(t2, e, n2, s, i) {
    this.key = t2, this.value = e, this.color = n2 != null ? n2 : Ye.RED, this.left = s != null ? s : Ye.EMPTY, this.right = i != null ? i : Ye.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n2, s, i) {
    return new Ye(t2 != null ? t2 : this.key, e != null ? e : this.value, n2 != null ? n2 : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n2) {
    let s = this;
    const i = n2(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n2), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n2)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Ye.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n2, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Ye.EMPTY;
        n2 = s.right.min(), s = s.copy(n2.key, n2.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Ye.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Ye.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw k();
    if (this.right.isRed())
      throw k();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw k();
    return t2 + (this.isRed() ? 0 : 1);
  }
}
Ye.EMPTY = null, Ye.RED = true, Ye.BLACK = false;
Ye.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw k();
  }
  get value() {
    throw k();
  }
  get color() {
    throw k();
  }
  get left() {
    throw k();
  }
  get right() {
    throw k();
  }
  copy(t2, e, n2, s, i) {
    return this;
  }
  insert(t2, e, n2) {
    return new Ye(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xe {
  constructor(t2) {
    this.comparator = t2, this.data = new He(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n2) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n2 = this.data.getIteratorFrom(t2[0]);
    for (; n2.hasNext(); ) {
      const s = n2.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n2;
    for (n2 = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n2.hasNext(); ) {
      if (!t2(n2.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Ze(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new Ze(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof Xe))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n2 = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n2.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new Xe(this.comparator);
    return e.data = t2, e;
  }
}
class Ze {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tn = new He(at.comparator);
function en() {
  return tn;
}
const nn = new He(at.comparator);
function sn() {
  return nn;
}
const rn = new He(at.comparator);
function on() {
  return rn;
}
const cn = new Xe(at.comparator);
function un(...t2) {
  let e = cn;
  for (const n2 of t2)
    e = e.add(n2);
  return e;
}
const an = new Xe(L);
function hn() {
  return an;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ln {
  constructor(t2, e, n2, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n2, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n2 = new Map();
    return n2.set(t2, fn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new ln(K.min(), n2, hn(), en(), un());
  }
}
class fn {
  constructor(t2, e, n2, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n2, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new fn(X.EMPTY_BYTE_STRING, e, un(), un(), un());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dn {
  constructor(t2, e, n2, s) {
    this.P = t2, this.removedTargetIds = e, this.key = n2, this.v = s;
  }
}
class wn {
  constructor(t2, e) {
    this.targetId = t2, this.V = e;
  }
}
class _n {
  constructor(t2, e, n2 = X.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n2, this.cause = s;
  }
}
class mn {
  constructor() {
    this.S = 0, this.D = pn(), this.C = X.EMPTY_BYTE_STRING, this.N = false, this.k = true;
  }
  get current() {
    return this.N;
  }
  get resumeToken() {
    return this.C;
  }
  get O() {
    return this.S !== 0;
  }
  get $() {
    return this.k;
  }
  M(t2) {
    t2.approximateByteSize() > 0 && (this.k = true, this.C = t2);
  }
  F() {
    let t2 = un(), e = un(), n2 = un();
    return this.D.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n2 = n2.add(s);
          break;
        default:
          k();
      }
    }), new fn(this.C, this.N, t2, e, n2);
  }
  L() {
    this.k = false, this.D = pn();
  }
  B(t2, e) {
    this.k = true, this.D = this.D.insert(t2, e);
  }
  q(t2) {
    this.k = true, this.D = this.D.remove(t2);
  }
  U() {
    this.S += 1;
  }
  K() {
    this.S -= 1;
  }
  j() {
    this.k = true, this.N = true;
  }
}
class gn {
  constructor(t2) {
    this.W = t2, this.G = new Map(), this.H = en(), this.J = yn(), this.Y = new Xe(L);
  }
  X(t2) {
    for (const e of t2.P)
      t2.v && t2.v.isFoundDocument() ? this.Z(e, t2.v) : this.tt(e, t2.key, t2.v);
    for (const e of t2.removedTargetIds)
      this.tt(e, t2.key, t2.v);
  }
  et(t2) {
    this.forEachTarget(t2, (e) => {
      const n2 = this.nt(e);
      switch (t2.state) {
        case 0:
          this.st(e) && n2.M(t2.resumeToken);
          break;
        case 1:
          n2.K(), n2.O || n2.L(), n2.M(t2.resumeToken);
          break;
        case 2:
          n2.K(), n2.O || this.removeTarget(e);
          break;
        case 3:
          this.st(e) && (n2.j(), n2.M(t2.resumeToken));
          break;
        case 4:
          this.st(e) && (this.it(e), n2.M(t2.resumeToken));
          break;
        default:
          k();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.G.forEach((t3, n2) => {
      this.st(n2) && e(n2);
    });
  }
  rt(t2) {
    const e = t2.targetId, n2 = t2.V.count, s = this.ot(e);
    if (s) {
      const t3 = s.target;
      if (Ct(t3))
        if (n2 === 0) {
          const n3 = new at(t3.path);
          this.tt(e, n3, Pt.newNoDocument(n3, K.min()));
        } else
          O(n2 === 1);
      else {
        this.ct(e) !== n2 && (this.it(e), this.Y = this.Y.add(e));
      }
    }
  }
  ut(t2) {
    const e = new Map();
    this.G.forEach((n3, s2) => {
      const i = this.ot(s2);
      if (i) {
        if (n3.current && Ct(i.target)) {
          const e2 = new at(i.target.path);
          this.H.get(e2) !== null || this.at(s2, e2) || this.tt(s2, e2, Pt.newNoDocument(e2, t2));
        }
        n3.$ && (e.set(s2, n3.F()), n3.L());
      }
    });
    let n2 = un();
    this.J.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.ot(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n2 = n2.add(t3));
    });
    const s = new ln(t2, e, this.Y, this.H, n2);
    return this.H = en(), this.J = yn(), this.Y = new Xe(L), s;
  }
  Z(t2, e) {
    if (!this.st(t2))
      return;
    const n2 = this.at(t2, e.key) ? 2 : 0;
    this.nt(t2).B(e.key, n2), this.H = this.H.insert(e.key, e), this.J = this.J.insert(e.key, this.ht(e.key).add(t2));
  }
  tt(t2, e, n2) {
    if (!this.st(t2))
      return;
    const s = this.nt(t2);
    this.at(t2, e) ? s.B(e, 1) : s.q(e), this.J = this.J.insert(e, this.ht(e).delete(t2)), n2 && (this.H = this.H.insert(e, n2));
  }
  removeTarget(t2) {
    this.G.delete(t2);
  }
  ct(t2) {
    const e = this.nt(t2).F();
    return this.W.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  U(t2) {
    this.nt(t2).U();
  }
  nt(t2) {
    let e = this.G.get(t2);
    return e || (e = new mn(), this.G.set(t2, e)), e;
  }
  ht(t2) {
    let e = this.J.get(t2);
    return e || (e = new Xe(L), this.J = this.J.insert(t2, e)), e;
  }
  st(t2) {
    const e = this.ot(t2) !== null;
    return e || D("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  ot(t2) {
    const e = this.G.get(t2);
    return e && e.O ? null : this.W.lt(t2);
  }
  it(t2) {
    this.G.set(t2, new mn());
    this.W.getRemoteKeysForTarget(t2).forEach((e) => {
      this.tt(t2, e, null);
    });
  }
  at(t2, e) {
    return this.W.getRemoteKeysForTarget(t2).has(e);
  }
}
function yn() {
  return new He(at.comparator);
}
function pn() {
  return new He(at.comparator);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const En = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})(), Tn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
class In {
  constructor(t2, e) {
    this.databaseId = t2, this.I = e;
  }
}
function An(t2, e) {
  if (t2.I) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Rn(t2, e) {
  return t2.I ? e.toBase64() : e.toUint8Array();
}
function Pn(t2, e) {
  return An(t2, e.toTimestamp());
}
function bn(t2) {
  return O(!!t2), K.fromTimestamp(function(t3) {
    const e = tt(t3);
    return new U(e.seconds, e.nanos);
  }(t2));
}
function vn(t2, e) {
  return function(t3) {
    return new z(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Vn(t2) {
  const e = z.fromString(t2);
  return O(ns(e)), e;
}
function Sn(t2, e) {
  return vn(t2.databaseId, e.path);
}
function Dn(t2, e) {
  const n2 = Vn(e);
  if (n2.get(1) !== t2.databaseId.projectId)
    throw new b(P.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n2.get(1) + " vs " + t2.databaseId.projectId);
  if (n2.get(3) !== t2.databaseId.database)
    throw new b(P.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n2.get(3) + " vs " + t2.databaseId.database);
  return new at(kn(n2));
}
function Cn(t2, e) {
  return vn(t2.databaseId, e);
}
function Nn(t2) {
  const e = Vn(t2);
  return e.length === 4 ? z.emptyPath() : kn(e);
}
function xn(t2) {
  return new z(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function kn(t2) {
  return O(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function On(t2, e, n2) {
  return {
    name: Sn(t2, e),
    fields: n2.toProto().mapValue.fields
  };
}
function $n(t2, e, n2) {
  const s = Dn(t2, e.name), i = bn(e.updateTime), r2 = new At({
    mapValue: {
      fields: e.fields
    }
  }), o = Pt.newFoundDocument(s, i, r2);
  return n2 && o.setHasCommittedMutations(), n2 ? o.setHasCommittedMutations() : o;
}
function Mn(t2, e) {
  return "found" in e ? function(t3, e2) {
    O(!!e2.found), e2.found.name, e2.found.updateTime;
    const n2 = Dn(t3, e2.found.name), s = bn(e2.found.updateTime), i = new At({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Pt.newFoundDocument(n2, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    O(!!e2.missing), O(!!e2.readTime);
    const n2 = Dn(t3, e2.missing), s = bn(e2.readTime);
    return Pt.newNoDocument(n2, s);
  }(t2, e) : k();
}
function Fn(t2, e) {
  let n2;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : k();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r2 = function(t3, e2) {
      return t3.I ? (O(e2 === void 0 || typeof e2 == "string"), X.fromBase64String(e2 || "")) : (O(e2 === void 0 || e2 instanceof Uint8Array), X.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, c = o && function(t3) {
      const e2 = t3.code === void 0 ? P.UNKNOWN : ze(t3.code);
      return new b(e2, t3.message || "");
    }(o);
    n2 = new _n(s, i, r2, c || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Dn(t2, s.document.name), r2 = bn(s.document.updateTime), o = new At({
      mapValue: {
        fields: s.document.fields
      }
    }), c = Pt.newFoundDocument(i, r2, o), u = s.targetIds || [], a = s.removedTargetIds || [];
    n2 = new dn(u, a, c.key, c);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Dn(t2, s.document), r2 = s.readTime ? bn(s.readTime) : K.min(), o = Pt.newNoDocument(i, r2), c = s.removedTargetIds || [];
    n2 = new dn([], c, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Dn(t2, s.document), r2 = s.removedTargetIds || [];
    n2 = new dn([], r2, i, null);
  } else {
    if (!("filter" in e))
      return k();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new Qe(s), r2 = t3.targetId;
      n2 = new wn(r2, i);
    }
  }
  return n2;
}
function Ln(t2, e) {
  let n2;
  if (e instanceof Me)
    n2 = {
      update: On(t2, e.key, e.value)
    };
  else if (e instanceof Ue)
    n2 = {
      delete: Sn(t2, e.key)
    };
  else if (e instanceof Fe)
    n2 = {
      update: On(t2, e.key, e.data),
      updateMask: es(e.fieldMask)
    };
  else {
    if (!(e instanceof Ke))
      return k();
    n2 = {
      verify: Sn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n2.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n3 = e2.transform;
    if (n3 instanceof ye)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n3 instanceof pe)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n3.elements
        }
      };
    if (n3 instanceof Te)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n3.elements
        }
      };
    if (n3 instanceof Ae)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n3.A
      };
    throw k();
  }(0, t3))), e.precondition.isNone || (n2.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Pn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : k();
  }(t2, e.precondition)), n2;
}
function Bn(t2, e) {
  const n2 = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? Se.updateTime(bn(t3.updateTime)) : t3.exists !== void 0 ? Se.exists(t3.exists) : Se.none();
  }(e.currentDocument) : Se.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n3 = null;
    if ("setToServerValue" in e3)
      O(e3.setToServerValue === "REQUEST_TIME"), n3 = new ye();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n3 = new pe(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n3 = new Te(t4);
    } else
      "increment" in e3 ? n3 = new Ae(t3, e3.increment) : k();
    const s2 = J.fromServerFormat(e3.fieldPath);
    return new be(s2, n3);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Dn(t2, e.update.name), r2 = new At({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new Y(e2.map((t5) => J.fromServerFormat(t5)));
      }(e.updateMask);
      return new Fe(i, r2, t3, n2, s);
    }
    return new Me(i, r2, n2, s);
  }
  if (e.delete) {
    const s2 = Dn(t2, e.delete);
    return new Ue(s2, n2);
  }
  if (e.verify) {
    const s2 = Dn(t2, e.verify);
    return new Ke(s2, n2);
  }
  return k();
}
function qn(t2, e) {
  return t2 && t2.length > 0 ? (O(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n2 = t4.updateTime ? bn(t4.updateTime) : bn(e2);
    return n2.isEqual(K.min()) && (n2 = bn(e2)), new Ve(n2, t4.transformResults || []);
  }(t3, e))) : [];
}
function Un(t2, e) {
  return {
    documents: [Cn(t2, e.path)]
  };
}
function Kn(t2, e) {
  const n2 = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n2.parent = Cn(t2, s), n2.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n2.parent = Cn(t2, s.popLast()), n2.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Tt(t5.value))
          return {
            unaryFilter: {
              field: Yn(t5.field),
              op: "IS_NAN"
            }
          };
        if (Et(t5.value))
          return {
            unaryFilter: {
              field: Yn(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Tt(t5.value))
          return {
            unaryFilter: {
              field: Yn(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Et(t5.value))
          return {
            unaryFilter: {
              field: Yn(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Yn(t5.field),
          op: Jn(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n2.structuredQuery.where = i);
  const r2 = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Yn(t5.field),
        direction: Hn(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r2 && (n2.structuredQuery.orderBy = r2);
  const o = function(t3, e2) {
    return t3.I || ot(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n2.structuredQuery.limit = o), e.startAt && (n2.structuredQuery.startAt = Gn(e.startAt)), e.endAt && (n2.structuredQuery.endAt = Gn(e.endAt)), n2;
}
function Qn(t2) {
  let e = Nn(t2.parent);
  const n2 = t2.structuredQuery, s = n2.from ? n2.from.length : 0;
  let i = null;
  if (s > 0) {
    O(s === 1);
    const t3 = n2.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r2 = [];
  n2.where && (r2 = Wn(n2.where));
  let o = [];
  n2.orderBy && (o = n2.orderBy.map((t3) => function(t4) {
    return new Qt(Xn(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let c = null;
  n2.limit && (c = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, ot(e2) ? null : e2;
  }(n2.limit));
  let u = null;
  n2.startAt && (u = zn(n2.startAt));
  let a = null;
  return n2.endAt && (a = zn(n2.endAt)), Ht(e, i, o, r2, c, "F", u, a);
}
function jn(t2, e) {
  const n2 = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return k();
    }
  }(0, e.purpose);
  return n2 == null ? null : {
    "goog-listen-tags": n2
  };
}
function Wn(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [ts(t2)] : t2.fieldFilter !== void 0 ? [Zn(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => Wn(t3)).reduce((t3, e) => t3.concat(e)) : k() : [];
}
function Gn(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function zn(t2) {
  const e = !!t2.before, n2 = t2.values || [];
  return new Ut(n2, e);
}
function Hn(t2) {
  return En[t2];
}
function Jn(t2) {
  return Tn[t2];
}
function Yn(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function Xn(t2) {
  return J.fromServerFormat(t2.fieldPath);
}
function Zn(t2) {
  return Nt.create(Xn(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
      default:
        return k();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ts(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = Xn(t2.unaryFilter.field);
      return Nt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n2 = Xn(t2.unaryFilter.field);
      return Nt.create(n2, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = Xn(t2.unaryFilter.field);
      return Nt.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = Xn(t2.unaryFilter.field);
      return Nt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    case "OPERATOR_UNSPECIFIED":
    default:
      return k();
  }
}
function es(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function ns(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ss(t2) {
  let e = "";
  for (let n2 = 0; n2 < t2.length; n2++)
    e.length > 0 && (e = rs(e)), e = is(t2.get(n2), e);
  return rs(e);
}
function is(t2, e) {
  let n2 = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n2 += "";
        break;
      case "":
        n2 += "";
        break;
      default:
        n2 += s2;
    }
  }
  return n2;
}
function rs(t2) {
  return t2 + "";
}
function os(t2) {
  const e = t2.length;
  if (O(e >= 2), e === 2)
    return O(t2.charAt(0) === "" && t2.charAt(1) === ""), z.emptyPath();
  const n2 = e - 2, s = [];
  let i = "";
  for (let r2 = 0; r2 < e; ) {
    const e2 = t2.indexOf("", r2);
    (e2 < 0 || e2 > n2) && k();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n3 = t2.substring(r2, e2);
        let o;
        i.length === 0 ? o = n3 : (i += n3, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r2, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r2, e2 + 1);
        break;
      default:
        k();
    }
    r2 = e2 + 2;
  }
  return new z(s);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cs {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
}
class us {
  constructor(t2, e, n2) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n2;
  }
}
us.store = "owner", us.key = "owner";
class as {
  constructor(t2, e, n2) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n2;
  }
}
as.store = "mutationQueues", as.keyPath = "userId";
class hs {
  constructor(t2, e, n2, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n2, this.baseMutations = s, this.mutations = i;
  }
}
hs.store = "mutations", hs.keyPath = "batchId", hs.userMutationsIndex = "userMutationsIndex", hs.userMutationsKeyPath = ["userId", "batchId"];
class ls {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, ss(e)];
  }
  static key(t2, e, n2) {
    return [t2, ss(e), n2];
  }
}
ls.store = "documentMutations", ls.PLACEHOLDER = new ls();
class fs {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
}
class ds {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
}
class ws {
  constructor(t2, e, n2, s, i, r2) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n2, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r2;
  }
}
ws.store = "remoteDocuments", ws.readTimeIndex = "readTimeIndex", ws.readTimeIndexPath = "readTime", ws.collectionReadTimeIndex = "collectionReadTimeIndex", ws.collectionReadTimeIndexPath = ["parentPath", "readTime"];
class _s {
  constructor(t2) {
    this.byteSize = t2;
  }
}
_s.store = "remoteDocumentGlobal", _s.key = "remoteDocumentGlobalKey";
class ms {
  constructor(t2, e, n2, s, i, r2, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n2, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r2, this.query = o;
  }
}
ms.store = "targets", ms.keyPath = "targetId", ms.queryTargetsIndexName = "queryTargetsIndex", ms.queryTargetsKeyPath = ["canonicalId", "targetId"];
class gs {
  constructor(t2, e, n2) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n2;
  }
}
gs.store = "targetDocuments", gs.keyPath = ["targetId", "path"], gs.documentTargetsIndex = "documentTargetsIndex", gs.documentTargetsKeyPath = ["path", "targetId"];
class ys {
  constructor(t2, e, n2, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n2, this.targetCount = s;
  }
}
ys.key = "targetGlobalKey", ys.store = "targetGlobal";
class ps {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
}
ps.store = "collectionParents", ps.keyPath = ["collectionId", "parent"];
class Es {
  constructor(t2, e, n2, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n2, this.inForeground = s;
  }
}
Es.store = "clientMetadata", Es.keyPath = "clientId";
class Ts {
  constructor(t2, e, n2) {
    this.bundleId = t2, this.createTime = e, this.version = n2;
  }
}
Ts.store = "bundles", Ts.keyPath = "bundleId";
class Is {
  constructor(t2, e, n2) {
    this.name = t2, this.readTime = e, this.bundledQuery = n2;
  }
}
Is.store = "namedQueries", Is.keyPath = "name";
const As = [...[...[...[...[as.store, hs.store, ls.store, ws.store, ms.store, us.store, ys.store, gs.store], Es.store], _s.store], ps.store], Ts.store, Is.store], Rs = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class Ps {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bs {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vs {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && k(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new vs((n2, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n2, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n2, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof vs ? e : vs.resolve(e);
    } catch (t3) {
      return vs.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : vs.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : vs.reject(e);
  }
  static resolve(t2) {
    return new vs((e, n2) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new vs((e, n2) => {
      n2(t2);
    });
  }
  static waitFor(t2) {
    return new vs((e, n2) => {
      let s = 0, i = 0, r2 = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r2 && i === s && e();
        }, (t4) => n2(t4));
      }), r2 = true, i === s && e();
    });
  }
  static or(t2) {
    let e = vs.resolve(false);
    for (const n2 of t2)
      e = e.next((t3) => t3 ? vs.resolve(t3) : n2());
    return e;
  }
  static forEach(t2, e) {
    const n2 = [];
    return t2.forEach((t3, s) => {
      n2.push(e.call(this, t3, s));
    }), this.waitFor(n2);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vs {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.ft = new bs(), this.transaction.oncomplete = () => {
      this.ft.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.ft.reject(new Cs(t2, e.error)) : this.ft.resolve();
    }, this.transaction.onerror = (e2) => {
      const n2 = $s(e2.target.error);
      this.ft.reject(new Cs(t2, n2));
    };
  }
  static open(t2, e, n2, s) {
    try {
      return new Vs(e, t2.transaction(s, n2));
    } catch (t3) {
      throw new Cs(e, t3);
    }
  }
  get dt() {
    return this.ft.promise;
  }
  abort(t2) {
    t2 && this.ft.reject(t2), this.aborted || (D("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new xs(e);
  }
}
class Ss {
  constructor(t2, e, n2) {
    this.name = t2, this.version = e, this.wt = n2;
    Ss._t(getUA()) === 12.2 && C("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return D("SimpleDb", "Removing database:", t2), ks(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static gt() {
    if (typeof indexedDB == "undefined")
      return false;
    if (Ss.yt())
      return true;
    const t2 = getUA(), e = Ss._t(t2), n2 = 0 < e && e < 10, s = Ss.Et(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n2 || i);
  }
  static yt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Tt) === "YES";
  }
  static It(t2, e) {
    return t2.store(e);
  }
  static _t(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n2 = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n2);
  }
  static Et(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n2 = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n2);
  }
  async At(t2) {
    return this.db || (D("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n2) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n3 = t3.target.result;
        e(n3);
      }, s.onblocked = () => {
        n2(new Cs(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n2(new b(P.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : n2(new Cs(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        D("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.wt.Rt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          D("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Pt && (this.db.onversionchange = (t3) => this.Pt(t3)), this.db;
  }
  bt(t2) {
    this.Pt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n2, s) {
    const i = e === "readonly";
    let r2 = 0;
    for (; ; ) {
      ++r2;
      try {
        this.db = await this.At(t2);
        const e2 = Vs.open(this.db, t2, i ? "readonly" : "readwrite", n2), r3 = s(e2).catch((t3) => (e2.abort(t3), vs.reject(t3))).toPromise();
        return r3.catch(() => {
        }), await e2.dt, r3;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r2 < 3;
        if (D("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
}
class Ds {
  constructor(t2) {
    this.vt = t2, this.Vt = false, this.St = null;
  }
  get isDone() {
    return this.Vt;
  }
  get Dt() {
    return this.St;
  }
  set cursor(t2) {
    this.vt = t2;
  }
  done() {
    this.Vt = true;
  }
  Ct(t2) {
    this.St = t2;
  }
  delete() {
    return ks(this.vt.delete());
  }
}
class Cs extends b {
  constructor(t2, e) {
    super(P.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
}
function Ns(t2) {
  return t2.name === "IndexedDbTransactionError";
}
class xs {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n2;
    return e !== void 0 ? (D("SimpleDb", "PUT", this.store.name, t2, e), n2 = this.store.put(e, t2)) : (D("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n2 = this.store.put(t2)), ks(n2);
  }
  add(t2) {
    D("SimpleDb", "ADD", this.store.name, t2, t2);
    return ks(this.store.add(t2));
  }
  get(t2) {
    return ks(this.store.get(t2)).next((e) => (e === void 0 && (e = null), D("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    D("SimpleDb", "DELETE", this.store.name, t2);
    return ks(this.store.delete(t2));
  }
  count() {
    D("SimpleDb", "COUNT", this.store.name);
    return ks(this.store.count());
  }
  Nt(t2, e) {
    const n2 = this.cursor(this.options(t2, e)), s = [];
    return this.xt(n2, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  kt(t2, e) {
    D("SimpleDb", "DELETE ALL", this.store.name);
    const n2 = this.options(t2, e);
    n2.Ot = false;
    const s = this.cursor(n2);
    return this.xt(s, (t3, e2, n3) => n3.delete());
  }
  $t(t2, e) {
    let n2;
    e ? n2 = t2 : (n2 = {}, e = t2);
    const s = this.cursor(n2);
    return this.xt(s, e);
  }
  Mt(t2) {
    const e = this.cursor({});
    return new vs((n2, s) => {
      e.onerror = (t3) => {
        const e2 = $s(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n2();
        }) : n2();
      };
    });
  }
  xt(t2, e) {
    const n2 = [];
    return new vs((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r2 = new Ds(i2), o = e(i2.primaryKey, i2.value, r2);
        if (o instanceof vs) {
          const t4 = o.catch((t5) => (r2.done(), vs.reject(t5)));
          n2.push(t4);
        }
        r2.isDone ? s() : r2.Dt === null ? i2.continue() : i2.continue(r2.Dt);
      };
    }).next(() => vs.waitFor(n2));
  }
  options(t2, e) {
    let n2;
    return t2 !== void 0 && (typeof t2 == "string" ? n2 = t2 : e = t2), {
      index: n2,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n2 = this.store.index(t2.index);
      return t2.Ot ? n2.openKeyCursor(t2.range, e) : n2.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
}
function ks(t2) {
  return new vs((e, n2) => {
    t2.onsuccess = (t3) => {
      const n3 = t3.target.result;
      e(n3);
    }, t2.onerror = (t3) => {
      const e2 = $s(t3.target.error);
      n2(e2);
    };
  });
}
let Os = false;
function $s(t2) {
  const e = Ss._t(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new b("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Os || (Os = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ms extends Ps {
  constructor(t2, e) {
    super(), this.Ft = t2, this.currentSequenceNumber = e;
  }
}
function Fs(t2, e) {
  const n2 = $(t2);
  return Ss.It(n2.Ft, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ls {
  constructor(t2, e, n2, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n2, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n2 = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        Ne(s, t2, n2[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && xe(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && xe(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n2 = t2.get(e.key), s = n2;
      this.applyToLocalView(s), n2.isValidDocument() || s.convertToNoDocument(K.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), un());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && B(this.mutations, t2.mutations, (t3, e) => Oe(t3, e)) && B(this.baseMutations, t2.baseMutations, (t3, e) => Oe(t3, e));
  }
}
class Bs {
  constructor(t2, e, n2, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n2, this.docVersions = s;
  }
  static from(t2, e, n2) {
    O(t2.mutations.length === n2.length);
    let s = on();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n2[t3].version);
    return new Bs(t2, e, n2, s);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qs {
  constructor(t2, e, n2, s, i = K.min(), r2 = K.min(), o = X.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n2, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r2, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new qs(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new qs(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new qs(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Us {
  constructor(t2) {
    this.Lt = t2;
  }
}
function Ks(t2, e) {
  if (e.document)
    return $n(t2.Lt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = at.fromSegments(e.noDocument.path), n2 = zs(e.noDocument.readTime), s = Pt.newNoDocument(t3, n2);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = at.fromSegments(e.unknownDocument.path), n2 = zs(e.unknownDocument.version);
    return Pt.newUnknownDocument(t3, n2);
  }
  return k();
}
function Qs(t2, e, n2) {
  const s = js(n2), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n3 = function(t3, e2) {
      return {
        name: Sn(t3, e2.key),
        fields: e2.data.toProto().mapValue.fields,
        updateTime: An(t3, e2.version.toTimestamp())
      };
    }(t2.Lt, e), r2 = e.hasCommittedMutations;
    return new ws(null, null, n3, r2, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n3 = Gs(e.version), r2 = e.hasCommittedMutations;
    return new ws(null, new fs(t3, n3), null, r2, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n3 = Gs(e.version);
    return new ws(new ds(t3, n3), null, null, true, s, i);
  }
  return k();
}
function js(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Ws(t2) {
  const e = new U(t2[0], t2[1]);
  return K.fromTimestamp(e);
}
function Gs(t2) {
  const e = t2.toTimestamp();
  return new cs(e.seconds, e.nanoseconds);
}
function zs(t2) {
  const e = new U(t2.seconds, t2.nanoseconds);
  return K.fromTimestamp(e);
}
function Hs(t2, e) {
  const n2 = (e.baseMutations || []).map((e2) => Bn(t2.Lt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n3 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n3.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Bn(t2.Lt, e2)), i = U.fromMillis(e.localWriteTimeMs);
  return new Ls(e.batchId, i, n2, s);
}
function Js(t2) {
  const e = zs(t2.readTime), n2 = t2.lastLimboFreeSnapshotVersion !== void 0 ? zs(t2.lastLimboFreeSnapshotVersion) : K.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (O((i = t2.query).documents.length === 1), s = se(Jt(Nn(i.documents[0])))) : s = function(t3) {
    return se(Qn(t3));
  }(t2.query), new qs(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n2, X.fromBase64String(t2.resumeToken));
}
function Ys(t2, e) {
  const n2 = Gs(e.snapshotVersion), s = Gs(e.lastLimboFreeSnapshotVersion);
  let i;
  i = Ct(e.target) ? Un(t2.Lt, e.target) : Kn(t2.Lt, e.target);
  const r2 = e.resumeToken.toBase64();
  return new ms(e.targetId, Vt(e.target), n2, r2, e.sequenceNumber, s, i);
}
function Xs(t2) {
  const e = Qn({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? ie(e, e.limit, "L") : e;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zs {
  getBundleMetadata(t2, e) {
    return ti(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: zs(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return ti(t2).put({
      bundleId: (n2 = e).id,
      createTime: Gs(bn(n2.createTime)),
      version: n2.version
    });
    var n2;
  }
  getNamedQuery(t2, e) {
    return ei(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: Xs(e2.bundledQuery),
          readTime: zs(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return ei(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Gs(bn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
}
function ti(t2) {
  return Fs(t2, Ts.store);
}
function ei(t2) {
  return Fs(t2, Is.store);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ni {
  constructor() {
    this.Bt = new si();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Bt.add(e), vs.resolve();
  }
  getCollectionParents(t2, e) {
    return vs.resolve(this.Bt.getEntries(e));
  }
}
class si {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n2 = t2.popLast(), s = this.index[e] || new Xe(z.comparator), i = !s.has(n2);
    return this.index[e] = s.add(n2), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n2 = t2.popLast(), s = this.index[e];
    return s && s.has(n2);
  }
  getEntries(t2) {
    return (this.index[t2] || new Xe(z.comparator)).toArray();
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ii {
  constructor() {
    this.qt = new si();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.qt.has(e)) {
      const n2 = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.qt.add(e);
      });
      const i = {
        collectionId: n2,
        parent: ss(s)
      };
      return ri(t2).put(i);
    }
    return vs.resolve();
  }
  getCollectionParents(t2, e) {
    const n2 = [], s = IDBKeyRange.bound([e, ""], [q(e), ""], false, true);
    return ri(t2).Nt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n2.push(os(s2.parent));
      }
      return n2;
    });
  }
}
function ri(t2) {
  return Fs(t2, ps.store);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oi = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
class ci {
  constructor(t2, e, n2) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n2;
  }
  static withCacheSize(t2) {
    return new ci(t2, ci.DEFAULT_COLLECTION_PERCENTILE, ci.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ui(t2, e, n2) {
  const s = t2.store(hs.store), i = t2.store(ls.store), r2 = [], o = IDBKeyRange.only(n2.batchId);
  let c = 0;
  const u = s.$t({
    range: o
  }, (t3, e2, n3) => (c++, n3.delete()));
  r2.push(u.next(() => {
    O(c === 1);
  }));
  const a = [];
  for (const t3 of n2.mutations) {
    const s2 = ls.key(e, t3.key.path, n2.batchId);
    r2.push(i.delete(s2)), a.push(t3.key);
  }
  return vs.waitFor(r2).next(() => a);
}
function ai(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw k();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ci.DEFAULT_COLLECTION_PERCENTILE = 10, ci.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, ci.DEFAULT = new ci(41943040, ci.DEFAULT_COLLECTION_PERCENTILE, ci.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), ci.DISABLED = new ci(-1, 0, 0);
class hi {
  constructor(t2, e, n2, s) {
    this.userId = t2, this.R = e, this.Ut = n2, this.referenceDelegate = s, this.Kt = {};
  }
  static Qt(t2, e, n2, s) {
    O(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new hi(i, e, n2, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n2 = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return fi(t2).$t({
      index: hs.userMutationsIndex,
      range: n2
    }, (t3, n3, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n2, s) {
    const i = di(t2), r2 = fi(t2);
    return r2.add({}).next((o) => {
      O(typeof o == "number");
      const c = new Ls(o, e, n2, s), u = function(t3, e2, n3) {
        const s2 = n3.baseMutations.map((e3) => Ln(t3.Lt, e3)), i2 = n3.mutations.map((e3) => Ln(t3.Lt, e3));
        return new hs(e2, n3.batchId, n3.localWriteTime.toMillis(), s2, i2);
      }(this.R, this.userId, c), a = [];
      let h2 = new Xe((t3, e2) => L(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = ls.key(this.userId, t3.key.path, o);
        h2 = h2.add(t3.key.path.popLast()), a.push(r2.put(u)), a.push(i.put(e2, ls.PLACEHOLDER));
      }
      return h2.forEach((e2) => {
        a.push(this.Ut.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Kt[o] = c.keys();
      }), vs.waitFor(a).next(() => c);
    });
  }
  lookupMutationBatch(t2, e) {
    return fi(t2).get(e).next((t3) => t3 ? (O(t3.userId === this.userId), Hs(this.R, t3)) : null);
  }
  jt(t2, e) {
    return this.Kt[e] ? vs.resolve(this.Kt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n2 = t3.keys();
        return this.Kt[e] = n2, n2;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n2 = e + 1, s = IDBKeyRange.lowerBound([this.userId, n2]);
    let i = null;
    return fi(t2).$t({
      index: hs.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (O(e2.batchId >= n2), i = Hs(this.R, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n2 = -1;
    return fi(t2).$t({
      index: hs.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n2 = e2.batchId, s.done();
    }).next(() => n2);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return fi(t2).Nt(hs.userMutationsIndex, e).next((t3) => t3.map((t4) => Hs(this.R, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n2 = ls.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n2), i = [];
    return di(t2).$t({
      range: s
    }, (n3, s2, r2) => {
      const [o, c, u] = n3, a = os(c);
      if (o === this.userId && e.path.isEqual(a))
        return fi(t2).get(u).next((t3) => {
          if (!t3)
            throw k();
          O(t3.userId === this.userId), i.push(Hs(this.R, t3));
        });
      r2.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n2 = new Xe(L);
    const s = [];
    return e.forEach((e2) => {
      const i = ls.prefixForPath(this.userId, e2.path), r2 = IDBKeyRange.lowerBound(i), o = di(t2).$t({
        range: r2
      }, (t3, s2, i2) => {
        const [r3, o2, c] = t3, u = os(o2);
        r3 === this.userId && e2.path.isEqual(u) ? n2 = n2.add(c) : i2.done();
      });
      s.push(o);
    }), vs.waitFor(s).next(() => this.Wt(t2, n2));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n2 = e.path, s = n2.length + 1, i = ls.prefixForPath(this.userId, n2), r2 = IDBKeyRange.lowerBound(i);
    let o = new Xe(L);
    return di(t2).$t({
      range: r2
    }, (t3, e2, i2) => {
      const [r3, c, u] = t3, a = os(c);
      r3 === this.userId && n2.isPrefixOf(a) ? a.length === s && (o = o.add(u)) : i2.done();
    }).next(() => this.Wt(t2, o));
  }
  Wt(t2, e) {
    const n2 = [], s = [];
    return e.forEach((e2) => {
      s.push(fi(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw k();
        O(t3.userId === this.userId), n2.push(Hs(this.R, t3));
      }));
    }), vs.waitFor(s).next(() => n2);
  }
  removeMutationBatch(t2, e) {
    return ui(t2.Ft, this.userId, e).next((n2) => (t2.addOnCommittedListener(() => {
      this.Gt(e.batchId);
    }), vs.forEach(n2, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  Gt(t2) {
    delete this.Kt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return vs.resolve();
      const n2 = IDBKeyRange.lowerBound(ls.prefixForUser(this.userId)), s = [];
      return di(t2).$t({
        range: n2
      }, (t3, e2, n3) => {
        if (t3[0] === this.userId) {
          const e3 = os(t3[1]);
          s.push(e3);
        } else
          n3.done();
      }).next(() => {
        O(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return li(t2, this.userId, e);
  }
  zt(t2) {
    return wi(t2).get(this.userId).next((t3) => t3 || new as(this.userId, -1, ""));
  }
}
function li(t2, e, n2) {
  const s = ls.prefixForPath(e, n2.path), i = s[1], r2 = IDBKeyRange.lowerBound(s);
  let o = false;
  return di(t2).$t({
    range: r2,
    Ot: true
  }, (t3, n3, s2) => {
    const [r3, c, u] = t3;
    r3 === e && c === i && (o = true), s2.done();
  }).next(() => o);
}
function fi(t2) {
  return Fs(t2, hs.store);
}
function di(t2) {
  return Fs(t2, ls.store);
}
function wi(t2) {
  return Fs(t2, as.store);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _i {
  constructor(t2) {
    this.Ht = t2;
  }
  next() {
    return this.Ht += 2, this.Ht;
  }
  static Jt() {
    return new _i(0);
  }
  static Yt() {
    return new _i(-1);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mi {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.R = e;
  }
  allocateTargetId(t2) {
    return this.Xt(t2).next((e) => {
      const n2 = new _i(e.highestTargetId);
      return e.highestTargetId = n2.next(), this.Zt(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.Xt(t2).next((t3) => K.fromTimestamp(new U(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.Xt(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n2) {
    return this.Xt(t2).next((s) => (s.highestListenSequenceNumber = e, n2 && (s.lastRemoteSnapshotVersion = n2.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Zt(t2, s)));
  }
  addTargetData(t2, e) {
    return this.te(t2, e).next(() => this.Xt(t2).next((n2) => (n2.targetCount += 1, this.ee(e, n2), this.Zt(t2, n2))));
  }
  updateTargetData(t2, e) {
    return this.te(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => gi(t2).delete(e.targetId)).next(() => this.Xt(t2)).next((e2) => (O(e2.targetCount > 0), e2.targetCount -= 1, this.Zt(t2, e2)));
  }
  removeTargets(t2, e, n2) {
    let s = 0;
    const i = [];
    return gi(t2).$t((r2, o) => {
      const c = Js(o);
      c.sequenceNumber <= e && n2.get(c.targetId) === null && (s++, i.push(this.removeTargetData(t2, c)));
    }).next(() => vs.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return gi(t2).$t((t3, n2) => {
      const s = Js(n2);
      e(s);
    });
  }
  Xt(t2) {
    return yi(t2).get(ys.key).next((t3) => (O(t3 !== null), t3));
  }
  Zt(t2, e) {
    return yi(t2).put(ys.key, e);
  }
  te(t2, e) {
    return gi(t2).put(Ys(this.R, e));
  }
  ee(t2, e) {
    let n2 = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n2 = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n2 = true), n2;
  }
  getTargetCount(t2) {
    return this.Xt(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n2 = Vt(e), s = IDBKeyRange.bound([n2, Number.NEGATIVE_INFINITY], [n2, Number.POSITIVE_INFINITY]);
    let i = null;
    return gi(t2).$t({
      range: s,
      index: ms.queryTargetsIndexName
    }, (t3, n3, s2) => {
      const r2 = Js(n3);
      Dt(e, r2.target) && (i = r2, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n2) {
    const s = [], i = pi(t2);
    return e.forEach((e2) => {
      const r2 = ss(e2.path);
      s.push(i.put(new gs(n2, r2))), s.push(this.referenceDelegate.addReference(t2, n2, e2));
    }), vs.waitFor(s);
  }
  removeMatchingKeys(t2, e, n2) {
    const s = pi(t2);
    return vs.forEach(e, (e2) => {
      const i = ss(e2.path);
      return vs.waitFor([s.delete([n2, i]), this.referenceDelegate.removeReference(t2, n2, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n2 = pi(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n2.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n2 = IDBKeyRange.bound([e], [e + 1], false, true), s = pi(t2);
    let i = un();
    return s.$t({
      range: n2,
      Ot: true
    }, (t3, e2, n3) => {
      const s2 = os(t3[1]), r2 = new at(s2);
      i = i.add(r2);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n2 = ss(e.path), s = IDBKeyRange.bound([n2], [q(n2)], false, true);
    let i = 0;
    return pi(t2).$t({
      index: gs.documentTargetsIndex,
      Ot: true,
      range: s
    }, ([t3, e2], n3, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  lt(t2, e) {
    return gi(t2).get(e).next((t3) => t3 ? Js(t3) : null);
  }
}
function gi(t2) {
  return Fs(t2, ms.store);
}
function yi(t2) {
  return Fs(t2, ys.store);
}
function pi(t2) {
  return Fs(t2, gs.store);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Ei(t2) {
  if (t2.code !== P.FAILED_PRECONDITION || t2.message !== Rs)
    throw t2;
  D("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ti([t2, e], [n2, s]) {
  const i = L(t2, n2);
  return i === 0 ? L(e, s) : i;
}
class Ii {
  constructor(t2) {
    this.ne = t2, this.buffer = new Xe(Ti), this.se = 0;
  }
  ie() {
    return ++this.se;
  }
  re(t2) {
    const e = [t2, this.ie()];
    if (this.buffer.size < this.ne)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Ti(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
}
class Ai {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.oe = false, this.ce = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.ue(t2);
  }
  stop() {
    this.ce && (this.ce.cancel(), this.ce = null);
  }
  get started() {
    return this.ce !== null;
  }
  ue(t2) {
    const e = this.oe ? 3e5 : 6e4;
    D("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.ce = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.ce = null, this.oe = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Ns(t3) ? D("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Ei(t3);
      }
      await this.ue(t2);
    });
  }
}
class Ri {
  constructor(t2, e) {
    this.ae = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.ae.he(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return vs.resolve(R.o);
    const n2 = new Ii(e);
    return this.ae.forEachTarget(t2, (t3) => n2.re(t3.sequenceNumber)).next(() => this.ae.le(t2, (t3) => n2.re(t3))).next(() => n2.maxValue);
  }
  removeTargets(t2, e, n2) {
    return this.ae.removeTargets(t2, e, n2);
  }
  removeOrphanedDocuments(t2, e) {
    return this.ae.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (D("LruGarbageCollector", "Garbage collection skipped; disabled"), vs.resolve(oi)) : this.getCacheSize(t2).next((n2) => n2 < this.params.cacheSizeCollectionThreshold ? (D("LruGarbageCollector", `Garbage collection skipped; Cache size ${n2} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), oi) : this.fe(t2, e));
  }
  getCacheSize(t2) {
    return this.ae.getCacheSize(t2);
  }
  fe(t2, e) {
    let n2, s, i, r2, o, u, a;
    const h2 = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (D("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r2 = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n2 = s2, o = Date.now(), this.removeTargets(t2, n2, e))).next((e2) => (i = e2, u = Date.now(), this.removeOrphanedDocuments(t2, n2))).next((t3) => {
      if (a = Date.now(), V() <= LogLevel.DEBUG) {
        D("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r2 - h2}ms
	Determined least recently used ${s} in ` + (o - r2) + `ms
	Removed ${i} targets in ` + (u - o) + `ms
	Removed ${t3} documents in ` + (a - u) + `ms
Total Duration: ${a - h2}ms`);
      }
      return vs.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pi {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Ri(t3, e2);
    }(this, e);
  }
  he(t2) {
    const e = this.de(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  de(t2) {
    let e = 0;
    return this.le(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  le(t2, e) {
    return this.we(t2, (t3, n2) => e(n2));
  }
  addReference(t2, e, n2) {
    return bi(t2, n2);
  }
  removeReference(t2, e, n2) {
    return bi(t2, n2);
  }
  removeTargets(t2, e, n2) {
    return this.db.getTargetCache().removeTargets(t2, e, n2);
  }
  markPotentiallyOrphaned(t2, e) {
    return bi(t2, e);
  }
  _e(t2, e) {
    return function(t3, e2) {
      let n2 = false;
      return wi(t3).Mt((s) => li(t3, s, e2).next((t4) => (t4 && (n2 = true), vs.resolve(!t4)))).next(() => n2);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n2 = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.we(t2, (r2, o) => {
      if (o <= e) {
        const e2 = this._e(t2, r2).next((e3) => {
          if (!e3)
            return i++, n2.getEntry(t2, r2).next(() => (n2.removeEntry(r2), pi(t2).delete([0, ss(r2.path)])));
        });
        s.push(e2);
      }
    }).next(() => vs.waitFor(s)).next(() => n2.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n2 = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n2);
  }
  updateLimboDocument(t2, e) {
    return bi(t2, e);
  }
  we(t2, e) {
    const n2 = pi(t2);
    let s, i = R.o;
    return n2.$t({
      index: gs.documentTargetsIndex
    }, ([t3, n3], {path: r2, sequenceNumber: o}) => {
      t3 === 0 ? (i !== R.o && e(new at(os(s)), i), i = o, s = r2) : i = R.o;
    }).next(() => {
      i !== R.o && e(new at(os(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
}
function bi(t2, e) {
  return pi(t2).put(function(t3, e2) {
    return new gs(0, ss(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vi {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n2 = this.inner[e];
    if (n2 !== void 0) {
      for (const [e2, s] of n2)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n2 = this.mapKeyFn(t2), s = this.inner[n2];
    if (s !== void 0) {
      for (let n3 = 0; n3 < s.length; n3++)
        if (this.equalsFn(s[n3][0], t2))
          return void (s[n3] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n2] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n2 = this.inner[e];
    if (n2 === void 0)
      return false;
    for (let s = 0; s < n2.length; s++)
      if (this.equalsFn(n2[s][0], t2))
        return n2.length === 1 ? delete this.inner[e] : n2.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    j(this.inner, (e, n2) => {
      for (const [e2, s] of n2)
        t2(e2, s);
    });
  }
  isEmpty() {
    return W(this.inner);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vi {
  constructor() {
    this.changes = new vi((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : K.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: Pt.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n2 = this.changes.get(e);
    return n2 !== void 0 ? vs.resolve(n2.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Si {
  constructor(t2, e) {
    this.R = t2, this.Ut = e;
  }
  addEntry(t2, e, n2) {
    return Ni(t2).put(xi(e), n2);
  }
  removeEntry(t2, e) {
    const n2 = Ni(t2), s = xi(e);
    return n2.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n2) => (n2.byteSize += e, this.me(t2, n2)));
  }
  getEntry(t2, e) {
    return Ni(t2).get(xi(e)).next((t3) => this.ge(e, t3));
  }
  ye(t2, e) {
    return Ni(t2).get(xi(e)).next((t3) => ({
      document: this.ge(e, t3),
      size: ai(t3)
    }));
  }
  getEntries(t2, e) {
    let n2 = en();
    return this.pe(t2, e, (t3, e2) => {
      const s = this.ge(t3, e2);
      n2 = n2.insert(t3, s);
    }).next(() => n2);
  }
  Ee(t2, e) {
    let n2 = en(), s = new He(at.comparator);
    return this.pe(t2, e, (t3, e2) => {
      const i = this.ge(t3, e2);
      n2 = n2.insert(t3, i), s = s.insert(t3, ai(e2));
    }).next(() => ({
      documents: n2,
      Te: s
    }));
  }
  pe(t2, e, n2) {
    if (e.isEmpty())
      return vs.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r2 = i.getNext();
    return Ni(t2).$t({
      range: s
    }, (t3, e2, s2) => {
      const o = at.fromSegments(t3);
      for (; r2 && at.comparator(r2, o) < 0; )
        n2(r2, null), r2 = i.getNext();
      r2 && r2.isEqual(o) && (n2(r2, e2), r2 = i.hasNext() ? i.getNext() : null), r2 ? s2.Ct(r2.path.toArray()) : s2.done();
    }).next(() => {
      for (; r2; )
        n2(r2, null), r2 = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n2) {
    let s = en();
    const i = e.path.length + 1, r2 = {};
    if (n2.isEqual(K.min())) {
      const t3 = e.path.toArray();
      r2.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = js(n2);
      r2.range = IDBKeyRange.lowerBound([t3, s2], true), r2.index = ws.collectionReadTimeIndex;
    }
    return Ni(t2).$t(r2, (t3, n3, r3) => {
      if (t3.length !== i)
        return;
      const o = Ks(this.R, n3);
      e.path.isPrefixOf(o.key.path) ? ue(e, o) && (s = s.insert(o.key, o)) : r3.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Di(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Ci(t2).get(_s.key).next((t3) => (O(!!t3), t3));
  }
  me(t2, e) {
    return Ci(t2).put(_s.key, e);
  }
  ge(t2, e) {
    if (e) {
      const t3 = Ks(this.R, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(K.min())))
        return t3;
    }
    return Pt.newInvalidDocument(t2);
  }
}
class Di extends Vi {
  constructor(t2, e) {
    super(), this.Ie = t2, this.trackRemovals = e, this.Ae = new vi((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n2 = 0, s = new Xe((t3, e2) => L(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r2) => {
      const o = this.Ae.get(i);
      if (r2.document.isValidDocument()) {
        const c = Qs(this.Ie.R, r2.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const u = ai(c);
        n2 += u - o, e.push(this.Ie.addEntry(t2, i, c));
      } else if (n2 -= o, this.trackRemovals) {
        const n3 = Qs(this.Ie.R, Pt.newNoDocument(i, K.min()), this.getReadTime(i));
        e.push(this.Ie.addEntry(t2, i, n3));
      } else
        e.push(this.Ie.removeEntry(t2, i));
    }), s.forEach((n3) => {
      e.push(this.Ie.Ut.addToCollectionParentIndex(t2, n3));
    }), e.push(this.Ie.updateMetadata(t2, n2)), vs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Ie.ye(t2, e).next((t3) => (this.Ae.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Ie.Ee(t2, e).next(({documents: t3, Te: e2}) => (e2.forEach((t4, e3) => {
      this.Ae.set(t4, e3);
    }), t3));
  }
}
function Ci(t2) {
  return Fs(t2, _s.store);
}
function Ni(t2) {
  return Fs(t2, ws.store);
}
function xi(t2) {
  return t2.path.toArray();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ki {
  constructor(t2) {
    this.R = t2;
  }
  Rt(t2, e, n2, s) {
    O(n2 < s && n2 >= 0 && s <= 11);
    const i = new Vs("createOrUpgrade", e);
    n2 < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(us.store);
    }(t2), function(t3) {
      t3.createObjectStore(as.store, {
        keyPath: as.keyPath
      });
      t3.createObjectStore(hs.store, {
        keyPath: hs.keyPath,
        autoIncrement: true
      }).createIndex(hs.userMutationsIndex, hs.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(ls.store);
    }(t2), Oi(t2), function(t3) {
      t3.createObjectStore(ws.store);
    }(t2));
    let r2 = vs.resolve();
    return n2 < 3 && s >= 3 && (n2 !== 0 && (!function(t3) {
      t3.deleteObjectStore(gs.store), t3.deleteObjectStore(ms.store), t3.deleteObjectStore(ys.store);
    }(t2), Oi(t2)), r2 = r2.next(() => function(t3) {
      const e2 = t3.store(ys.store), n3 = new ys(0, 0, K.min().toTimestamp(), 0);
      return e2.put(ys.key, n3);
    }(i))), n2 < 4 && s >= 4 && (n2 !== 0 && (r2 = r2.next(() => function(t3, e2) {
      return e2.store(hs.store).Nt().next((n3) => {
        t3.deleteObjectStore(hs.store);
        t3.createObjectStore(hs.store, {
          keyPath: hs.keyPath,
          autoIncrement: true
        }).createIndex(hs.userMutationsIndex, hs.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(hs.store), i2 = n3.map((t4) => s2.put(t4));
        return vs.waitFor(i2);
      });
    }(t2, i))), r2 = r2.next(() => {
      !function(t3) {
        t3.createObjectStore(Es.store, {
          keyPath: Es.keyPath
        });
      }(t2);
    })), n2 < 5 && s >= 5 && (r2 = r2.next(() => this.Re(i))), n2 < 6 && s >= 6 && (r2 = r2.next(() => (function(t3) {
      t3.createObjectStore(_s.store);
    }(t2), this.Pe(i)))), n2 < 7 && s >= 7 && (r2 = r2.next(() => this.be(i))), n2 < 8 && s >= 8 && (r2 = r2.next(() => this.ve(t2, i))), n2 < 9 && s >= 9 && (r2 = r2.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(ws.store);
        e2.createIndex(ws.readTimeIndex, ws.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(ws.collectionReadTimeIndex, ws.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n2 < 10 && s >= 10 && (r2 = r2.next(() => this.Ve(i))), n2 < 11 && s >= 11 && (r2 = r2.next(() => {
      !function(t3) {
        t3.createObjectStore(Ts.store, {
          keyPath: Ts.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Is.store, {
          keyPath: Is.keyPath
        });
      }(t2);
    })), r2;
  }
  Pe(t2) {
    let e = 0;
    return t2.store(ws.store).$t((t3, n2) => {
      e += ai(n2);
    }).next(() => {
      const n2 = new _s(e);
      return t2.store(_s.store).put(_s.key, n2);
    });
  }
  Re(t2) {
    const e = t2.store(as.store), n2 = t2.store(hs.store);
    return e.Nt().next((e2) => vs.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n2.Nt(hs.userMutationsIndex, s).next((n3) => vs.forEach(n3, (n4) => {
        O(n4.userId === e3.userId);
        const s2 = Hs(this.R, n4);
        return ui(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  be(t2) {
    const e = t2.store(gs.store), n2 = t2.store(ws.store);
    return t2.store(ys.store).get(ys.key).next((t3) => {
      const s = [];
      return n2.$t((n3, i) => {
        const r2 = new z(n3), o = function(t4) {
          return [0, ss(t4)];
        }(r2);
        s.push(e.get(o).next((n4) => n4 ? vs.resolve() : ((n5) => e.put(new gs(0, ss(n5), t3.highestListenSequenceNumber)))(r2)));
      }).next(() => vs.waitFor(s));
    });
  }
  ve(t2, e) {
    t2.createObjectStore(ps.store, {
      keyPath: ps.keyPath
    });
    const n2 = e.store(ps.store), s = new si(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n2.put({
          collectionId: e2,
          parent: ss(s2)
        });
      }
    };
    return e.store(ws.store).$t({
      Ot: true
    }, (t3, e2) => {
      const n3 = new z(t3);
      return i(n3.popLast());
    }).next(() => e.store(ls.store).$t({
      Ot: true
    }, ([t3, e2, n3], s2) => {
      const r2 = os(e2);
      return i(r2.popLast());
    }));
  }
  Ve(t2) {
    const e = t2.store(ms.store);
    return e.$t((t3, n2) => {
      const s = Js(n2), i = Ys(this.R, s);
      return e.put(i);
    });
  }
}
function Oi(t2) {
  t2.createObjectStore(gs.store, {
    keyPath: gs.keyPath
  }).createIndex(gs.documentTargetsIndex, gs.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(ms.store, {
    keyPath: ms.keyPath
  }).createIndex(ms.queryTargetsIndexName, ms.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(ys.store);
}
const $i = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
class Mi {
  constructor(t2, e, n2, s, i, r2, o, c, u, a) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n2, this.Se = i, this.window = r2, this.document = o, this.De = u, this.Ce = a, this.Ne = null, this.xe = false, this.isPrimary = false, this.networkEnabled = true, this.ke = null, this.inForeground = false, this.Oe = null, this.$e = null, this.Me = Number.NEGATIVE_INFINITY, this.Fe = (t3) => Promise.resolve(), !Mi.gt())
      throw new b(P.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Pi(this, s), this.Le = e + "main", this.R = new Us(c), this.Be = new Ss(this.Le, 11, new ki(this.R)), this.qe = new mi(this.referenceDelegate, this.R), this.Ut = new ii(), this.Ue = function(t3, e2) {
      return new Si(t3, e2);
    }(this.R, this.Ut), this.Ke = new Zs(), this.window && this.window.localStorage ? this.Qe = this.window.localStorage : (this.Qe = null, a === false && C("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.je().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new b(P.FAILED_PRECONDITION, $i);
      return this.We(), this.Ge(), this.ze(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.qe.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Ne = new R(t2, this.De);
    }).then(() => {
      this.xe = true;
    }).catch((t2) => (this.Be && this.Be.close(), Promise.reject(t2)));
  }
  He(t2) {
    return this.Fe = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.Be.bt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Se.enqueueAndForget(async () => {
      this.started && await this.je();
    }));
  }
  je() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => Li(t2).put(new Es(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.Je(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Se.enqueueRetryable(() => this.Fe(false)));
        });
    }).next(() => this.Ye(t2)).next((e) => this.isPrimary && !e ? this.Xe(t2).next(() => false) : !!e && this.Ze(t2).next(() => true))).catch((t2) => {
      if (Ns(t2))
        return D("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return D("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Se.enqueueRetryable(() => this.Fe(t2)), this.isPrimary = t2;
    });
  }
  Je(t2) {
    return Fi(t2).get(us.key).next((t3) => vs.resolve(this.tn(t3)));
  }
  en(t2) {
    return Li(t2).delete(this.clientId);
  }
  async nn() {
    if (this.isPrimary && !this.sn(this.Me, 18e5)) {
      this.Me = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = Fs(t3, Es.store);
        return e.Nt().next((t4) => {
          const n2 = this.rn(t4, 18e5), s = t4.filter((t5) => n2.indexOf(t5) === -1);
          return vs.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Qe)
        for (const e of t2)
          this.Qe.removeItem(this.on(e.clientId));
    }
  }
  ze() {
    this.$e = this.Se.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.je().then(() => this.nn()).then(() => this.ze()));
  }
  tn(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  Ye(t2) {
    if (this.Ce)
      return vs.resolve(true);
    return Fi(t2).get(us.key).next((e) => {
      if (e !== null && this.sn(e.leaseTimestampMs, 5e3) && !this.cn(e.ownerId)) {
        if (this.tn(e) && this.networkEnabled)
          return true;
        if (!this.tn(e)) {
          if (!e.allowTabSynchronization)
            throw new b(P.FAILED_PRECONDITION, $i);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || Li(t2).Nt().next((t3) => this.rn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n2 = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n2 && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && D("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.xe = false, this.un(), this.$e && (this.$e.cancel(), this.$e = null), this.an(), this.hn(), await this.Be.runTransaction("shutdown", "readwrite", [us.store, Es.store], (t2) => {
      const e = new Ms(t2, R.o);
      return this.Xe(e).next(() => this.en(e));
    }), this.Be.close(), this.ln();
  }
  rn(t2, e) {
    return t2.filter((t3) => this.sn(t3.updateTimeMs, e) && !this.cn(t3.clientId));
  }
  fn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => Li(t2).Nt().next((t3) => this.rn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.xe;
  }
  getMutationQueue(t2) {
    return hi.Qt(t2, this.R, this.Ut, this.referenceDelegate);
  }
  getTargetCache() {
    return this.qe;
  }
  getRemoteDocumentCache() {
    return this.Ue;
  }
  getIndexManager() {
    return this.Ut;
  }
  getBundleCache() {
    return this.Ke;
  }
  runTransaction(t2, e, n2) {
    D("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.Be.runTransaction(t2, s, As, (s2) => (i = new Ms(s2, this.Ne ? this.Ne.next() : R.o), e === "readwrite-primary" ? this.Je(i).next((t3) => !!t3 || this.Ye(i)).next((e2) => {
      if (!e2)
        throw C(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Se.enqueueRetryable(() => this.Fe(false)), new b(P.FAILED_PRECONDITION, Rs);
      return n2(i);
    }).next((t3) => this.Ze(i).next(() => t3)) : this.dn(i).next(() => n2(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  dn(t2) {
    return Fi(t2).get(us.key).next((t3) => {
      if (t3 !== null && this.sn(t3.leaseTimestampMs, 5e3) && !this.cn(t3.ownerId) && !this.tn(t3) && !(this.Ce || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new b(P.FAILED_PRECONDITION, $i);
    });
  }
  Ze(t2) {
    const e = new us(this.clientId, this.allowTabSynchronization, Date.now());
    return Fi(t2).put(us.key, e);
  }
  static gt() {
    return Ss.gt();
  }
  Xe(t2) {
    const e = Fi(t2);
    return e.get(us.key).next((t3) => this.tn(t3) ? (D("IndexedDbPersistence", "Releasing primary lease."), e.delete(us.key)) : vs.resolve());
  }
  sn(t2, e) {
    const n2 = Date.now();
    return !(t2 < n2 - e) && (!(t2 > n2) || (C(`Detected an update time that is in the future: ${t2} > ${n2}`), false));
  }
  We() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.Oe = () => {
      this.Se.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.je()));
    }, this.document.addEventListener("visibilitychange", this.Oe), this.inForeground = this.document.visibilityState === "visible");
  }
  an() {
    this.Oe && (this.document.removeEventListener("visibilitychange", this.Oe), this.Oe = null);
  }
  Ge() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.ke = () => {
      this.un(), this.Se.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("unload", this.ke));
  }
  hn() {
    this.ke && (this.window.removeEventListener("unload", this.ke), this.ke = null);
  }
  cn(t2) {
    var e;
    try {
      const n2 = ((e = this.Qe) === null || e === void 0 ? void 0 : e.getItem(this.on(t2))) !== null;
      return D("IndexedDbPersistence", `Client '${t2}' ${n2 ? "is" : "is not"} zombied in LocalStorage`), n2;
    } catch (t3) {
      return C("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  un() {
    if (this.Qe)
      try {
        this.Qe.setItem(this.on(this.clientId), String(Date.now()));
      } catch (t2) {
        C("Failed to set zombie client id.", t2);
      }
  }
  ln() {
    if (this.Qe)
      try {
        this.Qe.removeItem(this.on(this.clientId));
      } catch (t2) {
      }
  }
  on(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
}
function Fi(t2) {
  return Fs(t2, us.store);
}
function Li(t2) {
  return Fs(t2, Es.store);
}
function Bi(t2, e) {
  let n2 = t2.projectId;
  return t2.isDefaultDatabase || (n2 += "." + t2.database), "firestore/" + e + "/" + n2 + "/";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qi {
  constructor(t2, e) {
    this.progress = t2, this.wn = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ui {
  constructor(t2, e, n2) {
    this.Ue = t2, this._n = e, this.Ut = n2;
  }
  mn(t2, e) {
    return this._n.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n2) => this.gn(t2, e, n2));
  }
  gn(t2, e, n2) {
    return this.Ue.getEntry(t2, e).next((t3) => {
      for (const e2 of n2)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  yn(t2, e) {
    t2.forEach((t3, n2) => {
      for (const t4 of e)
        t4.applyToLocalView(n2);
    });
  }
  pn(t2, e) {
    return this.Ue.getEntries(t2, e).next((e2) => this.En(t2, e2).next(() => e2));
  }
  En(t2, e) {
    return this._n.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.yn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n2) {
    return function(t3) {
      return at.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Tn(t2, e.path) : ee(e) ? this.In(t2, e, n2) : this.An(t2, e, n2);
  }
  Tn(t2, e) {
    return this.mn(t2, new at(e)).next((t3) => {
      let e2 = sn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  In(t2, e, n2) {
    const s = e.collectionGroup;
    let i = sn();
    return this.Ut.getCollectionParents(t2, s).next((r2) => vs.forEach(r2, (r3) => {
      const o = function(t3, e2) {
        return new zt(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r3.child(s));
      return this.An(t2, o, n2).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  An(t2, e, n2) {
    let s, i;
    return this.Ue.getDocumentsMatchingQuery(t2, e, n2).next((n3) => (s = n3, this._n.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Rn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n3 = e3.key;
          let i2 = s.get(n3);
          i2 == null && (i2 = Pt.newInvalidDocument(n3), s = s.insert(n3, i2)), xe(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n3));
        }
    }))).next(() => (s.forEach((t3, n3) => {
      ue(e, n3) || (s = s.remove(t3));
    }), s));
  }
  Rn(t2, e, n2) {
    let s = un();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof Fe && n2.get(e2.key) === null && (s = s.add(e2.key));
    let i = n2;
    return this.Ue.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ki {
  constructor(t2, e, n2, s) {
    this.targetId = t2, this.fromCache = e, this.Pn = n2, this.bn = s;
  }
  static vn(t2, e) {
    let n2 = un(), s = un();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n2 = n2.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new Ki(t2, e.fromCache, n2, s);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qi {
  Vn(t2) {
    this.Sn = t2;
  }
  getDocumentsMatchingQuery(t2, e, n2, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n2.isEqual(K.min()) ? this.Dn(t2, e) : this.Sn.pn(t2, s).next((i) => {
      const r2 = this.Cn(e, i);
      return (Yt(e) || Xt(e)) && this.Nn(e.limitType, r2, s, n2) ? this.Dn(t2, e) : (V() <= LogLevel.DEBUG && D("QueryEngine", "Re-using previous result from %s to execute query: %s", n2.toString(), ce(e)), this.Sn.getDocumentsMatchingQuery(t2, e, n2).next((t3) => (r2.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Cn(t2, e) {
    let n2 = new Xe(ae(t2));
    return e.forEach((e2, s) => {
      ue(t2, s) && (n2 = n2.add(s));
    }), n2;
  }
  Nn(t2, e, n2, s) {
    if (n2.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Dn(t2, e) {
    return V() <= LogLevel.DEBUG && D("QueryEngine", "Using full collection scan to execute query:", ce(e)), this.Sn.getDocumentsMatchingQuery(t2, e, K.min());
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ji {
  constructor(t2, e, n2, s) {
    this.persistence = t2, this.xn = e, this.R = s, this.kn = new He(L), this.On = new vi((t3) => Vt(t3), Dt), this.$n = K.min(), this._n = t2.getMutationQueue(n2), this.Mn = t2.getRemoteDocumentCache(), this.qe = t2.getTargetCache(), this.Fn = new Ui(this.Mn, this._n, this.persistence.getIndexManager()), this.Ke = t2.getBundleCache(), this.xn.Vn(this.Fn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.kn));
  }
}
function Wi(t2, e, n2, s) {
  return new ji(t2, e, n2, s);
}
async function Gi(t2, e) {
  const n2 = $(t2);
  let s = n2._n, i = n2.Fn;
  const r2 = await n2.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r3;
    return n2._n.getAllMutationBatches(t3).next((o) => (r3 = o, s = n2.persistence.getMutationQueue(e), i = new Ui(n2.Mn, s, n2.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n3 = [], s2 = [];
      let o = un();
      for (const t4 of r3) {
        n3.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.pn(t3, o).next((t4) => ({
        Ln: t4,
        removedBatchIds: n3,
        addedBatchIds: s2
      }));
    });
  });
  return n2._n = s, n2.Fn = i, n2.xn.Vn(n2.Fn), r2;
}
function zi(t2, e) {
  const n2 = $(t2);
  return n2.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n2.Mn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n3, s2) {
      const i2 = n3.batch, r2 = i2.keys();
      let o = vs.resolve();
      return r2.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r3 = n3.docVersions.get(t5);
          O(r3 !== null), e3.version.compareTo(r3) < 0 && (i2.applyToRemoteDocument(e3, n3), e3.isValidDocument() && s2.addEntry(e3, n3.commitVersion));
        });
      }), o.next(() => t4._n.removeMutationBatch(e2, i2));
    }(n2, t3, e, i).next(() => i.apply(t3)).next(() => n2._n.performConsistencyCheck(t3)).next(() => n2.Fn.pn(t3, s));
  });
}
function Hi(t2) {
  const e = $(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.qe.getLastRemoteSnapshotVersion(t3));
}
function Ji(t2, e) {
  const n2 = $(t2), s = e.snapshotVersion;
  let i = n2.kn;
  return n2.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r2 = n2.Mn.newChangeBuffer({
      trackRemovals: true
    });
    i = n2.kn;
    const o = [];
    e.targetChanges.forEach((e2, r3) => {
      const c2 = i.get(r3);
      if (!c2)
        return;
      o.push(n2.qe.removeMatchingKeys(t3, e2.removedDocuments, r3).next(() => n2.qe.addMatchingKeys(t3, e2.addedDocuments, r3)));
      const u = e2.resumeToken;
      if (u.approximateByteSize() > 0) {
        const a = c2.withResumeToken(u, s).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r3, a), function(t4, e3, n3) {
          if (O(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n3.addedDocuments.size + n3.modifiedDocuments.size + n3.removedDocuments.size > 0;
        }(c2, a, e2) && o.push(n2.qe.updateTargetData(t3, a));
      }
    });
    let c = en();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n2.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(Yi(t3, r2, e.documentUpdates, s, void 0).next((t4) => {
      c = t4;
    })), !s.isEqual(K.min())) {
      const e2 = n2.qe.getLastRemoteSnapshotVersion(t3).next((e3) => n2.qe.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return vs.waitFor(o).next(() => r2.apply(t3)).next(() => n2.Fn.En(t3, c)).next(() => c);
  }).then((t3) => (n2.kn = i, t3));
}
function Yi(t2, e, n2, s, i) {
  let r2 = un();
  return n2.forEach((t3) => r2 = r2.add(t3)), e.getEntries(t2, r2).next((t3) => {
    let r3 = en();
    return n2.forEach((n3, o) => {
      const c = t3.get(n3), u = (i == null ? void 0 : i.get(n3)) || s;
      o.isNoDocument() && o.version.isEqual(K.min()) ? (e.removeEntry(n3, u), r3 = r3.insert(n3, o)) : !c.isValidDocument() || o.version.compareTo(c.version) > 0 || o.version.compareTo(c.version) === 0 && c.hasPendingWrites ? (e.addEntry(o, u), r3 = r3.insert(n3, o)) : D("LocalStore", "Ignoring outdated watch update for ", n3, ". Current version:", c.version, " Watch version:", o.version);
    }), r3;
  });
}
function Xi(t2, e) {
  const n2 = $(t2);
  return n2.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n2._n.getNextMutationBatchAfterBatchId(t3, e)));
}
function Zi(t2, e) {
  const n2 = $(t2);
  return n2.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n2.qe.getTargetData(t3, e).next((i) => i ? (s = i, vs.resolve(s)) : n2.qe.allocateTargetId(t3).next((i2) => (s = new qs(e, i2, 0, t3.currentSequenceNumber), n2.qe.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n2.kn.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n2.kn = n2.kn.insert(t3.targetId, t3), n2.On.set(e, t3.targetId)), t3;
  });
}
async function tr(t2, e, n2) {
  const s = $(t2), i = s.kn.get(e), r2 = n2 ? "readwrite" : "readwrite-primary";
  try {
    n2 || await s.persistence.runTransaction("Release target", r2, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Ns(t3))
      throw t3;
    D("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.kn = s.kn.remove(e), s.On.delete(i.target);
}
function er(t2, e, n2) {
  const s = $(t2);
  let i = K.min(), r2 = un();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n3) {
    const s2 = $(t4), i2 = s2.On.get(n3);
    return i2 !== void 0 ? vs.resolve(s2.kn.get(i2)) : s2.qe.getTargetData(e2, n3);
  }(s, t3, se(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.qe.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r2 = t4;
      });
  }).next(() => s.xn.getDocumentsMatchingQuery(t3, e, n2 ? i : K.min(), n2 ? r2 : un())).next((t4) => ({
    documents: t4,
    Bn: r2
  })));
}
function nr(t2, e) {
  const n2 = $(t2), s = $(n2.qe), i = n2.kn.get(e);
  return i ? Promise.resolve(i.target) : n2.persistence.runTransaction("Get target data", "readonly", (t3) => s.lt(t3, e).next((t4) => t4 ? t4.target : null));
}
function sr(t2) {
  const e = $(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n2) {
    const s = $(t4);
    let i = en(), r2 = js(n2);
    const o = Ni(e2), c = IDBKeyRange.lowerBound(r2, true);
    return o.$t({
      index: ws.readTimeIndex,
      range: c
    }, (t5, e3) => {
      const n3 = Ks(s.R, e3);
      i = i.insert(n3.key, n3), r2 = e3.readTime;
    }).next(() => ({
      wn: i,
      readTime: Ws(r2)
    }));
  }(e.Mn, t3, e.$n)).then(({wn: t3, readTime: n2}) => (e.$n = n2, t3));
}
async function ir(t2) {
  const e = $(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = Ni(t4);
    let n2 = K.min();
    return e2.$t({
      index: ws.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n2 = Ws(e3.readTime)), s.done();
    }).next(() => n2);
  }(t3)).then((t3) => {
    e.$n = t3;
  });
}
async function rr(t2, e, n2, s) {
  const i = $(t2);
  let r2 = un(), o = en(), c = on();
  for (const t3 of n2) {
    const n3 = e.qn(t3.metadata.name);
    t3.document && (r2 = r2.add(n3)), o = o.insert(n3, e.Un(t3)), c = c.insert(n3, e.Kn(t3.metadata.readTime));
  }
  const u = i.Mn.newChangeBuffer({
    trackRemovals: true
  }), a = await Zi(i, function(t3) {
    return se(Jt(z.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => Yi(t3, u, o, K.min(), c).next((e2) => (u.apply(t3), e2)).next((e2) => i.qe.removeMatchingKeysForTargetId(t3, a.targetId).next(() => i.qe.addMatchingKeys(t3, r2, a.targetId)).next(() => i.Fn.En(t3, e2)).next(() => e2)));
}
async function or(t2, e, n2 = un()) {
  const s = await Zi(t2, se(Xs(e.bundledQuery))), i = $(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r2 = bn(e.readTime);
    if (s.snapshotVersion.compareTo(r2) >= 0)
      return i.Ke.saveNamedQuery(t3, e);
    const o = s.withResumeToken(X.EMPTY_BYTE_STRING, r2);
    return i.kn = i.kn.insert(o.targetId, o), i.qe.updateTargetData(t3, o).next(() => i.qe.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.qe.addMatchingKeys(t3, n2, s.targetId)).next(() => i.Ke.saveNamedQuery(t3, e));
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cr {
  constructor(t2) {
    this.R = t2, this.Qn = new Map(), this.jn = new Map();
  }
  getBundleMetadata(t2, e) {
    return vs.resolve(this.Qn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n2;
    return this.Qn.set(e.id, {
      id: (n2 = e).id,
      version: n2.version,
      createTime: bn(n2.createTime)
    }), vs.resolve();
  }
  getNamedQuery(t2, e) {
    return vs.resolve(this.jn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.jn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: Xs(t3.bundledQuery),
        readTime: bn(t3.readTime)
      };
    }(e)), vs.resolve();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ur {
  constructor() {
    this.Wn = new Xe(ar.Gn), this.zn = new Xe(ar.Hn);
  }
  isEmpty() {
    return this.Wn.isEmpty();
  }
  addReference(t2, e) {
    const n2 = new ar(t2, e);
    this.Wn = this.Wn.add(n2), this.zn = this.zn.add(n2);
  }
  Jn(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.Yn(new ar(t2, e));
  }
  Xn(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  Zn(t2) {
    const e = new at(new z([])), n2 = new ar(e, t2), s = new ar(e, t2 + 1), i = [];
    return this.zn.forEachInRange([n2, s], (t3) => {
      this.Yn(t3), i.push(t3.key);
    }), i;
  }
  ts() {
    this.Wn.forEach((t2) => this.Yn(t2));
  }
  Yn(t2) {
    this.Wn = this.Wn.delete(t2), this.zn = this.zn.delete(t2);
  }
  es(t2) {
    const e = new at(new z([])), n2 = new ar(e, t2), s = new ar(e, t2 + 1);
    let i = un();
    return this.zn.forEachInRange([n2, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new ar(t2, 0), n2 = this.Wn.firstAfterOrEqual(e);
    return n2 !== null && t2.isEqual(n2.key);
  }
}
class ar {
  constructor(t2, e) {
    this.key = t2, this.ns = e;
  }
  static Gn(t2, e) {
    return at.comparator(t2.key, e.key) || L(t2.ns, e.ns);
  }
  static Hn(t2, e) {
    return L(t2.ns, e.ns) || at.comparator(t2.key, e.key);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hr {
  constructor(t2, e) {
    this.Ut = t2, this.referenceDelegate = e, this._n = [], this.ss = 1, this.rs = new Xe(ar.Gn);
  }
  checkEmpty(t2) {
    return vs.resolve(this._n.length === 0);
  }
  addMutationBatch(t2, e, n2, s) {
    const i = this.ss;
    if (this.ss++, this._n.length > 0) {
      this._n[this._n.length - 1];
    }
    const r2 = new Ls(i, e, n2, s);
    this._n.push(r2);
    for (const e2 of s)
      this.rs = this.rs.add(new ar(e2.key, i)), this.Ut.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return vs.resolve(r2);
  }
  lookupMutationBatch(t2, e) {
    return vs.resolve(this.os(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n2 = e + 1, s = this.cs(n2), i = s < 0 ? 0 : s;
    return vs.resolve(this._n.length > i ? this._n[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return vs.resolve(this._n.length === 0 ? -1 : this.ss - 1);
  }
  getAllMutationBatches(t2) {
    return vs.resolve(this._n.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n2 = new ar(e, 0), s = new ar(e, Number.POSITIVE_INFINITY), i = [];
    return this.rs.forEachInRange([n2, s], (t3) => {
      const e2 = this.os(t3.ns);
      i.push(e2);
    }), vs.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n2 = new Xe(L);
    return e.forEach((t3) => {
      const e2 = new ar(t3, 0), s = new ar(t3, Number.POSITIVE_INFINITY);
      this.rs.forEachInRange([e2, s], (t4) => {
        n2 = n2.add(t4.ns);
      });
    }), vs.resolve(this.us(n2));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n2 = e.path, s = n2.length + 1;
    let i = n2;
    at.isDocumentKey(i) || (i = i.child(""));
    const r2 = new ar(new at(i), 0);
    let o = new Xe(L);
    return this.rs.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n2.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ns)), true);
    }, r2), vs.resolve(this.us(o));
  }
  us(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n2 = this.os(t3);
      n2 !== null && e.push(n2);
    }), e;
  }
  removeMutationBatch(t2, e) {
    O(this.hs(e.batchId, "removed") === 0), this._n.shift();
    let n2 = this.rs;
    return vs.forEach(e.mutations, (s) => {
      const i = new ar(s.key, e.batchId);
      return n2 = n2.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.rs = n2;
    });
  }
  Gt(t2) {
  }
  containsKey(t2, e) {
    const n2 = new ar(e, 0), s = this.rs.firstAfterOrEqual(n2);
    return vs.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this._n.length, vs.resolve();
  }
  hs(t2, e) {
    return this.cs(t2);
  }
  cs(t2) {
    if (this._n.length === 0)
      return 0;
    return t2 - this._n[0].batchId;
  }
  os(t2) {
    const e = this.cs(t2);
    if (e < 0 || e >= this._n.length)
      return null;
    return this._n[e];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lr {
  constructor(t2, e) {
    this.Ut = t2, this.ls = e, this.docs = new He(at.comparator), this.size = 0;
  }
  addEntry(t2, e, n2) {
    const s = e.key, i = this.docs.get(s), r2 = i ? i.size : 0, o = this.ls(e);
    return this.docs = this.docs.insert(s, {
      document: e.clone(),
      size: o,
      readTime: n2
    }), this.size += o - r2, this.Ut.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n2 = this.docs.get(e);
    return vs.resolve(n2 ? n2.document.clone() : Pt.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n2 = en();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n2 = n2.insert(t3, e2 ? e2.document.clone() : Pt.newInvalidDocument(t3));
    }), vs.resolve(n2);
  }
  getDocumentsMatchingQuery(t2, e, n2) {
    let s = en();
    const i = new at(e.path.child("")), r2 = this.docs.getIteratorFrom(i);
    for (; r2.hasNext(); ) {
      const {key: t3, value: {document: i2, readTime: o}} = r2.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n2) <= 0 || ue(e, i2) && (s = s.insert(i2.key, i2.clone()));
    }
    return vs.resolve(s);
  }
  fs(t2, e) {
    return vs.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new fr(this);
  }
  getSize(t2) {
    return vs.resolve(this.size);
  }
}
class fr extends Vi {
  constructor(t2) {
    super(), this.Ie = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n2, s) => {
      s.document.isValidDocument() ? e.push(this.Ie.addEntry(t2, s.document, this.getReadTime(n2))) : this.Ie.removeEntry(n2);
    }), vs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Ie.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Ie.getEntries(t2, e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dr {
  constructor(t2) {
    this.persistence = t2, this.ds = new vi((t3) => Vt(t3), Dt), this.lastRemoteSnapshotVersion = K.min(), this.highestTargetId = 0, this.ws = 0, this._s = new ur(), this.targetCount = 0, this.gs = _i.Jt();
  }
  forEachTarget(t2, e) {
    return this.ds.forEach((t3, n2) => e(n2)), vs.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return vs.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return vs.resolve(this.ws);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.gs.next(), vs.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n2) {
    return n2 && (this.lastRemoteSnapshotVersion = n2), e > this.ws && (this.ws = e), vs.resolve();
  }
  te(t2) {
    this.ds.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.gs = new _i(e), this.highestTargetId = e), t2.sequenceNumber > this.ws && (this.ws = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.te(e), this.targetCount += 1, vs.resolve();
  }
  updateTargetData(t2, e) {
    return this.te(e), vs.resolve();
  }
  removeTargetData(t2, e) {
    return this.ds.delete(e.target), this._s.Zn(e.targetId), this.targetCount -= 1, vs.resolve();
  }
  removeTargets(t2, e, n2) {
    let s = 0;
    const i = [];
    return this.ds.forEach((r2, o) => {
      o.sequenceNumber <= e && n2.get(o.targetId) === null && (this.ds.delete(r2), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), vs.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return vs.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n2 = this.ds.get(e) || null;
    return vs.resolve(n2);
  }
  addMatchingKeys(t2, e, n2) {
    return this._s.Jn(e, n2), vs.resolve();
  }
  removeMatchingKeys(t2, e, n2) {
    this._s.Xn(e, n2);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), vs.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this._s.Zn(e), vs.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n2 = this._s.es(e);
    return vs.resolve(n2);
  }
  containsKey(t2, e) {
    return vs.resolve(this._s.containsKey(e));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wr {
  constructor(t2, e) {
    this.ys = {}, this.Ne = new R(0), this.xe = false, this.xe = true, this.referenceDelegate = t2(this), this.qe = new dr(this);
    this.Ut = new ni(), this.Ue = function(t3, e2) {
      return new lr(t3, e2);
    }(this.Ut, (t3) => this.referenceDelegate.ps(t3)), this.R = new Us(e), this.Ke = new cr(this.R);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.xe = false, Promise.resolve();
  }
  get started() {
    return this.xe;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.Ut;
  }
  getMutationQueue(t2) {
    let e = this.ys[t2.toKey()];
    return e || (e = new hr(this.Ut, this.referenceDelegate), this.ys[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.qe;
  }
  getRemoteDocumentCache() {
    return this.Ue;
  }
  getBundleCache() {
    return this.Ke;
  }
  runTransaction(t2, e, n2) {
    D("MemoryPersistence", "Starting transaction:", t2);
    const s = new _r(this.Ne.next());
    return this.referenceDelegate.Es(), n2(s).next((t3) => this.referenceDelegate.Ts(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Is(t2, e) {
    return vs.or(Object.values(this.ys).map((n2) => () => n2.containsKey(t2, e)));
  }
}
class _r extends Ps {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
}
class mr {
  constructor(t2) {
    this.persistence = t2, this.As = new ur(), this.Rs = null;
  }
  static Ps(t2) {
    return new mr(t2);
  }
  get bs() {
    if (this.Rs)
      return this.Rs;
    throw k();
  }
  addReference(t2, e, n2) {
    return this.As.addReference(n2, e), this.bs.delete(n2.toString()), vs.resolve();
  }
  removeReference(t2, e, n2) {
    return this.As.removeReference(n2, e), this.bs.add(n2.toString()), vs.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.bs.add(e.toString()), vs.resolve();
  }
  removeTarget(t2, e) {
    this.As.Zn(e.targetId).forEach((t3) => this.bs.add(t3.toString()));
    const n2 = this.persistence.getTargetCache();
    return n2.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.bs.add(t4.toString()));
    }).next(() => n2.removeTargetData(t2, e));
  }
  Es() {
    this.Rs = new Set();
  }
  Ts(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return vs.forEach(this.bs, (n2) => {
      const s = at.fromPath(n2);
      return this.vs(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Rs = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.vs(t2, e).next((t3) => {
      t3 ? this.bs.delete(e.toString()) : this.bs.add(e.toString());
    });
  }
  ps(t2) {
    return 0;
  }
  vs(t2, e) {
    return vs.or([() => vs.resolve(this.As.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Is(t2, e)]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gr {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
}
gr.UNAUTHENTICATED = new gr(null), gr.GOOGLE_CREDENTIALS = new gr("google-credentials-uid"), gr.FIRST_PARTY = new gr("first-party-uid");
function yr(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function pr(t2, e, n2) {
  let s = `firestore_mutations_${t2}_${n2}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Er(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
class Tr {
  constructor(t2, e, n2, s) {
    this.user = t2, this.batchId = e, this.state = n2, this.error = s;
  }
  static Vs(t2, e, n2) {
    const s = JSON.parse(n2);
    let i, r2 = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r2 && s.error && (r2 = typeof s.error.message == "string" && typeof s.error.code == "string", r2 && (i = new b(s.error.code, s.error.message))), r2 ? new Tr(t2, e, s.state, i) : (C("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n2}`), null);
  }
  Ss() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
}
class Ir {
  constructor(t2, e, n2) {
    this.targetId = t2, this.state = e, this.error = n2;
  }
  static Vs(t2, e) {
    const n2 = JSON.parse(e);
    let s, i = typeof n2 == "object" && ["not-current", "current", "rejected"].indexOf(n2.state) !== -1 && (n2.error === void 0 || typeof n2.error == "object");
    return i && n2.error && (i = typeof n2.error.message == "string" && typeof n2.error.code == "string", i && (s = new b(n2.error.code, n2.error.message))), i ? new Ir(t2, n2.state, s) : (C("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Ss() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
}
class Ar {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Vs(t2, e) {
    const n2 = JSON.parse(e);
    let s = typeof n2 == "object" && n2.activeTargetIds instanceof Array, i = hn();
    for (let t3 = 0; s && t3 < n2.activeTargetIds.length; ++t3)
      s = ut(n2.activeTargetIds[t3]), i = i.add(n2.activeTargetIds[t3]);
    return s ? new Ar(t2, i) : (C("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
}
class Rr {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Vs(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Rr(e.clientId, e.onlineState) : (C("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
}
class Pr {
  constructor() {
    this.activeTargetIds = hn();
  }
  Ds(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Cs(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Ss() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
}
class br {
  constructor(t2, e, n2, s, i) {
    this.window = t2, this.Se = e, this.persistenceKey = n2, this.Ns = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.xs = this.ks.bind(this), this.Os = new He(L), this.started = false, this.$s = [];
    const r2 = n2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.Ms = yr(this.persistenceKey, this.Ns), this.Fs = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.Os = this.Os.insert(this.Ns, new Pr()), this.Ls = new RegExp(`^firestore_clients_${r2}_([^_]*)$`), this.Bs = new RegExp(`^firestore_mutations_${r2}_(\\d+)(?:_(.*))?$`), this.qs = new RegExp(`^firestore_targets_${r2}_(\\d+)$`), this.Us = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Ks = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.xs);
  }
  static gt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.fn();
    for (const e2 of t2) {
      if (e2 === this.Ns)
        continue;
      const t3 = this.getItem(yr(this.persistenceKey, e2));
      if (t3) {
        const n2 = Ar.Vs(e2, t3);
        n2 && (this.Os = this.Os.insert(n2.clientId, n2));
      }
    }
    this.Qs();
    const e = this.storage.getItem(this.Us);
    if (e) {
      const t3 = this.js(e);
      t3 && this.Ws(t3);
    }
    for (const t3 of this.$s)
      this.ks(t3);
    this.$s = [], this.window.addEventListener("unload", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Fs, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.Gs(this.Os);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.Os.forEach((n2, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.zs(t2, "pending");
  }
  updateMutationState(t2, e, n2) {
    this.zs(t2, e, n2), this.Hs(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n2 = this.storage.getItem(Er(this.persistenceKey, t2));
      if (n2) {
        const s = Ir.Vs(t2, n2);
        s && (e = s.state);
      }
    }
    return this.Js.Ds(t2), this.Qs(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Js.Cs(t2), this.Qs();
  }
  isLocalQueryTarget(t2) {
    return this.Js.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(Er(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n2) {
    this.Ys(t2, e, n2);
  }
  handleUserChange(t2, e, n2) {
    e.forEach((t3) => {
      this.Hs(t3);
    }), this.currentUser = t2, n2.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Xs(t2);
  }
  notifyBundleLoaded() {
    this.Zs();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.xs), this.removeItem(this.Ms), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return D("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    D("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    D("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  ks(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (D("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.Ms)
        return void C("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Se.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Ls.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ti(e.key);
                return this.ei(t3, null);
              }
              {
                const t3 = this.ni(e.key, e.newValue);
                if (t3)
                  return this.ei(t3.clientId, t3);
              }
            } else if (this.Bs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.si(e.key, e.newValue);
                if (t3)
                  return this.ii(t3);
              }
            } else if (this.qs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.ri(e.key, e.newValue);
                if (t3)
                  return this.oi(t3);
              }
            } else if (e.key === this.Us) {
              if (e.newValue !== null) {
                const t3 = this.js(e.newValue);
                if (t3)
                  return this.Ws(t3);
              }
            } else if (e.key === this.Fs) {
              const t3 = function(t4) {
                let e2 = R.o;
                if (t4 != null)
                  try {
                    const n2 = JSON.parse(t4);
                    O(typeof n2 == "number"), e2 = n2;
                  } catch (t5) {
                    C("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== R.o && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Ks)
              return this.syncEngine.ci();
          }
        } else
          this.$s.push(e);
      });
    }
  }
  get Js() {
    return this.Os.get(this.Ns);
  }
  Qs() {
    this.setItem(this.Ms, this.Js.Ss());
  }
  zs(t2, e, n2) {
    const s = new Tr(this.currentUser, t2, e, n2), i = pr(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Ss());
  }
  Hs(t2) {
    const e = pr(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Xs(t2) {
    const e = {
      clientId: this.Ns,
      onlineState: t2
    };
    this.storage.setItem(this.Us, JSON.stringify(e));
  }
  Ys(t2, e, n2) {
    const s = Er(this.persistenceKey, t2), i = new Ir(t2, e, n2);
    this.setItem(s, i.Ss());
  }
  Zs() {
    this.setItem(this.Ks, "value-not-used");
  }
  ti(t2) {
    const e = this.Ls.exec(t2);
    return e ? e[1] : null;
  }
  ni(t2, e) {
    const n2 = this.ti(t2);
    return Ar.Vs(n2, e);
  }
  si(t2, e) {
    const n2 = this.Bs.exec(t2), s = Number(n2[1]), i = n2[2] !== void 0 ? n2[2] : null;
    return Tr.Vs(new gr(i), s, e);
  }
  ri(t2, e) {
    const n2 = this.qs.exec(t2), s = Number(n2[1]);
    return Ir.Vs(s, e);
  }
  js(t2) {
    return Rr.Vs(t2);
  }
  async ii(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.ui(t2.batchId, t2.state, t2.error);
    D("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  oi(t2) {
    return this.syncEngine.ai(t2.targetId, t2.state, t2.error);
  }
  ei(t2, e) {
    const n2 = e ? this.Os.insert(t2, e) : this.Os.remove(t2), s = this.Gs(this.Os), i = this.Gs(n2), r2 = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r2.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.hi(r2, o).then(() => {
      this.Os = n2;
    });
  }
  Ws(t2) {
    this.Os.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  Gs(t2) {
    let e = hn();
    return t2.forEach((t3, n2) => {
      e = e.unionWith(n2.activeTargetIds);
    }), e;
  }
}
class vr {
  constructor() {
    this.li = new Pr(), this.fi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n2) {
  }
  addLocalQueryTarget(t2) {
    return this.li.Ds(t2), this.fi[t2] || "not-current";
  }
  updateQueryState(t2, e, n2) {
    this.fi[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.li.Cs(t2);
  }
  isLocalQueryTarget(t2) {
    return this.li.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.fi[t2];
  }
  getAllActiveQueryTargets() {
    return this.li.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.li.activeTargetIds.has(t2);
  }
  start() {
    return this.li = new Pr(), Promise.resolve();
  }
  handleUserChange(t2, e, n2) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vr {
  di(t2) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sr {
  constructor() {
    this.wi = () => this._i(), this.mi = () => this.gi(), this.yi = [], this.pi();
  }
  di(t2) {
    this.yi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.wi), window.removeEventListener("offline", this.mi);
  }
  pi() {
    window.addEventListener("online", this.wi), window.addEventListener("offline", this.mi);
  }
  _i() {
    D("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.yi)
      t2(0);
  }
  gi() {
    D("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.yi)
      t2(1);
  }
  static gt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Dr = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cr {
  constructor(t2) {
    this.Ei = t2.Ei, this.Ti = t2.Ti;
  }
  Ii(t2) {
    this.Ai = t2;
  }
  Ri(t2) {
    this.Pi = t2;
  }
  onMessage(t2) {
    this.bi = t2;
  }
  close() {
    this.Ti();
  }
  send(t2) {
    this.Ei(t2);
  }
  vi() {
    this.Ai();
  }
  Vi(t2) {
    this.Pi(t2);
  }
  Si(t2) {
    this.bi(t2);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Nr extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Di = e + "://" + t2.host, this.Ci = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Ni(t2, e, n2, s) {
    const i = this.xi(t2, e);
    D("RestConnection", "Sending: ", i, n2);
    const r2 = {};
    return this.ki(r2, s), this.Oi(t2, i, r2, n2).then((t3) => (D("RestConnection", "Received: ", t3), t3), (e2) => {
      throw N("RestConnection", `${t2} failed with error: `, e2, "url: ", i, "request:", n2), e2;
    });
  }
  $i(t2, e, n2, s) {
    return this.Ni(t2, e, n2, s);
  }
  ki(t2, e) {
    if (t2["X-Goog-Api-Client"] = "gl-js/ fire/8.4.1", t2["X-Firebase-GMPID"] = this.databaseInfo.appId, t2["Content-Type"] = "text/plain", e)
      for (const n2 in e.authHeaders)
        e.authHeaders.hasOwnProperty(n2) && (t2[n2] = e.authHeaders[n2]);
  }
  xi(t2, e) {
    const n2 = Dr[t2];
    return `${this.Di}/v1/${e}:${n2}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling;
  }
  Oi(t2, e, n2, s) {
    return new Promise((i, r2) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              D("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              D("Connection", 'RPC "' + t2 + '" timed out'), r2(new b(P.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n3 = o.getStatus();
              if (D("Connection", 'RPC "' + t2 + '" failed with status:', n3, "response text:", o.getResponseText()), n3 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(P).indexOf(e4) >= 0 ? e4 : P.UNKNOWN;
                  }(t3.status);
                  r2(new b(e3, t3.message));
                } else
                  r2(new b(P.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r2(new b(P.UNAVAILABLE, "Connection failed."));
              break;
            default:
              k();
          }
        } finally {
          D("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const c = JSON.stringify(s);
      o.send(e, "POST", c, n2, 15);
    });
  }
  Mi(t2, e) {
    const n2 = [this.Di, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], s = createWebChannelTransport(), i = getStatEventTarget(), r2 = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.ki(r2.initMessageHeaders, e), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (r2.httpHeadersOverwriteParam = "$httpHeaders");
    const o = n2.join("");
    D("Connection", "Creating WebChannel: " + o, r2);
    const c = s.createWebChannel(o, r2);
    let u = false, _ = false;
    const m = new Cr({
      Ei: (t3) => {
        _ ? D("Connection", "Not sending because WebChannel is closed:", t3) : (u || (D("Connection", "Opening WebChannel transport."), c.open(), u = true), D("Connection", "WebChannel sending:", t3), c.send(t3));
      },
      Ti: () => c.close()
    }), g = (t3, e2, n3) => {
      t3.listen(e2, (t4) => {
        try {
          n3(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return g(c, WebChannel.EventType.OPEN, () => {
      _ || D("Connection", "WebChannel transport opened.");
    }), g(c, WebChannel.EventType.CLOSE, () => {
      _ || (_ = true, D("Connection", "WebChannel transport closed"), m.Vi());
    }), g(c, WebChannel.EventType.ERROR, (t3) => {
      _ || (_ = true, N("Connection", "WebChannel transport errored:", t3), m.Vi(new b(P.UNAVAILABLE, "The operation could not be completed")));
    }), g(c, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!_) {
        const n3 = t3.data[0];
        O(!!n3);
        const s2 = n3, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          D("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = je[t5];
            if (e4 !== void 0)
              return ze(e4);
          }(t4), n4 = i2.message;
          e3 === void 0 && (e3 = P.INTERNAL, n4 = "Unknown error status: " + t4 + " with message " + i2.message), _ = true, m.Vi(new b(e3, n4)), c.close();
        } else
          D("Connection", "WebChannel received:", n3), m.Si(n3);
      }
    }), g(i, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? D("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && D("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      m.vi();
    }, 0), m;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xr() {
  return typeof window != "undefined" ? window : null;
}
function kr() {
  return typeof document != "undefined" ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Or(t2) {
  return new In(t2, true);
}
class $r {
  constructor(t2, e, n2 = 1e3, s = 1.5, i = 6e4) {
    this.Se = t2, this.timerId = e, this.Fi = n2, this.Li = s, this.Bi = i, this.qi = 0, this.Ui = null, this.Ki = Date.now(), this.reset();
  }
  reset() {
    this.qi = 0;
  }
  Qi() {
    this.qi = this.Bi;
  }
  ji(t2) {
    this.cancel();
    const e = Math.floor(this.qi + this.Wi()), n2 = Math.max(0, Date.now() - this.Ki), s = Math.max(0, e - n2);
    s > 0 && D("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.qi} ms, delay with jitter: ${e} ms, last attempt: ${n2} ms ago)`), this.Ui = this.Se.enqueueAfterDelay(this.timerId, s, () => (this.Ki = Date.now(), t2())), this.qi *= this.Li, this.qi < this.Fi && (this.qi = this.Fi), this.qi > this.Bi && (this.qi = this.Bi);
  }
  Gi() {
    this.Ui !== null && (this.Ui.skipDelay(), this.Ui = null);
  }
  cancel() {
    this.Ui !== null && (this.Ui.cancel(), this.Ui = null);
  }
  Wi() {
    return (Math.random() - 0.5) * this.qi;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mr {
  constructor(t2, e, n2, s, i, r2) {
    this.Se = t2, this.zi = n2, this.Hi = s, this.Ji = i, this.listener = r2, this.state = 0, this.Yi = 0, this.Xi = null, this.stream = null, this.Zi = new $r(t2, e);
  }
  tr() {
    return this.state === 1 || this.state === 2 || this.state === 4;
  }
  er() {
    return this.state === 2;
  }
  start() {
    this.state !== 3 ? this.auth() : this.nr();
  }
  async stop() {
    this.tr() && await this.close(0);
  }
  sr() {
    this.state = 0, this.Zi.reset();
  }
  ir() {
    this.er() && this.Xi === null && (this.Xi = this.Se.enqueueAfterDelay(this.zi, 6e4, () => this.rr()));
  }
  cr(t2) {
    this.ur(), this.stream.send(t2);
  }
  async rr() {
    if (this.er())
      return this.close(0);
  }
  ur() {
    this.Xi && (this.Xi.cancel(), this.Xi = null);
  }
  async close(t2, e) {
    this.ur(), this.Zi.cancel(), this.Yi++, t2 !== 3 ? this.Zi.reset() : e && e.code === P.RESOURCE_EXHAUSTED ? (C(e.toString()), C("Using maximum backoff delay to prevent overloading the backend."), this.Zi.Qi()) : e && e.code === P.UNAUTHENTICATED && this.Ji.invalidateToken(), this.stream !== null && (this.ar(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ri(e);
  }
  ar() {
  }
  auth() {
    this.state = 1;
    const t2 = this.hr(this.Yi), e = this.Yi;
    this.Ji.getToken().then((t3) => {
      this.Yi === e && this.lr(t3);
    }, (e2) => {
      t2(() => {
        const t3 = new b(P.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.dr(t3);
      });
    });
  }
  lr(t2) {
    const e = this.hr(this.Yi);
    this.stream = this.wr(t2), this.stream.Ii(() => {
      e(() => (this.state = 2, this.listener.Ii()));
    }), this.stream.Ri((t3) => {
      e(() => this.dr(t3));
    }), this.stream.onMessage((t3) => {
      e(() => this.onMessage(t3));
    });
  }
  nr() {
    this.state = 4, this.Zi.ji(async () => {
      this.state = 0, this.start();
    });
  }
  dr(t2) {
    return D("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(3, t2);
  }
  hr(t2) {
    return (e) => {
      this.Se.enqueueAndForget(() => this.Yi === t2 ? e() : (D("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
}
class Fr extends Mr {
  constructor(t2, e, n2, s, i) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", e, n2, i), this.R = s;
  }
  wr(t2) {
    return this.Hi.Mi("Listen", t2);
  }
  onMessage(t2) {
    this.Zi.reset();
    const e = Fn(this.R, t2), n2 = function(t3) {
      if (!("targetChange" in t3))
        return K.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? K.min() : e2.readTime ? bn(e2.readTime) : K.min();
    }(t2);
    return this.listener._r(e, n2);
  }
  mr(t2) {
    const e = {};
    e.database = xn(this.R), e.addTarget = function(t3, e2) {
      let n3;
      const s = e2.target;
      return n3 = Ct(s) ? {
        documents: Un(t3, s)
      } : {
        query: Kn(t3, s)
      }, n3.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n3.resumeToken = Rn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(K.min()) > 0 && (n3.readTime = An(t3, e2.snapshotVersion.toTimestamp())), n3;
    }(this.R, t2);
    const n2 = jn(this.R, t2);
    n2 && (e.labels = n2), this.cr(e);
  }
  gr(t2) {
    const e = {};
    e.database = xn(this.R), e.removeTarget = t2, this.cr(e);
  }
}
class Lr extends Mr {
  constructor(t2, e, n2, s, i) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", e, n2, i), this.R = s, this.yr = false;
  }
  get pr() {
    return this.yr;
  }
  start() {
    this.yr = false, this.lastStreamToken = void 0, super.start();
  }
  ar() {
    this.yr && this.Er([]);
  }
  wr(t2) {
    return this.Hi.Mi("Write", t2);
  }
  onMessage(t2) {
    if (O(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.yr) {
      this.Zi.reset();
      const e = qn(t2.writeResults, t2.commitTime), n2 = bn(t2.commitTime);
      return this.listener.Tr(n2, e);
    }
    return O(!t2.writeResults || t2.writeResults.length === 0), this.yr = true, this.listener.Ir();
  }
  Ar() {
    const t2 = {};
    t2.database = xn(this.R), this.cr(t2);
  }
  Er(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => Ln(this.R, t3))
    };
    this.cr(e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Br extends class {
} {
  constructor(t2, e, n2) {
    super(), this.credentials = t2, this.Hi = e, this.R = n2, this.Rr = false;
  }
  Pr() {
    if (this.Rr)
      throw new b(P.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Ni(t2, e, n2) {
    return this.Pr(), this.credentials.getToken().then((s) => this.Hi.Ni(t2, e, n2, s)).catch((t3) => {
      throw t3.code === P.UNAUTHENTICATED && this.credentials.invalidateToken(), t3;
    });
  }
  $i(t2, e, n2) {
    return this.Pr(), this.credentials.getToken().then((s) => this.Hi.$i(t2, e, n2, s)).catch((t3) => {
      throw t3.code === P.UNAUTHENTICATED && this.credentials.invalidateToken(), t3;
    });
  }
  terminate() {
    this.Rr = false;
  }
}
class qr {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.br = 0, this.vr = null, this.Vr = true;
  }
  Sr() {
    this.br === 0 && (this.Dr("Unknown"), this.vr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.vr = null, this.Cr("Backend didn't respond within 10 seconds."), this.Dr("Offline"), Promise.resolve())));
  }
  Nr(t2) {
    this.state === "Online" ? this.Dr("Unknown") : (this.br++, this.br >= 1 && (this.kr(), this.Cr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Dr("Offline")));
  }
  set(t2) {
    this.kr(), this.br = 0, t2 === "Online" && (this.Vr = false), this.Dr(t2);
  }
  Dr(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  Cr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.Vr ? (C(e), this.Vr = false) : D("OnlineStateTracker", e);
  }
  kr() {
    this.vr !== null && (this.vr.cancel(), this.vr = null);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ur {
  constructor(t2, e, n2, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n2, this.remoteSyncer = {}, this.Or = [], this.$r = new Map(), this.Mr = new Set(), this.Fr = [], this.Lr = i, this.Lr.di((t3) => {
      n2.enqueueAndForget(async () => {
        Yr(this) && (D("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = $(t4);
          e2.Mr.add(4), await Qr(e2), e2.Br.set("Unknown"), e2.Mr.delete(4), await Kr(e2);
        }(this));
      });
    }), this.Br = new qr(n2, s);
  }
}
async function Kr(t2) {
  if (Yr(t2))
    for (const e of t2.Fr)
      await e(true);
}
async function Qr(t2) {
  for (const e of t2.Fr)
    await e(false);
}
function jr(t2, e) {
  const n2 = $(t2);
  n2.$r.has(e.targetId) || (n2.$r.set(e.targetId, e), Jr(n2) ? Hr(n2) : _o(n2).er() && Gr(n2, e));
}
function Wr(t2, e) {
  const n2 = $(t2), s = _o(n2);
  n2.$r.delete(e), s.er() && zr(n2, e), n2.$r.size === 0 && (s.er() ? s.ir() : Yr(n2) && n2.Br.set("Unknown"));
}
function Gr(t2, e) {
  t2.qr.U(e.targetId), _o(t2).mr(e);
}
function zr(t2, e) {
  t2.qr.U(e), _o(t2).gr(e);
}
function Hr(t2) {
  t2.qr = new gn({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    lt: (e) => t2.$r.get(e) || null
  }), _o(t2).start(), t2.Br.Sr();
}
function Jr(t2) {
  return Yr(t2) && !_o(t2).tr() && t2.$r.size > 0;
}
function Yr(t2) {
  return $(t2).Mr.size === 0;
}
function Xr(t2) {
  t2.qr = void 0;
}
async function Zr(t2) {
  t2.$r.forEach((e, n2) => {
    Gr(t2, e);
  });
}
async function to(t2, e) {
  Xr(t2), Jr(t2) ? (t2.Br.Nr(e), Hr(t2)) : t2.Br.set("Unknown");
}
async function eo(t2, e, n2) {
  if (t2.Br.set("Online"), e instanceof _n && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n3 = e2.cause;
        for (const s of e2.targetIds)
          t3.$r.has(s) && (await t3.remoteSyncer.rejectListen(s, n3), t3.$r.delete(s), t3.qr.removeTarget(s));
      }(t2, e);
    } catch (n3) {
      D("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n3), await no(t2, n3);
    }
  else if (e instanceof dn ? t2.qr.X(e) : e instanceof wn ? t2.qr.rt(e) : t2.qr.et(e), !n2.isEqual(K.min()))
    try {
      const e2 = await Hi(t2.localStore);
      n2.compareTo(e2) >= 0 && await function(t3, e3) {
        const n3 = t3.qr.ut(e3);
        return n3.targetChanges.forEach((n4, s) => {
          if (n4.resumeToken.approximateByteSize() > 0) {
            const i = t3.$r.get(s);
            i && t3.$r.set(s, i.withResumeToken(n4.resumeToken, e3));
          }
        }), n3.targetMismatches.forEach((e4) => {
          const n4 = t3.$r.get(e4);
          if (!n4)
            return;
          t3.$r.set(e4, n4.withResumeToken(X.EMPTY_BYTE_STRING, n4.snapshotVersion)), zr(t3, e4);
          const s = new qs(n4.target, e4, 1, n4.sequenceNumber);
          Gr(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n3);
      }(t2, n2);
    } catch (e2) {
      D("RemoteStore", "Failed to raise snapshot:", e2), await no(t2, e2);
    }
}
async function no(t2, e, n2) {
  if (!Ns(e))
    throw e;
  t2.Mr.add(1), await Qr(t2), t2.Br.set("Offline"), n2 || (n2 = () => Hi(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    D("RemoteStore", "Retrying IndexedDB access"), await n2(), t2.Mr.delete(1), await Kr(t2);
  });
}
function so(t2, e) {
  return e().catch((n2) => no(t2, n2, e));
}
async function io(t2) {
  const e = $(t2), n2 = mo(e);
  let s = e.Or.length > 0 ? e.Or[e.Or.length - 1].batchId : -1;
  for (; ro(e); )
    try {
      const t3 = await Xi(e.localStore, s);
      if (t3 === null) {
        e.Or.length === 0 && n2.ir();
        break;
      }
      s = t3.batchId, oo(e, t3);
    } catch (t3) {
      await no(e, t3);
    }
  co(e) && uo(e);
}
function ro(t2) {
  return Yr(t2) && t2.Or.length < 10;
}
function oo(t2, e) {
  t2.Or.push(e);
  const n2 = mo(t2);
  n2.er() && n2.pr && n2.Er(e.mutations);
}
function co(t2) {
  return Yr(t2) && !mo(t2).tr() && t2.Or.length > 0;
}
function uo(t2) {
  mo(t2).start();
}
async function ao(t2) {
  mo(t2).Ar();
}
async function ho(t2) {
  const e = mo(t2);
  for (const n2 of t2.Or)
    e.Er(n2.mutations);
}
async function lo(t2, e, n2) {
  const s = t2.Or.shift(), i = Bs.from(s, e, n2);
  await so(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await io(t2);
}
async function fo(t2, e) {
  e && mo(t2).pr && await async function(t3, e2) {
    if (n2 = e2.code, Ge(n2) && n2 !== P.ABORTED) {
      const n3 = t3.Or.shift();
      mo(t3).sr(), await so(t3, () => t3.remoteSyncer.rejectFailedWrite(n3.batchId, e2)), await io(t3);
    }
    var n2;
  }(t2, e), co(t2) && uo(t2);
}
async function wo(t2, e) {
  const n2 = $(t2);
  e ? (n2.Mr.delete(2), await Kr(n2)) : e || (n2.Mr.add(2), await Qr(n2), n2.Br.set("Unknown"));
}
function _o(t2) {
  return t2.Ur || (t2.Ur = function(t3, e, n2) {
    const s = $(t3);
    return s.Pr(), new Fr(e, s.Hi, s.credentials, s.R, n2);
  }(t2.datastore, t2.asyncQueue, {
    Ii: Zr.bind(null, t2),
    Ri: to.bind(null, t2),
    _r: eo.bind(null, t2)
  }), t2.Fr.push(async (e) => {
    e ? (t2.Ur.sr(), Jr(t2) ? Hr(t2) : t2.Br.set("Unknown")) : (await t2.Ur.stop(), Xr(t2));
  })), t2.Ur;
}
function mo(t2) {
  return t2.Kr || (t2.Kr = function(t3, e, n2) {
    const s = $(t3);
    return s.Pr(), new Lr(e, s.Hi, s.credentials, s.R, n2);
  }(t2.datastore, t2.asyncQueue, {
    Ii: ao.bind(null, t2),
    Ri: fo.bind(null, t2),
    Ir: ho.bind(null, t2),
    Tr: lo.bind(null, t2)
  }), t2.Fr.push(async (e) => {
    e ? (t2.Kr.sr(), await io(t2)) : (await t2.Kr.stop(), t2.Or.length > 0 && (D("RemoteStore", `Stopping write stream with ${t2.Or.length} pending writes`), t2.Or = []));
  })), t2.Kr;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class go {
  constructor(t2, e, n2, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n2, this.op = s, this.removalCallback = i, this.deferred = new bs(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n2, s, i) {
    const r2 = Date.now() + n2, o = new go(t2, e, r2, s, i);
    return o.start(n2), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new b(P.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function yo(t2, e) {
  if (C("AsyncQueue", `${e}: ${t2}`), Ns(t2))
    return new b(P.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class po {
  constructor(t2) {
    this.comparator = t2 ? (e, n2) => t2(e, n2) || at.comparator(e.key, n2.key) : (t3, e) => at.comparator(t3.key, e.key), this.keyedMap = sn(), this.sortedSet = new He(this.comparator);
  }
  static emptySet(t2) {
    return new po(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n2) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof po))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n2 = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n2.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n2 = new po();
    return n2.comparator = this.comparator, n2.keyedMap = t2, n2.sortedSet = e, n2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Eo {
  constructor() {
    this.Qr = new He(at.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n2 = this.Qr.get(e);
    n2 ? t2.type !== 0 && n2.type === 3 ? this.Qr = this.Qr.insert(e, t2) : t2.type === 3 && n2.type !== 1 ? this.Qr = this.Qr.insert(e, {
      type: n2.type,
      doc: t2.doc
    }) : t2.type === 2 && n2.type === 2 ? this.Qr = this.Qr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n2.type === 0 ? this.Qr = this.Qr.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n2.type === 0 ? this.Qr = this.Qr.remove(e) : t2.type === 1 && n2.type === 2 ? this.Qr = this.Qr.insert(e, {
      type: 1,
      doc: n2.doc
    }) : t2.type === 0 && n2.type === 1 ? this.Qr = this.Qr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : k() : this.Qr = this.Qr.insert(e, t2);
  }
  jr() {
    const t2 = [];
    return this.Qr.inorderTraversal((e, n2) => {
      t2.push(n2);
    }), t2;
  }
}
class To {
  constructor(t2, e, n2, s, i, r2, o, c) {
    this.query = t2, this.docs = e, this.oldDocs = n2, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r2, this.syncStateChanged = o, this.excludesMetadataChanges = c;
  }
  static fromInitialDocuments(t2, e, n2, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new To(t2, e, po.emptySet(e), i, n2, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && re(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n2 = t2.docChanges;
    if (e.length !== n2.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n2[t3].type || !e[t3].doc.isEqual(n2[t3].doc))
        return false;
    return true;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Io {
  constructor() {
    this.Wr = void 0, this.listeners = [];
  }
}
class Ao {
  constructor() {
    this.queries = new vi((t2) => oe(t2), re), this.onlineState = "Unknown", this.Gr = new Set();
  }
}
async function Ro(t2, e) {
  const n2 = $(t2), s = e.query;
  let i = false, r2 = n2.queries.get(s);
  if (r2 || (i = true, r2 = new Io()), i)
    try {
      r2.Wr = await n2.onListen(s);
    } catch (t3) {
      const n3 = yo(t3, `Initialization of query '${ce(e.query)}' failed`);
      return void e.onError(n3);
    }
  n2.queries.set(s, r2), r2.listeners.push(e);
  e.zr(n2.onlineState);
  if (r2.Wr) {
    e.Hr(r2.Wr) && Vo(n2);
  }
}
async function Po(t2, e) {
  const n2 = $(t2), s = e.query;
  let i = false;
  const r2 = n2.queries.get(s);
  if (r2) {
    const t3 = r2.listeners.indexOf(e);
    t3 >= 0 && (r2.listeners.splice(t3, 1), i = r2.listeners.length === 0);
  }
  if (i)
    return n2.queries.delete(s), n2.onUnlisten(s);
}
function bo(t2, e) {
  const n2 = $(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n2.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Hr(t3) && (s = true);
      i.Wr = t3;
    }
  }
  s && Vo(n2);
}
function vo(t2, e, n2) {
  const s = $(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n2);
  s.queries.delete(e);
}
function Vo(t2) {
  t2.Gr.forEach((t3) => {
    t3.next();
  });
}
class So {
  constructor(t2, e, n2) {
    this.query = t2, this.Jr = e, this.Yr = false, this.Xr = null, this.onlineState = "Unknown", this.options = n2 || {};
  }
  Hr(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n2 of t2.docChanges)
        n2.type !== 3 && e2.push(n2);
      t2 = new To(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.Yr ? this.Zr(t2) && (this.Jr.next(t2), e = true) : this.eo(t2, this.onlineState) && (this.no(t2), e = true), this.Xr = t2, e;
  }
  onError(t2) {
    this.Jr.error(t2);
  }
  zr(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Xr && !this.Yr && this.eo(this.Xr, t2) && (this.no(this.Xr), e = true), e;
  }
  eo(t2, e) {
    if (!t2.fromCache)
      return true;
    const n2 = e !== "Offline";
    return (!this.options.so || !n2) && (!t2.docs.isEmpty() || e === "Offline");
  }
  Zr(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Xr && this.Xr.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  no(t2) {
    t2 = To.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.Yr = true, this.Jr.next(t2);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Do {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  io() {
    return "metadata" in this.payload;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Co {
  constructor(t2) {
    this.R = t2;
  }
  qn(t2) {
    return Dn(this.R, t2);
  }
  Un(t2) {
    return t2.metadata.exists ? $n(this.R, t2.document, false) : Pt.newNoDocument(this.qn(t2.metadata.name), this.Kn(t2.metadata.readTime));
  }
  Kn(t2) {
    return bn(t2);
  }
}
class No {
  constructor(t2, e, n2) {
    this.ro = t2, this.localStore = e, this.R = n2, this.queries = [], this.documents = [], this.progress = xo(t2);
  }
  oo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  co(t2) {
    const e = new Map(), n2 = new Co(this.R);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n2.qn(s.metadata.name);
        for (const n3 of s.metadata.queries) {
          const s2 = (e.get(n3) || un()).add(t3);
          e.set(n3, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await rr(this.localStore, new Co(this.R), this.documents, this.ro.id), e = this.co(this.documents);
    for (const t3 of this.queries)
      await or(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new qi(Object.assign({}, this.progress), t2);
  }
}
function xo(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ko {
  constructor(t2) {
    this.key = t2;
  }
}
class Oo {
  constructor(t2) {
    this.key = t2;
  }
}
class $o {
  constructor(t2, e) {
    this.query = t2, this.uo = e, this.ao = null, this.current = false, this.ho = un(), this.mutatedKeys = un(), this.lo = ae(t2), this.fo = new po(this.lo);
  }
  get wo() {
    return this.uo;
  }
  _o(t2, e) {
    const n2 = e ? e.mo : new Eo(), s = e ? e.fo : this.fo;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r2 = s, o = false;
    const c = Yt(this.query) && s.size === this.query.limit ? s.last() : null, u = Xt(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const a = s.get(t3), h2 = ue(this.query, e2) ? e2 : null, l = !!a && this.mutatedKeys.has(a.key), f = !!h2 && (h2.hasLocalMutations || this.mutatedKeys.has(h2.key) && h2.hasCommittedMutations);
      let d2 = false;
      if (a && h2) {
        a.data.isEqual(h2.data) ? l !== f && (n2.track({
          type: 3,
          doc: h2
        }), d2 = true) : this.yo(a, h2) || (n2.track({
          type: 2,
          doc: h2
        }), d2 = true, (c && this.lo(h2, c) > 0 || u && this.lo(h2, u) < 0) && (o = true));
      } else
        !a && h2 ? (n2.track({
          type: 0,
          doc: h2
        }), d2 = true) : a && !h2 && (n2.track({
          type: 1,
          doc: a
        }), d2 = true, (c || u) && (o = true));
      d2 && (h2 ? (r2 = r2.add(h2), i = f ? i.add(t3) : i.delete(t3)) : (r2 = r2.delete(t3), i = i.delete(t3)));
    }), Yt(this.query) || Xt(this.query))
      for (; r2.size > this.query.limit; ) {
        const t3 = Yt(this.query) ? r2.last() : r2.first();
        r2 = r2.delete(t3.key), i = i.delete(t3.key), n2.track({
          type: 1,
          doc: t3
        });
      }
    return {
      fo: r2,
      mo: n2,
      Nn: o,
      mutatedKeys: i
    };
  }
  yo(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n2) {
    const s = this.fo;
    this.fo = t2.fo, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.mo.jr();
    i.sort((t3, e2) => function(t4, e3) {
      const n3 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return k();
        }
      };
      return n3(t4) - n3(e3);
    }(t3.type, e2.type) || this.lo(t3.doc, e2.doc)), this.po(n2);
    const r2 = e ? this.Eo() : [], o = this.ho.size === 0 && this.current ? 1 : 0, c = o !== this.ao;
    if (this.ao = o, i.length !== 0 || c) {
      return {
        snapshot: new To(this.query, t2.fo, s, i, t2.mutatedKeys, o === 0, c, false),
        To: r2
      };
    }
    return {
      To: r2
    };
  }
  zr(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      fo: this.fo,
      mo: new Eo(),
      mutatedKeys: this.mutatedKeys,
      Nn: false
    }, false)) : {
      To: []
    };
  }
  Io(t2) {
    return !this.uo.has(t2) && (!!this.fo.has(t2) && !this.fo.get(t2).hasLocalMutations);
  }
  po(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.uo = this.uo.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.uo = this.uo.delete(t3)), this.current = t2.current);
  }
  Eo() {
    if (!this.current)
      return [];
    const t2 = this.ho;
    this.ho = un(), this.fo.forEach((t3) => {
      this.Io(t3.key) && (this.ho = this.ho.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.ho.has(t3) || e.push(new Oo(t3));
    }), this.ho.forEach((n2) => {
      t2.has(n2) || e.push(new ko(n2));
    }), e;
  }
  Ao(t2) {
    this.uo = t2.Bn, this.ho = un();
    const e = this._o(t2.documents);
    return this.applyChanges(e, true);
  }
  Ro() {
    return To.fromInitialDocuments(this.query, this.fo, this.mutatedKeys, this.ao === 0);
  }
}
class Mo {
  constructor(t2, e, n2) {
    this.query = t2, this.targetId = e, this.view = n2;
  }
}
class Fo {
  constructor(t2) {
    this.key = t2, this.Po = false;
  }
}
class Lo {
  constructor(t2, e, n2, s, i, r2) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n2, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r2, this.bo = {}, this.vo = new vi((t3) => oe(t3), re), this.Vo = new Map(), this.So = new Set(), this.Do = new He(at.comparator), this.Co = new Map(), this.No = new ur(), this.xo = {}, this.ko = new Map(), this.Oo = _i.Yt(), this.onlineState = "Unknown", this.$o = void 0;
  }
  get isPrimaryClient() {
    return this.$o === true;
  }
}
async function Bo(t2, e) {
  const n2 = _c(t2);
  let s, i;
  const r2 = n2.vo.get(e);
  if (r2)
    s = r2.targetId, n2.sharedClientState.addLocalQueryTarget(s), i = r2.view.Ro();
  else {
    const t3 = await Zi(n2.localStore, se(e)), r3 = n2.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await qo(n2, e, s, r3 === "current"), n2.isPrimaryClient && jr(n2.remoteStore, t3);
  }
  return i;
}
async function qo(t2, e, n2, s) {
  t2.Mo = (e2, n3, s2) => async function(t3, e3, n4, s3) {
    let i2 = e3.view._o(n4);
    i2.Nn && (i2 = await er(t3.localStore, e3.query, false).then(({documents: t4}) => e3.view._o(t4, i2)));
    const r3 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r3);
    return tc(t3, e3.targetId, o2.To), o2.snapshot;
  }(t2, e2, n3, s2);
  const i = await er(t2.localStore, e, true), r2 = new $o(e, i.Bn), o = r2._o(i.documents), c = fn.createSynthesizedTargetChangeForCurrentChange(n2, s && t2.onlineState !== "Offline"), u = r2.applyChanges(o, t2.isPrimaryClient, c);
  tc(t2, n2, u.To);
  const a = new Mo(e, n2, r2);
  return t2.vo.set(e, a), t2.Vo.has(n2) ? t2.Vo.get(n2).push(e) : t2.Vo.set(n2, [e]), u.snapshot;
}
async function Uo(t2, e) {
  const n2 = $(t2), s = n2.vo.get(e), i = n2.Vo.get(s.targetId);
  if (i.length > 1)
    return n2.Vo.set(s.targetId, i.filter((t3) => !re(t3, e))), void n2.vo.delete(e);
  if (n2.isPrimaryClient) {
    n2.sharedClientState.removeLocalQueryTarget(s.targetId);
    n2.sharedClientState.isActiveQueryTarget(s.targetId) || await tr(n2.localStore, s.targetId, false).then(() => {
      n2.sharedClientState.clearQueryState(s.targetId), Wr(n2.remoteStore, s.targetId), Xo(n2, s.targetId);
    }).catch(Ei);
  } else
    Xo(n2, s.targetId), await tr(n2.localStore, s.targetId, true);
}
async function Ko(t2, e, n2) {
  const s = mc(t2);
  try {
    const t3 = await function(t4, e2) {
      const n3 = $(t4), s2 = U.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), un());
      let r2;
      return n3.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n3.Fn.pn(t5, i).next((i2) => {
        r2 = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = ke(t6, r2.get(t6.key));
          e3 != null && o.push(new Fe(t6.key, e3, Rt(e3.toProto().mapValue), Se.exists(true)));
        }
        return n3._n.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r2), {
        batchId: t5.batchId,
        changes: r2
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n3) {
      let s2 = t4.xo[t4.currentUser.toKey()];
      s2 || (s2 = new He(L));
      s2 = s2.insert(e2, n3), t4.xo[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n2), await sc(s, t3.changes), await io(s.remoteStore);
  } catch (t3) {
    const e2 = yo(t3, "Failed to persist write");
    n2.reject(e2);
  }
}
async function Qo(t2, e) {
  const n2 = $(t2);
  try {
    const t3 = await Ji(n2.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n2.Co.get(e2);
      s && (O(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Po = true : t4.modifiedDocuments.size > 0 ? O(s.Po) : t4.removedDocuments.size > 0 && (O(s.Po), s.Po = false));
    }), await sc(n2, t3, e);
  } catch (t3) {
    await Ei(t3);
  }
}
function jo(t2, e, n2) {
  const s = $(t2);
  if (s.isPrimaryClient && n2 === 0 || !s.isPrimaryClient && n2 === 1) {
    const t3 = [];
    s.vo.forEach((n3, s2) => {
      const i = s2.view.zr(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n3 = $(t4);
      n3.onlineState = e2;
      let s2 = false;
      n3.queries.forEach((t5, n4) => {
        for (const t6 of n4.listeners)
          t6.zr(e2) && (s2 = true);
      }), s2 && Vo(n3);
    }(s.eventManager, e), t3.length && s.bo._r(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function Wo(t2, e, n2) {
  const s = $(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n2);
  const i = s.Co.get(e), r2 = i && i.key;
  if (r2) {
    let t3 = new He(at.comparator);
    t3 = t3.insert(r2, Pt.newNoDocument(r2, K.min()));
    const n3 = un().add(r2), i2 = new ln(K.min(), new Map(), new Xe(L), t3, n3);
    await Qo(s, i2), s.Do = s.Do.remove(r2), s.Co.delete(e), nc(s);
  } else
    await tr(s.localStore, e, false).then(() => Xo(s, e, n2)).catch(Ei);
}
async function Go(t2, e) {
  const n2 = $(t2), s = e.batch.batchId;
  try {
    const t3 = await zi(n2.localStore, e);
    Yo(n2, s, null), Jo(n2, s), n2.sharedClientState.updateMutationState(s, "acknowledged"), await sc(n2, t3);
  } catch (t3) {
    await Ei(t3);
  }
}
async function zo(t2, e, n2) {
  const s = $(t2);
  try {
    const t3 = await function(t4, e2) {
      const n3 = $(t4);
      return n3.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n3._n.lookupMutationBatch(t5, e2).next((e3) => (O(e3 !== null), s2 = e3.keys(), n3._n.removeMutationBatch(t5, e3))).next(() => n3._n.performConsistencyCheck(t5)).next(() => n3.Fn.pn(t5, s2));
      });
    }(s.localStore, e);
    Yo(s, e, n2), Jo(s, e), s.sharedClientState.updateMutationState(e, "rejected", n2), await sc(s, t3);
  } catch (n3) {
    await Ei(n3);
  }
}
async function Ho(t2, e) {
  const n2 = $(t2);
  Yr(n2.remoteStore) || D("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = $(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2._n.getHighestUnacknowledgedBatchId(t5));
    }(n2.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n2.ko.get(t3) || [];
    s.push(e), n2.ko.set(t3, s);
  } catch (t3) {
    const n3 = yo(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n3);
  }
}
function Jo(t2, e) {
  (t2.ko.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.ko.delete(e);
}
function Yo(t2, e, n2) {
  const s = $(t2);
  let i = s.xo[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n2 ? t3.reject(n2) : t3.resolve(), i = i.remove(e)), s.xo[s.currentUser.toKey()] = i;
  }
}
function Xo(t2, e, n2 = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.Vo.get(e))
    t2.vo.delete(s), n2 && t2.bo.Fo(s, n2);
  if (t2.Vo.delete(e), t2.isPrimaryClient) {
    t2.No.Zn(e).forEach((e2) => {
      t2.No.containsKey(e2) || Zo(t2, e2);
    });
  }
}
function Zo(t2, e) {
  t2.So.delete(e.path.canonicalString());
  const n2 = t2.Do.get(e);
  n2 !== null && (Wr(t2.remoteStore, n2), t2.Do = t2.Do.remove(e), t2.Co.delete(n2), nc(t2));
}
function tc(t2, e, n2) {
  for (const s of n2)
    if (s instanceof ko)
      t2.No.addReference(s.key, e), ec(t2, s);
    else if (s instanceof Oo) {
      D("SyncEngine", "Document no longer in limbo: " + s.key), t2.No.removeReference(s.key, e);
      t2.No.containsKey(s.key) || Zo(t2, s.key);
    } else
      k();
}
function ec(t2, e) {
  const n2 = e.key, s = n2.path.canonicalString();
  t2.Do.get(n2) || t2.So.has(s) || (D("SyncEngine", "New document in limbo: " + n2), t2.So.add(s), nc(t2));
}
function nc(t2) {
  for (; t2.So.size > 0 && t2.Do.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.So.values().next().value;
    t2.So.delete(e);
    const n2 = new at(z.fromString(e)), s = t2.Oo.next();
    t2.Co.set(s, new Fo(n2)), t2.Do = t2.Do.insert(n2, s), jr(t2.remoteStore, new qs(se(Jt(n2.path)), s, 2, R.o));
  }
}
async function sc(t2, e, n2) {
  const s = $(t2), i = [], r2 = [], o = [];
  s.vo.isEmpty() || (s.vo.forEach((t3, c) => {
    o.push(s.Mo(c, e, n2).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(c.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = Ki.vn(c.targetId, t4);
        r2.push(e2);
      }
    }));
  }), await Promise.all(o), s.bo._r(i), await async function(t3, e2) {
    const n3 = $(t3);
    try {
      await n3.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => vs.forEach(e2, (e3) => vs.forEach(e3.Pn, (s2) => n3.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => vs.forEach(e3.bn, (s2) => n3.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Ns(t4))
        throw t4;
      D("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n3.kn.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n3.kn = n3.kn.insert(e3, i2);
      }
    }
  }(s.localStore, r2));
}
async function ic(t2, e) {
  const n2 = $(t2);
  if (!n2.currentUser.isEqual(e)) {
    D("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await Gi(n2.localStore, e);
    n2.currentUser = e, function(t4, e2) {
      t4.ko.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new b(P.CANCELLED, e2));
        });
      }), t4.ko.clear();
    }(n2, "'waitForPendingWrites' promise is rejected due to a user change."), n2.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await sc(n2, t3.Ln);
  }
}
function rc(t2, e) {
  const n2 = $(t2), s = n2.Co.get(e);
  if (s && s.Po)
    return un().add(s.key);
  {
    let t3 = un();
    const s2 = n2.Vo.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n2.vo.get(e2);
      t3 = t3.unionWith(s3.view.wo);
    }
    return t3;
  }
}
async function oc(t2, e) {
  const n2 = $(t2), s = await er(n2.localStore, e.query, true), i = e.view.Ao(s);
  return n2.isPrimaryClient && tc(n2, e.targetId, i.To), i;
}
async function cc(t2) {
  const e = $(t2);
  return sr(e.localStore).then((t3) => sc(e, t3));
}
async function uc(t2, e, n2, s) {
  const i = $(t2), r2 = await function(t3, e2) {
    const n3 = $(t3), s2 = $(n3._n);
    return n3.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.jt(t4, e2).next((e3) => e3 ? n3.Fn.pn(t4, e3) : vs.resolve(null)));
  }(i.localStore, e);
  r2 !== null ? (n2 === "pending" ? await io(i.remoteStore) : n2 === "acknowledged" || n2 === "rejected" ? (Yo(i, e, s || null), Jo(i, e), function(t3, e2) {
    $($(t3)._n).Gt(e2);
  }(i.localStore, e)) : k(), await sc(i, r2)) : D("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function ac(t2, e) {
  const n2 = $(t2);
  if (_c(n2), mc(n2), e === true && n2.$o !== true) {
    const t3 = n2.sharedClientState.getAllActiveQueryTargets(), e2 = await hc(n2, t3.toArray());
    n2.$o = true, await wo(n2.remoteStore, true);
    for (const t4 of e2)
      jr(n2.remoteStore, t4);
  } else if (e === false && n2.$o !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n2.Vo.forEach((s, i) => {
      n2.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (Xo(n2, i), tr(n2.localStore, i, true))), Wr(n2.remoteStore, i);
    }), await e2, await hc(n2, t3), function(t4) {
      const e3 = $(t4);
      e3.Co.forEach((t5, n3) => {
        Wr(e3.remoteStore, n3);
      }), e3.No.ts(), e3.Co = new Map(), e3.Do = new He(at.comparator);
    }(n2), n2.$o = false, await wo(n2.remoteStore, false);
  }
}
async function hc(t2, e, n2) {
  const s = $(t2), i = [], r2 = [];
  for (const t3 of e) {
    let e2;
    const n3 = s.Vo.get(t3);
    if (n3 && n3.length !== 0) {
      e2 = await Zi(s.localStore, se(n3[0]));
      for (const t4 of n3) {
        const e3 = s.vo.get(t4), n4 = await oc(s, e3);
        n4.snapshot && r2.push(n4.snapshot);
      }
    } else {
      const n4 = await nr(s.localStore, t3);
      e2 = await Zi(s.localStore, n4), await qo(s, lc(n4), t3, false);
    }
    i.push(e2);
  }
  return s.bo._r(r2), i;
}
function lc(t2) {
  return Ht(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function fc(t2) {
  const e = $(t2);
  return $($(e.localStore).persistence).fn();
}
async function dc(t2, e, n2, s) {
  const i = $(t2);
  if (i.$o)
    D("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.Vo.has(e))
    switch (n2) {
      case "current":
      case "not-current": {
        const t3 = await sr(i.localStore), s2 = ln.createSynthesizedRemoteEventForCurrentChange(e, n2 === "current");
        await sc(i, t3, s2);
        break;
      }
      case "rejected":
        await tr(i.localStore, e, true), Xo(i, e, s);
        break;
      default:
        k();
    }
}
async function wc(t2, e, n2) {
  const s = _c(t2);
  if (s.$o) {
    for (const t3 of e) {
      if (s.Vo.has(t3)) {
        D("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await nr(s.localStore, t3), n3 = await Zi(s.localStore, e2);
      await qo(s, lc(e2), n3.targetId, false), jr(s.remoteStore, n3);
    }
    for (const t3 of n2)
      s.Vo.has(t3) && await tr(s.localStore, t3, false).then(() => {
        Wr(s.remoteStore, t3), Xo(s, t3);
      }).catch(Ei);
  }
}
function _c(t2) {
  const e = $(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Qo.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = rc.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = Wo.bind(null, e), e.bo._r = bo.bind(null, e.eventManager), e.bo.Fo = vo.bind(null, e.eventManager), e;
}
function mc(t2) {
  const e = $(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = Go.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = zo.bind(null, e), e;
}
function gc(t2, e, n2) {
  const s = $(t2);
  (async function(t3, e2, n3) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n4 = $(t4), s3 = bn(e3.createTime);
        return n4.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n4.Ke.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n3._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n3._updateProgress(xo(s2));
      const i = new No(s2, t3.localStore, e2.R);
      let r2 = await e2.Lo();
      for (; r2; ) {
        const t4 = await i.oo(r2);
        t4 && n3._updateProgress(t4), r2 = await e2.Lo();
      }
      const o = await i.complete();
      await sc(t3, o.wn, void 0), await function(t4, e3) {
        const n4 = $(t4);
        return n4.persistence.runTransaction("Save bundle", "readwrite", (t5) => n4.Ke.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n3._completeWith(o.progress);
    } catch (t4) {
      N("SyncEngine", `Loading bundle failed with ${t4}`), n3._failWith(t4);
    }
  })(s, e, n2).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
class yc {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.R = Or(t2.databaseInfo.databaseId), this.sharedClientState = this.Bo(t2), this.persistence = this.qo(t2), await this.persistence.start(), this.gcScheduler = this.Uo(t2), this.localStore = this.Ko(t2);
  }
  Uo(t2) {
    return null;
  }
  Ko(t2) {
    return Wi(this.persistence, new Qi(), t2.initialUser, this.R);
  }
  qo(t2) {
    return new wr(mr.Ps, this.R);
  }
  Bo(t2) {
    return new vr();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
}
class pc extends yc {
  constructor(t2, e, n2) {
    super(), this.Qo = t2, this.cacheSizeBytes = e, this.forceOwnership = n2, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await ir(this.localStore), await this.Qo.initialize(this, t2), await mc(this.Qo.syncEngine), await io(this.Qo.remoteStore);
  }
  Ko(t2) {
    return Wi(this.persistence, new Qi(), t2.initialUser, this.R);
  }
  Uo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Ai(e, t2.asyncQueue);
  }
  qo(t2) {
    const e = Bi(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n2 = this.cacheSizeBytes !== void 0 ? ci.withCacheSize(this.cacheSizeBytes) : ci.DEFAULT;
    return new Mi(this.synchronizeTabs, e, t2.clientId, n2, t2.asyncQueue, xr(), kr(), this.R, this.sharedClientState, !!this.forceOwnership);
  }
  Bo(t2) {
    return new vr();
  }
}
class Ec extends pc {
  constructor(t2, e) {
    super(t2, e, false), this.Qo = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.Qo.syncEngine;
    this.sharedClientState instanceof br && (this.sharedClientState.syncEngine = {
      ui: uc.bind(null, e),
      ai: dc.bind(null, e),
      hi: wc.bind(null, e),
      fn: fc.bind(null, e),
      ci: cc.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.He(async (t3) => {
      await ac(this.Qo.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Bo(t2) {
    const e = xr();
    if (!br.gt(e))
      throw new b(P.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n2 = Bi(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new br(e, t2.asyncQueue, n2, t2.clientId, t2.initialUser);
  }
}
class Tc {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => jo(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = ic.bind(null, this.syncEngine), await wo(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Ao();
  }
  createDatastore(t2) {
    const e = Or(t2.databaseInfo.databaseId), n2 = (s = t2.databaseInfo, new Nr(s));
    var s;
    return function(t3, e2, n3) {
      return new Br(t3, e2, n3);
    }(t2.credentials, n2, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n2 = this.datastore, s = t2.asyncQueue, i = (t3) => jo(this.syncEngine, t3, 0), r2 = Sr.gt() ? new Sr() : new Vr(), new Ur(e, n2, s, i, r2);
    var e, n2, s, i, r2;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n2, s, i, r2, o) {
      const c = new Lo(t3, e2, n2, s, i, r2);
      return o && (c.$o = true), c;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = $(t2);
      D("RemoteStore", "RemoteStore shutting down."), e.Mr.add(5), await Qr(e), e.Lr.shutdown(), e.Br.set("Unknown");
    }(this.remoteStore);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ic(t2, e = 10240) {
  let n2 = 0;
  return {
    async read() {
      if (n2 < t2.byteLength) {
        const s = {
          value: t2.slice(n2, n2 + e),
          done: false
        };
        return n2 += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ac {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.jo(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.jo(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Wo() {
    this.muted = true;
  }
  jo(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Rc {
  constructor(t2, e) {
    this.Go = t2, this.R = e, this.metadata = new bs(), this.buffer = new Uint8Array(), this.zo = new TextDecoder("utf-8"), this.Ho().then((t3) => {
      t3 && t3.io() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Go.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Lo() {
    return await this.getMetadata(), this.Ho();
  }
  async Ho() {
    const t2 = await this.Jo();
    if (t2 === null)
      return null;
    const e = this.zo.decode(t2), n2 = Number(e);
    isNaN(n2) && this.Yo(`length string (${e}) is not valid number`);
    const s = await this.Xo(n2);
    return new Do(JSON.parse(s), t2.length + n2);
  }
  Zo() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Jo() {
    for (; this.Zo() < 0; ) {
      if (await this.tc())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.Zo();
    t2 < 0 && this.Yo("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async Xo(t2) {
    for (; this.buffer.length < t2; ) {
      await this.tc() && this.Yo("Reached the end of bundle when more is expected.");
    }
    const e = this.zo.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Yo(t2) {
    throw this.Go.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async tc() {
    const t2 = await this.Go.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pc {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new b(P.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n2 = $(t3), s = xn(n2.R) + "/documents", i = {
        documents: e2.map((t4) => Sn(n2.R, t4))
      }, r2 = await n2.$i("BatchGetDocuments", s, i), o = new Map();
      r2.forEach((t4) => {
        const e3 = Mn(n2.R, t4);
        o.set(e3.key.toString(), e3);
      });
      const c = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        O(!!e3), c.push(e3);
      }), c;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new Ue(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n2 = at.fromPath(e);
      this.mutations.push(new Ke(n2, this.precondition(n2)));
    }), await async function(t3, e) {
      const n2 = $(t3), s = xn(n2.R) + "/documents", i = {
        writes: e.map((t4) => Ln(n2.R, t4))
      };
      await n2.Ni("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw k();
      e = K.min();
    }
    const n2 = this.readVersions.get(t2.key.toString());
    if (n2) {
      if (!e.isEqual(n2))
        throw new b(P.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? Se.updateTime(e) : Se.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(K.min()))
        throw new b(P.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return Se.updateTime(e);
    }
    return Se.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bc {
  constructor(t2, e, n2, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n2, this.deferred = s, this.ec = 5, this.Zi = new $r(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.nc();
  }
  nc() {
    this.Zi.ji(async () => {
      const t2 = new Pc(this.datastore), e = this.sc(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.ic(t3);
        }));
      }).catch((t3) => {
        this.ic(t3);
      });
    });
  }
  sc(t2) {
    try {
      const e = this.updateFunction(t2);
      return !ot(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  ic(t2) {
    this.ec > 0 && this.rc(t2) ? (this.ec -= 1, this.asyncQueue.enqueueAndForget(() => (this.nc(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  rc(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !Ge(e);
    }
    return false;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vc {
  constructor(t2, e, n2) {
    this.credentials = t2, this.asyncQueue = e, this.databaseInfo = n2, this.user = gr.UNAUTHENTICATED, this.clientId = F.u(), this.credentialListener = () => {
    }, this.receivedInitialUser = new bs(), this.credentials.setChangeListener((t3) => {
      D("FirestoreClient", "Received user=", t3.uid), this.user = t3, this.credentialListener(t3), this.receivedInitialUser.resolve();
    });
  }
  async getConfiguration() {
    return await this.receivedInitialUser.promise, {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      credentials: this.credentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.credentialListener = t2, this.receivedInitialUser.promise.then(() => this.credentialListener(this.user));
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new b(P.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new bs();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.credentials.removeChangeListener(), t2.resolve();
      } catch (e) {
        const n2 = yo(e, "Failed to shutdown persistence");
        t2.reject(n2);
      }
    }), t2.promise;
  }
}
async function Vc(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), D("FirestoreClient", "Initializing OfflineComponentProvider");
  const n2 = await t2.getConfiguration();
  await e.initialize(n2);
  let s = n2.initialUser;
  t2.setCredentialChangeListener((n3) => {
    s.isEqual(n3) || (s = n3, t2.asyncQueue.enqueueRetryable(async () => {
      await Gi(e.localStore, n3);
    }));
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Sc(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n2 = await Dc(t2);
  D("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n2, s), t2.setCredentialChangeListener((n3) => t2.asyncQueue.enqueueRetryable(() => async function(t3, e2) {
    const n4 = $(t3);
    n4.asyncQueue.verifyOperationInProgress(), D("RemoteStore", "RemoteStore received new credentials");
    const s2 = Yr(n4);
    n4.Mr.add(3), await Qr(n4), s2 && n4.Br.set("Unknown"), await n4.remoteSyncer.handleCredentialChange(e2), n4.Mr.delete(3), await Kr(n4);
  }(e.remoteStore, n3))), t2.onlineComponents = e;
}
async function Dc(t2) {
  return t2.offlineComponents || (D("FirestoreClient", "Using default OfflineComponentProvider"), await Vc(t2, new yc())), t2.offlineComponents;
}
async function Cc(t2) {
  return t2.onlineComponents || (D("FirestoreClient", "Using default OnlineComponentProvider"), await Sc(t2, new Tc())), t2.onlineComponents;
}
function Nc(t2) {
  return Dc(t2).then((t3) => t3.persistence);
}
function xc(t2) {
  return Dc(t2).then((t3) => t3.localStore);
}
function kc(t2) {
  return Cc(t2).then((t3) => t3.remoteStore);
}
function Oc(t2) {
  return Cc(t2).then((t3) => t3.syncEngine);
}
async function $c(t2) {
  const e = await Cc(t2), n2 = e.eventManager;
  return n2.onListen = Bo.bind(null, e.syncEngine), n2.onUnlisten = Uo.bind(null, e.syncEngine), n2;
}
function Mc(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Nc(t2), n2 = await kc(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = $(t3);
      return e2.Mr.delete(0), Kr(e2);
    }(n2);
  });
}
function Fc(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Nc(t2), n2 = await kc(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = $(t3);
      e2.Mr.add(0), await Qr(e2), e2.Br.set("Offline");
    }(n2);
  });
}
function Lc(t2, e) {
  const n2 = new bs();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n3) {
    try {
      const s = await function(t4, e3) {
        const n4 = $(t4);
        return n4.persistence.runTransaction("read document", "readonly", (t5) => n4.Fn.mn(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n3.resolve(s) : s.isNoDocument() ? n3.resolve(null) : n3.reject(new b(P.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = yo(t4, `Failed to get document '${e2} from cache`);
      n3.reject(s);
    }
  }(await xc(t2), e, n2)), n2.promise;
}
function Bc(t2, e, n2 = {}) {
  const s = new bs();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n3, s2, i) {
    const r2 = new Ac({
      next: (r3) => {
        e2.enqueueAndForget(() => Po(t3, o));
        const c = r3.docs.has(n3);
        !c && r3.fromCache ? i.reject(new b(P.UNAVAILABLE, "Failed to get document because the client is offline.")) : c && r3.fromCache && s2 && s2.source === "server" ? i.reject(new b(P.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r3);
      },
      error: (t4) => i.reject(t4)
    }), o = new So(Jt(n3.path), r2, {
      includeMetadataChanges: true,
      so: true
    });
    return Ro(t3, o);
  }(await $c(t2), t2.asyncQueue, e, n2, s)), s.promise;
}
function qc(t2, e) {
  const n2 = new bs();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n3) {
    try {
      const s = await er(t3, e2, true), i = new $o(e2, s.Bn), r2 = i._o(s.documents), o = i.applyChanges(r2, false);
      n3.resolve(o.snapshot);
    } catch (t4) {
      const s = yo(t4, `Failed to execute query '${e2} against cache`);
      n3.reject(s);
    }
  }(await xc(t2), e, n2)), n2.promise;
}
function Uc(t2, e, n2 = {}) {
  const s = new bs();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n3, s2, i) {
    const r2 = new Ac({
      next: (n4) => {
        e2.enqueueAndForget(() => Po(t3, o)), n4.fromCache && s2.source === "server" ? i.reject(new b(P.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n4);
      },
      error: (t4) => i.reject(t4)
    }), o = new So(n3, r2, {
      includeMetadataChanges: true,
      so: true
    });
    return Ro(t3, o);
  }(await $c(t2), t2.asyncQueue, e, n2, s)), s.promise;
}
function Kc(t2, e) {
  const n2 = new Ac(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    $(t3).Gr.add(e2), e2.next();
  }(await $c(t2), n2)), () => {
    n2.Wo(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      $(t3).Gr.delete(e2);
    }(await $c(t2), n2));
  };
}
function Qc(t2, e) {
  const n2 = new bs();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Cc(t3).then((t4) => t4.datastore);
    }(t2);
    new bc(t2.asyncQueue, s, e, n2).run();
  }), n2.promise;
}
function jc(t2, e, n2, s) {
  const i = function(t3, e2) {
    let n3;
    n3 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Rc(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Ic(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Ic(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n3), e2);
  }(n2, Or(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    gc(await Oc(t2), i, s);
  });
}
function Wc(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n2 = $(t3);
    return n2.persistence.runTransaction("Get named query", "readonly", (t4) => n2.Ke.getNamedQuery(t4, e2));
  }(await xc(t2), e));
}
class Gc {
  constructor(t2, e, n2, s, i, r2, o) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n2, this.host = s, this.ssl = i, this.forceLongPolling = r2, this.autoDetectLongPolling = o;
  }
}
class zc {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof zc && t2.projectId === this.projectId && t2.database === this.database;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Hc = new Map();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jc {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t2}`;
  }
}
class Yc {
  constructor() {
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  setChangeListener(t2) {
    this.changeListener = t2, t2(gr.UNAUTHENTICATED);
  }
  removeChangeListener() {
    this.changeListener = null;
  }
}
class Xc {
  constructor(t2) {
    this.oc = null, this.currentUser = gr.UNAUTHENTICATED, this.receivedInitialUser = false, this.cc = 0, this.changeListener = null, this.forceRefresh = false, this.oc = () => {
      this.cc++, this.currentUser = this.uc(), this.receivedInitialUser = true, this.changeListener && this.changeListener(this.currentUser);
    }, this.cc = 0, this.auth = t2.getImmediate({
      optional: true
    }), this.auth ? this.auth.addAuthTokenListener(this.oc) : (this.oc(null), t2.get().then((t3) => {
      this.auth = t3, this.oc && this.auth.addAuthTokenListener(this.oc);
    }, () => {
    }));
  }
  getToken() {
    const t2 = this.cc, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.cc !== t2 ? (D("FirebaseCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (O(typeof e2.accessToken == "string"), new Jc(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  setChangeListener(t2) {
    this.changeListener = t2, this.receivedInitialUser && t2(this.currentUser);
  }
  removeChangeListener() {
    this.auth && this.auth.removeAuthTokenListener(this.oc), this.oc = null, this.changeListener = null;
  }
  uc() {
    const t2 = this.auth && this.auth.getUid();
    return O(t2 === null || typeof t2 == "string"), new gr(t2);
  }
}
class Zc {
  constructor(t2, e, n2) {
    this.ac = t2, this.hc = e, this.lc = n2, this.type = "FirstParty", this.user = gr.FIRST_PARTY;
  }
  get authHeaders() {
    const t2 = {
      "X-Goog-AuthUser": this.hc
    }, e = this.ac.auth.getAuthHeaderValueForFirstParty([]);
    return e && (t2.Authorization = e), this.lc && (t2["X-Goog-Iam-Authorization-Token"] = this.lc), t2;
  }
}
class tu {
  constructor(t2, e, n2) {
    this.ac = t2, this.hc = e, this.lc = n2;
  }
  getToken() {
    return Promise.resolve(new Zc(this.ac, this.hc, this.lc));
  }
  setChangeListener(t2) {
    t2(gr.FIRST_PARTY);
  }
  removeChangeListener() {
  }
  invalidateToken() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function eu(t2, e, n2) {
  if (!n2)
    throw new b(P.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function nu(t2) {
  if (!at.isDocumentKey(t2))
    throw new b(P.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function su(t2) {
  if (at.isDocumentKey(t2))
    throw new b(P.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function iu(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor) {
          const e2 = /function\s+([^\s(]+)\s*\(/.exec(t3.constructor.toString());
          if (e2 && e2.length > 1)
            return e2[1];
        }
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : k();
}
function ru(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new b(P.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n2 = iu(t2);
      throw new b(P.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n2}`);
    }
  }
  return t2;
}
function ou(t2, e) {
  if (e <= 0)
    throw new b(P.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cu {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new b(P.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new b(P.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, function(t3, e2, n2, s) {
      if (e2 === true && s === true)
        throw new b(P.INVALID_ARGUMENT, `${t3} and ${n2} cannot be used together.`);
    }("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uu {
  constructor(t2, e) {
    this._persistenceKey = "(lite)", this._settings = new cu({}), this._settingsFrozen = false, t2 instanceof zc ? (this._databaseId = t2, this._credentials = new Yc()) : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new b(P.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new zc(t3.options.projectId);
    }(t2), this._credentials = new Xc(e));
  }
  get app() {
    if (!this._app)
      throw new b(P.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new b(P.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new cu(t2), t2.credentials !== void 0 && (this._credentials = function(t3) {
      if (!t3)
        return new Yc();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return O(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new tu(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new b(P.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = Hc.get(t2);
      e && (D("ComponentProvider", "Removing Datastore"), Hc.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
}
function au(t2, e, n2) {
  const s = (t2 = ru(t2, uu))._getSettings();
  s.host !== "firestore.googleapis.com" && s.host !== e && N("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, s), {
    host: `${e}:${n2}`,
    ssl: false
  }));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hu {
  constructor(t2, e, n2) {
    this._converter = e, this._key = n2, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new fu(this.firestore, this._converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new hu(this.firestore, t2, this._key);
  }
}
class lu {
  constructor(t2, e, n2) {
    this._converter = e, this._query = n2, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new lu(this.firestore, t2, this._query);
  }
}
class fu extends lu {
  constructor(t2, e, n2) {
    super(t2, e, Jt(n2)), this._path = n2, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new hu(this.firestore, null, new at(t2));
  }
  withConverter(t2) {
    return new fu(this.firestore, t2, this._path);
  }
}
function du(t2, e, ...n2) {
  if (t2 = getModularInstance(t2), eu("collection", "path", e), t2 instanceof uu) {
    const s = z.fromString(e, ...n2);
    return su(s), new fu(t2, null, s);
  }
  {
    if (!(t2 instanceof hu || t2 instanceof fu))
      throw new b(P.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = z.fromString(t2.path, ...n2).child(z.fromString(e));
    return su(s), new fu(t2.firestore, null, s);
  }
}
function wu(t2, e) {
  if (t2 = ru(t2, uu), eu("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new b(P.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new lu(t2, null, function(t3) {
    return new zt(z.emptyPath(), t3);
  }(e));
}
function _u(t2, e, ...n2) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = F.u()), eu("doc", "path", e), t2 instanceof uu) {
    const s = z.fromString(e, ...n2);
    return nu(s), new hu(t2, null, new at(s));
  }
  {
    if (!(t2 instanceof hu || t2 instanceof fu))
      throw new b(P.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(z.fromString(e, ...n2));
    return nu(s), new hu(t2.firestore, t2 instanceof fu ? t2._converter : null, new at(s));
  }
}
function mu(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof hu || t2 instanceof fu) && (e instanceof hu || e instanceof fu) && (t2.firestore === e.firestore && t2.path === e.path && t2._converter === e._converter);
}
function gu(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof lu && e instanceof lu && (t2.firestore === e.firestore && re(t2._query, e._query) && t2._converter === e._converter);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yu {
  constructor() {
    this.fc = Promise.resolve(), this.dc = [], this.wc = false, this._c = [], this.mc = null, this.gc = false, this.yc = [], this.Zi = new $r(this, "async_queue_retry"), this.Ec = () => {
      const t3 = kr();
      t3 && D("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.Zi.Gi();
    };
    const t2 = kr();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ec);
  }
  get isShuttingDown() {
    return this.wc;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Tc(), this.Ic(t2);
  }
  enterRestrictedMode() {
    if (!this.wc) {
      this.wc = true;
      const t2 = kr();
      t2 && typeof t2.removeEventListener == "function" && t2.removeEventListener("visibilitychange", this.Ec);
    }
  }
  enqueue(t2) {
    return this.Tc(), this.wc ? new Promise((t3) => {
    }) : this.Ic(t2);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.dc.push(t2), this.Ac()));
  }
  async Ac() {
    if (this.dc.length !== 0) {
      try {
        await this.dc[0](), this.dc.shift(), this.Zi.reset();
      } catch (t2) {
        if (!Ns(t2))
          throw t2;
        D("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.dc.length > 0 && this.Zi.ji(() => this.Ac());
    }
  }
  Ic(t2) {
    const e = this.fc.then(() => (this.gc = true, t2().catch((t3) => {
      this.mc = t3, this.gc = false;
      throw C("INTERNAL UNHANDLED ERROR: ", function(t4) {
        let e2 = t4.message || "";
        t4.stack && (e2 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e2;
      }(t3)), t3;
    }).then((t3) => (this.gc = false, t3))));
    return this.fc = e, e;
  }
  enqueueAfterDelay(t2, e, n2) {
    this.Tc(), this.yc.indexOf(t2) > -1 && (e = 0);
    const s = go.createAndSchedule(this, t2, e, n2, (t3) => this.Rc(t3));
    return this._c.push(s), s;
  }
  Tc() {
    this.mc && k();
  }
  verifyOperationInProgress() {
  }
  async Pc() {
    let t2;
    do {
      t2 = this.fc, await t2;
    } while (t2 !== this.fc);
  }
  bc(t2) {
    for (const e of this._c)
      if (e.timerId === t2)
        return true;
    return false;
  }
  vc(t2) {
    return this.Pc().then(() => {
      this._c.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this._c)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Pc();
    });
  }
  Vc(t2) {
    this.yc.push(t2);
  }
  Rc(t2) {
    const e = this._c.indexOf(t2);
    this._c.splice(e, 1);
  }
}
function pu(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n2 = t3;
    for (const t4 of e)
      if (t4 in n2 && typeof n2[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
class Eu {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new bs(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n2) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n2
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Tu = -1;
class Iu extends uu {
  constructor(t2, e) {
    super(t2, e), this._queue = new yu(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || bu(this), this._firestoreClient.terminate();
  }
}
function Pu(t2) {
  return t2._firestoreClient || bu(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function bu(t2) {
  var e;
  const n2 = t2._freezeSettings(), s = function(t3, e2, n3, s2) {
    return new Gc(t3, e2, n3, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n2);
  t2._firestoreClient = new vc(t2._credentials, t2._queue, s);
}
function vu(t2, e) {
  Mu(t2 = ru(t2, Iu));
  const n2 = Pu(t2), s = t2._freezeSettings(), i = new Tc();
  return Su(n2, i, new pc(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Vu(t2) {
  Mu(t2 = ru(t2, Iu));
  const e = Pu(t2), n2 = t2._freezeSettings(), s = new Tc();
  return Su(e, s, new Ec(s, n2.cacheSizeBytes));
}
function Su(t2, e, n2) {
  const s = new bs();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Vc(t2, n2), await Sc(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === P.FAILED_PRECONDITION || t4.code === P.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Du(t2) {
  if (t2._initialized && !t2._terminated)
    throw new b(P.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new bs();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Ss.gt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Ss.delete(e2);
      }(Bi(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Cu(t2) {
  return function(t3) {
    const e = new bs();
    return t3.asyncQueue.enqueueAndForget(async () => Ho(await Oc(t3), e)), e.promise;
  }(Pu(t2 = ru(t2, Iu)));
}
function Nu(t2) {
  return Mc(Pu(t2 = ru(t2, Iu)));
}
function xu(t2) {
  return Fc(Pu(t2 = ru(t2, Iu)));
}
function Ou(t2, e) {
  const n2 = Pu(t2 = ru(t2, Iu)), s = new Eu();
  return jc(n2, t2._databaseId, e, s), s;
}
function $u(t2, e) {
  return Wc(Pu(t2 = ru(t2, Iu)), e).then((e2) => e2 ? new lu(t2, null, e2.query) : null);
}
function Mu(t2) {
  if (t2._initialized || t2._terminated)
    throw new b(P.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fu {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new b(P.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new J(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bu {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Bu(X.fromBase64String(t2));
    } catch (t3) {
      throw new b(P.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Bu(X.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qu {
  constructor(t2) {
    this._methodName = t2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Uu {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new b(P.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new b(P.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return L(this._lat, t2._lat) || L(this._long, t2._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ku = /^__.*__$/;
class Qu {
  constructor(t2, e, n2) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n2;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new Fe(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new Me(t2, this.data, e, this.fieldTransforms);
  }
}
class ju {
  constructor(t2, e, n2) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n2;
  }
  toMutation(t2, e) {
    return new Fe(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
}
function Wu(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw k();
  }
}
class Gu {
  constructor(t2, e, n2, s, i, r2) {
    this.settings = t2, this.databaseId = e, this.R = n2, this.ignoreUndefinedProperties = s, i === void 0 && this.Sc(), this.fieldTransforms = i || [], this.fieldMask = r2 || [];
  }
  get path() {
    return this.settings.path;
  }
  get Dc() {
    return this.settings.Dc;
  }
  Cc(t2) {
    return new Gu(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.R, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Nc(t2) {
    var e;
    const n2 = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Cc({
      path: n2,
      xc: false
    });
    return s.kc(t2), s;
  }
  Oc(t2) {
    var e;
    const n2 = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Cc({
      path: n2,
      xc: false
    });
    return s.Sc(), s;
  }
  $c(t2) {
    return this.Cc({
      path: void 0,
      xc: true
    });
  }
  Mc(t2) {
    return da(t2, this.settings.methodName, this.settings.Fc || false, this.path, this.settings.Lc);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Sc() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.kc(this.path.get(t2));
  }
  kc(t2) {
    if (t2.length === 0)
      throw this.Mc("Document fields must not be empty");
    if (Wu(this.Dc) && Ku.test(t2))
      throw this.Mc('Document fields cannot begin and end with "__"');
  }
}
class zu {
  constructor(t2, e, n2) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.R = n2 || Or(t2);
  }
  Bc(t2, e, n2, s = false) {
    return new Gu({
      Dc: t2,
      methodName: e,
      Lc: n2,
      path: J.emptyPath(),
      xc: false,
      Fc: s
    }, this.databaseId, this.R, this.ignoreUndefinedProperties);
  }
}
function Hu(t2) {
  const e = t2._freezeSettings(), n2 = Or(t2._databaseId);
  return new zu(t2._databaseId, !!e.ignoreUndefinedProperties, n2);
}
function Ju(t2, e, n2, s, i, r2 = {}) {
  const o = t2.Bc(r2.merge || r2.mergeFields ? 2 : 0, e, n2, i);
  aa("Data must be an object, but it was:", o, s);
  const c = ca(s, o);
  let u, a;
  if (r2.merge)
    u = new Y(o.fieldMask), a = o.fieldTransforms;
  else if (r2.mergeFields) {
    const t3 = [];
    for (const s2 of r2.mergeFields) {
      const i2 = ha(e, s2, n2);
      if (!o.contains(i2))
        throw new b(P.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      wa(t3, i2) || t3.push(i2);
    }
    u = new Y(t3), a = o.fieldTransforms.filter((t4) => u.covers(t4.field));
  } else
    u = null, a = o.fieldTransforms;
  return new Qu(new At(c), u, a);
}
class Yu extends qu {
  _toFieldTransform(t2) {
    if (t2.Dc !== 2)
      throw t2.Dc === 1 ? t2.Mc(`${this._methodName}() can only appear at the top level of your update data`) : t2.Mc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof Yu;
  }
}
function Xu(t2, e, n2) {
  return new Gu({
    Dc: 3,
    Lc: e.settings.Lc,
    methodName: t2._methodName,
    xc: n2
  }, e.databaseId, e.R, e.ignoreUndefinedProperties);
}
class Zu extends qu {
  _toFieldTransform(t2) {
    return new be(t2.path, new ye());
  }
  isEqual(t2) {
    return t2 instanceof Zu;
  }
}
class ta extends qu {
  constructor(t2, e) {
    super(t2), this.qc = e;
  }
  _toFieldTransform(t2) {
    const e = Xu(this, t2, true), n2 = this.qc.map((t3) => oa(t3, e)), s = new pe(n2);
    return new be(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
}
class ea extends qu {
  constructor(t2, e) {
    super(t2), this.qc = e;
  }
  _toFieldTransform(t2) {
    const e = Xu(this, t2, true), n2 = this.qc.map((t3) => oa(t3, e)), s = new Te(n2);
    return new be(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
}
class na extends qu {
  constructor(t2, e) {
    super(t2), this.Uc = e;
  }
  _toFieldTransform(t2) {
    const e = new Ae(t2.R, de(t2.R, this.Uc));
    return new be(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
}
function sa(t2, e, n2, s) {
  const i = t2.Bc(1, e, n2);
  aa("Data must be an object, but it was:", i, s);
  const r2 = [], o = At.empty();
  j(s, (t3, s2) => {
    const c2 = fa(e, t3, n2);
    s2 = getModularInstance(s2);
    const u = i.Oc(c2);
    if (s2 instanceof Yu)
      r2.push(c2);
    else {
      const t4 = oa(s2, u);
      t4 != null && (r2.push(c2), o.set(c2, t4));
    }
  });
  const c = new Y(r2);
  return new ju(o, c, i.fieldTransforms);
}
function ia(t2, e, n2, s, i, r2) {
  const o = t2.Bc(1, e, n2), c = [ha(e, s, n2)], u = [i];
  if (r2.length % 2 != 0)
    throw new b(P.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r2.length; t3 += 2)
    c.push(ha(e, r2[t3])), u.push(r2[t3 + 1]);
  const a = [], h2 = At.empty();
  for (let t3 = c.length - 1; t3 >= 0; --t3)
    if (!wa(a, c[t3])) {
      const e2 = c[t3];
      let n3 = u[t3];
      n3 = getModularInstance(n3);
      const s2 = o.Oc(e2);
      if (n3 instanceof Yu)
        a.push(e2);
      else {
        const t4 = oa(n3, s2);
        t4 != null && (a.push(e2), h2.set(e2, t4));
      }
    }
  const l = new Y(a);
  return new ju(h2, l, o.fieldTransforms);
}
function ra(t2, e, n2, s = false) {
  return oa(n2, t2.Bc(s ? 4 : 3, e));
}
function oa(t2, e) {
  if (ua(t2 = getModularInstance(t2)))
    return aa("Unsupported field value:", e, t2), ca(t2, e);
  if (t2 instanceof qu)
    return function(t3, e2) {
      if (!Wu(e2.Dc))
        throw e2.Mc(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Mc(`${t3._methodName}() is not currently supported inside arrays`);
      const n2 = t3._toFieldTransform(e2);
      n2 && e2.fieldTransforms.push(n2);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.xc && e.Dc !== 4)
      throw e.Mc("Nested arrays are not supported");
    return function(t3, e2) {
      const n2 = [];
      let s = 0;
      for (const i of t3) {
        let t4 = oa(i, e2.$c(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n2.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n2
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return de(e2.R, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n2 = U.fromDate(t3);
      return {
        timestampValue: An(e2.R, n2)
      };
    }
    if (t3 instanceof U) {
      const n2 = new U(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: An(e2.R, n2)
      };
    }
    if (t3 instanceof Uu)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Bu)
      return {
        bytesValue: Rn(e2.R, t3._byteString)
      };
    if (t3 instanceof hu) {
      const n2 = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n2))
        throw e2.Mc(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n2.projectId}/${n2.database}`);
      return {
        referenceValue: vn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Mc(`Unsupported field value: ${iu(t3)}`);
  }(t2, e);
}
function ca(t2, e) {
  const n2 = {};
  return W(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : j(t2, (t3, s) => {
    const i = oa(s, e.Nc(t3));
    i != null && (n2[t3] = i);
  }), {
    mapValue: {
      fields: n2
    }
  };
}
function ua(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof U || t2 instanceof Uu || t2 instanceof Bu || t2 instanceof hu || t2 instanceof qu);
}
function aa(t2, e, n2) {
  if (!ua(n2) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n2)) {
    const s = iu(n2);
    throw s === "an object" ? e.Mc(t2 + " a custom object") : e.Mc(t2 + " " + s);
  }
}
function ha(t2, e, n2) {
  if ((e = getModularInstance(e)) instanceof Fu)
    return e._internalPath;
  if (typeof e == "string")
    return fa(t2, e);
  throw da("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n2);
}
const la = new RegExp("[~\\*/\\[\\]]");
function fa(t2, e, n2) {
  if (e.search(la) >= 0)
    throw da(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n2);
  try {
    return new Fu(...e.split("."))._internalPath;
  } catch (s) {
    throw da(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n2);
  }
}
function da(t2, e, n2, s, i) {
  const r2 = s && !s.isEmpty(), o = i !== void 0;
  let c = `Function ${e}() called with invalid data`;
  n2 && (c += " (via `toFirestore()`)"), c += ". ";
  let u = "";
  return (r2 || o) && (u += " (found", r2 && (u += ` in field ${s}`), o && (u += ` in document ${i}`), u += ")"), new b(P.INVALID_ARGUMENT, c + t2 + u);
}
function wa(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _a {
  constructor(t2, e, n2, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n2, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new hu(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new ma(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.toProto());
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(ga("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
}
class ma extends _a {
  data() {
    return super.data();
  }
}
function ga(t2, e) {
  return typeof e == "string" ? fa(t2, e) : e instanceof Fu ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ya {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
}
class pa extends _a {
  constructor(t2, e, n2, s, i, r2) {
    super(t2, e, n2, s, r2), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Ea(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.toProto(), t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n2 = this._document.data.field(ga("DocumentSnapshot.get", t2));
      if (n2 !== null)
        return this._userDataWriter.convertValue(n2, e.serverTimestamps);
    }
  }
}
class Ea extends pa {
  data(t2 = {}) {
    return super.data(t2);
  }
}
class Ta {
  constructor(t2, e, n2, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new ya(s.hasPendingWrites, s.fromCache), this.query = n2;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n2) => {
      t2.call(e, new Ea(this._firestore, this._userDataWriter, n2.key, n2, new ya(this._snapshot.mutatedKeys.has(n2.key), this._snapshot.fromCache), this.query._converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new b(P.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let n2 = 0;
        return t3._snapshot.docChanges.map((s) => {
          const i = new Ea(t3._firestore, t3._userDataWriter, s.doc.key, s.doc, new ya(t3._snapshot.mutatedKeys.has(s.doc.key), t3._snapshot.fromCache), t3.query._converter);
          return s.doc, {
            type: "added",
            doc: i,
            oldIndex: -1,
            newIndex: n2++
          };
        });
      }
      {
        let n2 = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Ea(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new ya(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query._converter);
          let i = -1, r2 = -1;
          return e3.type !== 0 && (i = n2.indexOf(e3.doc.key), n2 = n2.delete(e3.doc.key)), e3.type !== 1 && (n2 = n2.add(e3.doc), r2 = n2.indexOf(e3.doc.key)), {
            type: Ia(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r2
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
}
function Ia(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return k();
  }
}
function Aa(t2, e) {
  return t2 instanceof pa && e instanceof pa ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Ta && e instanceof Ta && (t2._firestore === e._firestore && gu(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ra(t2) {
  if (Xt(t2) && t2.explicitOrderBy.length === 0)
    throw new b(P.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
class Pa {
}
function ba(t2, ...e) {
  for (const n2 of e)
    t2 = n2._apply(t2);
  return t2;
}
class va extends Pa {
  constructor(t2, e, n2) {
    super(), this.Kc = t2, this.Qc = e, this.jc = n2, this.type = "where";
  }
  _apply(t2) {
    const e = Hu(t2.firestore), n2 = function(t3, e2, n3, s, i, r2, o) {
      let c;
      if (i.isKeyField()) {
        if (r2 === "array-contains" || r2 === "array-contains-any")
          throw new b(P.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r2}' queries on FieldPath.documentId().`);
        if (r2 === "in" || r2 === "not-in") {
          Ua(o, r2);
          const e3 = [];
          for (const n4 of o)
            e3.push(qa(s, t3, n4));
          c = {
            arrayValue: {
              values: e3
            }
          };
        } else
          c = qa(s, t3, o);
      } else
        r2 !== "in" && r2 !== "not-in" && r2 !== "array-contains-any" || Ua(o, r2), c = ra(n3, e2, o, r2 === "in" || r2 === "not-in");
      const u = Nt.create(i, r2, c);
      return function(t4, e3) {
        if (e3.g()) {
          const n5 = te(t4);
          if (n5 !== null && !n5.isEqual(e3.field))
            throw new b(P.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n5.toString()}' and '${e3.field.toString()}'`);
          const s2 = Zt(t4);
          s2 !== null && Ka(t4, e3.field, s2);
        }
        const n4 = function(t5, e4) {
          for (const n5 of t5.filters)
            if (e4.indexOf(n5.op) >= 0)
              return n5.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n4 !== null)
          throw n4 === e3.op ? new b(P.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new b(P.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n4.toString()}' filters.`);
      }(t3, u), u;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Kc, this.Qc, this.jc);
    return new lu(t2.firestore, t2._converter, function(t3, e2) {
      const n3 = t3.filters.concat([e2]);
      return new zt(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n3, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n2));
  }
}
function Va(t2, e, n2) {
  const s = e, i = ga("where", t2);
  return new va(i, s, n2);
}
class Sa extends Pa {
  constructor(t2, e) {
    super(), this.Kc = t2, this.Wc = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n2) {
      if (t3.startAt !== null)
        throw new b(P.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new b(P.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Qt(e2, n2);
      return function(t4, e3) {
        if (Zt(t4) === null) {
          const n3 = te(t4);
          n3 !== null && Ka(t4, n3, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Kc, this.Wc);
    return new lu(t2.firestore, t2._converter, function(t3, e2) {
      const n2 = t3.explicitOrderBy.concat([e2]);
      return new zt(t3.path, t3.collectionGroup, n2, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
}
function Da(t2, e = "asc") {
  const n2 = e, s = ga("orderBy", t2);
  return new Sa(s, n2);
}
class Ca extends Pa {
  constructor(t2, e, n2) {
    super(), this.type = t2, this.Gc = e, this.zc = n2;
  }
  _apply(t2) {
    return new lu(t2.firestore, t2._converter, ie(t2._query, this.Gc, this.zc));
  }
}
function Na(t2) {
  return ou("limit", t2), new Ca("limit", t2, "F");
}
function xa(t2) {
  return ou("limitToLast", t2), new Ca("limitToLast", t2, "L");
}
class ka extends Pa {
  constructor(t2, e, n2) {
    super(), this.type = t2, this.Hc = e, this.Jc = n2;
  }
  _apply(t2) {
    const e = Ba(t2, this.type, this.Hc, this.Jc);
    return new lu(t2.firestore, t2._converter, function(t3, e2) {
      return new zt(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
}
function Oa(...t2) {
  return new ka("startAt", t2, true);
}
function $a(...t2) {
  return new ka("startAfter", t2, false);
}
class Ma extends Pa {
  constructor(t2, e, n2) {
    super(), this.type = t2, this.Hc = e, this.Jc = n2;
  }
  _apply(t2) {
    const e = Ba(t2, this.type, this.Hc, this.Jc);
    return new lu(t2.firestore, t2._converter, function(t3, e2) {
      return new zt(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
}
function Fa(...t2) {
  return new Ma("endBefore", t2, true);
}
function La(...t2) {
  return new Ma("endAt", t2, false);
}
function Ba(t2, e, n2, s) {
  if (n2[0] = getModularInstance(n2[0]), n2[0] instanceof _a)
    return function(t3, e2, n3, s2, i) {
      if (!s2)
        throw new b(P.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n3}().`);
      const r2 = [];
      for (const n4 of ne(t3))
        if (n4.field.isKeyField())
          r2.push(gt(e2, s2.key));
        else {
          const t4 = s2.data.field(n4.field);
          if (st(t4))
            throw new b(P.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n4.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n4.field.canonicalString();
            throw new b(P.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r2.push(t4);
        }
      return new Ut(r2, i);
    }(t2._query, t2.firestore._databaseId, e, n2[0]._document, s);
  {
    const i = Hu(t2.firestore);
    return function(t3, e2, n3, s2, i2, r2) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new b(P.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const c = [];
      for (let r3 = 0; r3 < i2.length; r3++) {
        const u = i2[r3];
        if (o[r3].field.isKeyField()) {
          if (typeof u != "string")
            throw new b(P.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof u}`);
          if (!ee(t3) && u.indexOf("/") !== -1)
            throw new b(P.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${s2}() must be a plain document ID, but '${u}' contains a slash.`);
          const n4 = t3.path.child(z.fromString(u));
          if (!at.isDocumentKey(n4))
            throw new b(P.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${s2}() must result in a valid document path, but '${n4}' is not because it contains an odd number of segments.`);
          const i3 = new at(n4);
          c.push(gt(e2, i3));
        } else {
          const t4 = ra(n3, s2, u);
          c.push(t4);
        }
      }
      return new Ut(c, r2);
    }(t2._query, t2.firestore._databaseId, i, e, n2, s);
  }
}
function qa(t2, e, n2) {
  if (typeof (n2 = getModularInstance(n2)) == "string") {
    if (n2 === "")
      throw new b(P.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!ee(e) && n2.indexOf("/") !== -1)
      throw new b(P.INVALID_ARGUMENT, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${n2}' contains a '/' character.`);
    const s = e.path.child(z.fromString(n2));
    if (!at.isDocumentKey(s))
      throw new b(P.INVALID_ARGUMENT, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return gt(t2, new at(s));
  }
  if (n2 instanceof hu)
    return gt(t2, n2._key);
  throw new b(P.INVALID_ARGUMENT, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${iu(n2)}.`);
}
function Ua(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new b(P.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new b(P.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Ka(t2, e, n2) {
  if (!n2.isEqual(e))
    throw new b(P.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n2.toString()}' instead.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qa {
  convertValue(t2, e = "none") {
    switch (ht(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return et(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(nt(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw k();
    }
  }
  convertObject(t2, e) {
    const n2 = {};
    return j(t2.fields || {}, (t3, s) => {
      n2[t3] = this.convertValue(s, e);
    }), n2;
  }
  convertGeoPoint(t2) {
    return new Uu(et(t2.latitude), et(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n2 = it(t2);
        return n2 == null ? null : this.convertValue(n2, e);
      case "estimate":
        return this.convertTimestamp(rt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = tt(t2);
    return new U(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n2 = z.fromString(t2);
    O(ns(n2));
    const s = new zc(n2.get(1), n2.get(3)), i = new at(n2.popFirst(5));
    return s.isEqual(e) || C(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ja(t2, e, n2) {
  let s;
  return s = t2 ? n2 && (n2.merge || n2.mergeFields) ? t2.toFirestore(e, n2) : t2.toFirestore(e) : e, s;
}
class Wa extends Qa {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Bu(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new hu(this.firestore, null, e);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ga {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = Hu(t2);
  }
  set(t2, e, n2) {
    this._verifyNotCommitted();
    const s = za(t2, this._firestore), i = ja(s._converter, e, n2), r2 = Ju(this._dataReader, "WriteBatch.set", s._key, i, s._converter !== null, n2);
    return this._mutations.push(r2.toMutation(s._key, Se.none())), this;
  }
  update(t2, e, n2, ...s) {
    this._verifyNotCommitted();
    const i = za(t2, this._firestore);
    let r2;
    return r2 = typeof (e = getModularInstance(e)) == "string" || e instanceof Fu ? ia(this._dataReader, "WriteBatch.update", i._key, e, n2, s) : sa(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r2.toMutation(i._key, Se.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = za(t2, this._firestore);
    return this._mutations = this._mutations.concat(new Ue(e._key, Se.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new b(P.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
}
function za(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new b(P.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ha(t2) {
  t2 = ru(t2, hu);
  const e = ru(t2.firestore, Iu);
  return Bc(Pu(e), t2._key).then((n2) => ah(e, t2, n2));
}
class Ja extends Qa {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Bu(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new hu(this.firestore, null, e);
  }
}
function Ya(t2) {
  t2 = ru(t2, hu);
  const e = ru(t2.firestore, Iu), n2 = Pu(e), s = new Ja(e);
  return Lc(n2, t2._key).then((n3) => new pa(e, s, t2._key, n3, new ya(n3 !== null && n3.hasLocalMutations, true), t2._converter));
}
function Xa(t2) {
  t2 = ru(t2, hu);
  const e = ru(t2.firestore, Iu);
  return Bc(Pu(e), t2._key, {
    source: "server"
  }).then((n2) => ah(e, t2, n2));
}
function Za(t2) {
  t2 = ru(t2, lu);
  const e = ru(t2.firestore, Iu), n2 = Pu(e), s = new Ja(e);
  return Ra(t2._query), Uc(n2, t2._query).then((n3) => new Ta(e, s, t2, n3));
}
function th(t2) {
  t2 = ru(t2, lu);
  const e = ru(t2.firestore, Iu), n2 = Pu(e), s = new Ja(e);
  return qc(n2, t2._query).then((n3) => new Ta(e, s, t2, n3));
}
function eh(t2) {
  t2 = ru(t2, lu);
  const e = ru(t2.firestore, Iu), n2 = Pu(e), s = new Ja(e);
  return Uc(n2, t2._query, {
    source: "server"
  }).then((n3) => new Ta(e, s, t2, n3));
}
function nh(t2, e, n2) {
  t2 = ru(t2, hu);
  const s = ru(t2.firestore, Iu), i = ja(t2._converter, e, n2);
  return uh(s, [Ju(Hu(s), "setDoc", t2._key, i, t2._converter !== null, n2).toMutation(t2._key, Se.none())]);
}
function sh(t2, e, n2, ...s) {
  t2 = ru(t2, hu);
  const i = ru(t2.firestore, Iu), r2 = Hu(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Fu ? ia(r2, "updateDoc", t2._key, e, n2, s) : sa(r2, "updateDoc", t2._key, e);
  return uh(i, [o.toMutation(t2._key, Se.exists(true))]);
}
function ih(t2) {
  return uh(ru(t2.firestore, Iu), [new Ue(t2._key, Se.none())]);
}
function rh(t2, e) {
  const n2 = ru(t2.firestore, Iu), s = _u(t2), i = ja(t2._converter, e);
  return uh(n2, [Ju(Hu(t2.firestore), "addDoc", s._key, i, t2._converter !== null, {}).toMutation(s._key, Se.exists(false))]).then(() => s);
}
function oh(t2, ...e) {
  var n2, s, i;
  t2 = getModularInstance(t2);
  let r2 = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || pu(e[o]) || (r2 = e[o], o++);
  const c = {
    includeMetadataChanges: r2.includeMetadataChanges
  };
  if (pu(e[o])) {
    const t3 = e[o];
    e[o] = (n2 = t3.next) === null || n2 === void 0 ? void 0 : n2.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let u, a, h2;
  if (t2 instanceof hu)
    a = ru(t2.firestore, Iu), h2 = Jt(t2._key.path), u = {
      next: (n3) => {
        e[o] && e[o](ah(a, t2, n3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n3 = ru(t2, lu);
    a = ru(n3.firestore, Iu), h2 = n3._query;
    const s2 = new Ja(a);
    u = {
      next: (t3) => {
        e[o] && e[o](new Ta(a, s2, n3, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Ra(t2._query);
  }
  return function(t3, e2, n3, s2) {
    const i2 = new Ac(s2), r3 = new So(e2, i2, n3);
    return t3.asyncQueue.enqueueAndForget(async () => Ro(await $c(t3), r3)), () => {
      i2.Wo(), t3.asyncQueue.enqueueAndForget(async () => Po(await $c(t3), r3));
    };
  }(Pu(a), h2, c, u);
}
function ch(t2, e) {
  return Kc(Pu(t2 = ru(t2, Iu)), pu(e) ? e : {
    next: e
  });
}
function uh(t2, e) {
  return function(t3, e2) {
    const n2 = new bs();
    return t3.asyncQueue.enqueueAndForget(async () => Ko(await Oc(t3), e2, n2)), n2.promise;
  }(Pu(t2), e);
}
function ah(t2, e, n2) {
  const s = n2.docs.get(e._key), i = new Ja(t2);
  return new pa(t2, i, e._key, s, new ya(n2.hasPendingWrites, n2.fromCache), e._converter);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hh extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = Hu(t2);
  }
  get(t2) {
    const e = za(t2, this._firestore), n2 = new Wa(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return k();
      const s = t3[0];
      if (s.isFoundDocument())
        return new _a(this._firestore, n2, s.key, s, e._converter);
      if (s.isNoDocument())
        return new _a(this._firestore, n2, e._key, null, e._converter);
      throw k();
    });
  }
  set(t2, e, n2) {
    const s = za(t2, this._firestore), i = ja(s._converter, e, n2), r2 = Ju(this._dataReader, "Transaction.set", s._key, i, s._converter !== null, n2);
    return this._transaction.set(s._key, r2), this;
  }
  update(t2, e, n2, ...s) {
    const i = za(t2, this._firestore);
    let r2;
    return r2 = typeof (e = getModularInstance(e)) == "string" || e instanceof Fu ? ia(this._dataReader, "Transaction.update", i._key, e, n2, s) : sa(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r2), this;
  }
  delete(t2) {
    const e = za(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = za(t2, this._firestore), n2 = new Ja(this._firestore);
    return super.get(t2).then((t3) => new pa(this._firestore, n2, e._key, t3._document, new ya(false, false), e._converter));
  }
}
function lh(t2, e) {
  return Qc(Pu(t2), (n2) => e(new hh(t2, n2)));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fh() {
  return new Yu("deleteField");
}
function dh() {
  return new Zu("serverTimestamp");
}
function wh(...t2) {
  return new ta("arrayUnion", t2);
}
function _h(...t2) {
  return new ea("arrayRemove", t2);
}
function mh(t2) {
  return new na("increment", t2);
}
var yh;
_registerComponent(new Component("firestore-exp", (t2, {options: e}) => {
  const n2 = t2.getProvider("app-exp").getImmediate(), s = new Iu(n2, t2.getProvider("auth-internal"));
  return e && s._setSettings(e), s;
}, "PUBLIC")), registerVersion("@firebase/firestore", "0.0.900-exp.894b5da5a", yh);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_DATABASE_NAME = "(default)";
class DatabaseId {
  constructor(projectId, database) {
    this.projectId = projectId;
    this.database = database ? database : DEFAULT_DATABASE_NAME;
  }
  get isDefaultDatabase() {
    return this.database === DEFAULT_DATABASE_NAME;
  }
  isEqual(other) {
    return other instanceof DatabaseId && other.projectId === this.projectId && other.database === this.database;
  }
}
const version = "8.4.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function formatJSON(value) {
  return JSON.stringify(value);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger("@firebase/firestore");
function setLogLevel(logLevel) {
  logClient.setLogLevel(logLevel);
}
function logError(msg, ...obj) {
  if (logClient.logLevel <= LogLevel.ERROR) {
    const args = obj.map(argToString);
    logClient.error(`Firestore (${version}): ${msg}`, ...args);
  }
}
function argToString(obj) {
  if (typeof obj === "string") {
    return obj;
  } else {
    try {
      return formatJSON(obj);
    } catch (e) {
      return obj;
    }
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fail(failure = "Unexpected state") {
  const message = `FIRESTORE (${version}) INTERNAL ASSERTION FAILED: ` + failure;
  logError(message);
  throw new Error(message);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Code = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
class FirestoreError extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.message = message;
    this.name = "FirebaseError";
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DOCUMENT_KEY_NAME = "__name__";
class BasePath {
  constructor(segments, offset, length) {
    if (offset === void 0) {
      offset = 0;
    } else if (offset > segments.length) {
      fail();
    }
    if (length === void 0) {
      length = segments.length - offset;
    } else if (length > segments.length - offset) {
      fail();
    }
    this.segments = segments;
    this.offset = offset;
    this.len = length;
  }
  get length() {
    return this.len;
  }
  isEqual(other) {
    return BasePath.comparator(this, other) === 0;
  }
  child(nameOrPath) {
    const segments = this.segments.slice(this.offset, this.limit());
    if (nameOrPath instanceof BasePath) {
      nameOrPath.forEach((segment) => {
        segments.push(segment);
      });
    } else {
      segments.push(nameOrPath);
    }
    return this.construct(segments);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(size) {
    size = size === void 0 ? 1 : size;
    return this.construct(this.segments, this.offset + size, this.length - size);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(index2) {
    return this.segments[this.offset + index2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(other) {
    if (other.length < this.length) {
      return false;
    }
    for (let i = 0; i < this.length; i++) {
      if (this.get(i) !== other.get(i)) {
        return false;
      }
    }
    return true;
  }
  isImmediateParentOf(potentialChild) {
    if (this.length + 1 !== potentialChild.length) {
      return false;
    }
    for (let i = 0; i < this.length; i++) {
      if (this.get(i) !== potentialChild.get(i)) {
        return false;
      }
    }
    return true;
  }
  forEach(fn2) {
    for (let i = this.offset, end = this.limit(); i < end; i++) {
      fn2(this.segments[i]);
    }
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(p1, p2) {
    const len = Math.min(p1.length, p2.length);
    for (let i = 0; i < len; i++) {
      const left = p1.get(i);
      const right = p2.get(i);
      if (left < right) {
        return -1;
      }
      if (left > right) {
        return 1;
      }
    }
    if (p1.length < p2.length) {
      return -1;
    }
    if (p1.length > p2.length) {
      return 1;
    }
    return 0;
  }
}
class ResourcePath extends BasePath {
  construct(segments, offset, length) {
    return new ResourcePath(segments, offset, length);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...pathComponents) {
    const segments = [];
    for (const path of pathComponents) {
      if (path.indexOf("//") >= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);
      }
      segments.push(...path.split("/").filter((segment) => segment.length > 0));
    }
    return new ResourcePath(segments);
  }
  static emptyPath() {
    return new ResourcePath([]);
  }
}
const identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class FieldPath extends BasePath {
  construct(segments, offset, length) {
    return new FieldPath(segments, offset, length);
  }
  static isValidIdentifier(segment) {
    return identifierRegExp.test(segment);
  }
  canonicalString() {
    return this.toArray().map((str) => {
      str = str.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
      if (!FieldPath.isValidIdentifier(str)) {
        str = "`" + str + "`";
      }
      return str;
    }).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
  }
  static keyField() {
    return new FieldPath([DOCUMENT_KEY_NAME]);
  }
  static fromServerFormat(path) {
    const segments = [];
    let current = "";
    let i = 0;
    const addCurrentSegment = () => {
      if (current.length === 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      }
      segments.push(current);
      current = "";
    };
    let inBackticks = false;
    while (i < path.length) {
      const c = path[i];
      if (c === "\\") {
        if (i + 1 === path.length) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has trailing escape character: " + path);
        }
        const next = path[i + 1];
        if (!(next === "\\" || next === "." || next === "`")) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has invalid escape sequence: " + path);
        }
        current += next;
        i += 2;
      } else if (c === "`") {
        inBackticks = !inBackticks;
        i++;
      } else if (c === "." && !inBackticks) {
        addCurrentSegment();
        i++;
      } else {
        current += c;
        i++;
      }
    }
    addCurrentSegment();
    if (inBackticks) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Unterminated ` in path: " + path);
    }
    return new FieldPath(segments);
  }
  static emptyPath() {
    return new FieldPath([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentKey {
  constructor(path) {
    this.path = path;
  }
  static fromPath(path) {
    return new DocumentKey(ResourcePath.fromString(path));
  }
  static fromName(name2) {
    return new DocumentKey(ResourcePath.fromString(name2).popFirst(5));
  }
  hasCollectionId(collectionId) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;
  }
  isEqual(other) {
    return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(k1, k2) {
    return ResourcePath.comparator(k1.path, k2.path);
  }
  static isDocumentKey(path) {
    return path.length % 2 === 0;
  }
  static fromSegments(segments) {
    return new DocumentKey(new ResourcePath(segments.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function validateSetOptions(methodName, options2) {
  if (options2 === void 0) {
    return {
      merge: false
    };
  }
  if (options2.mergeFields !== void 0 && options2.merge !== void 0) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid options passed to function ${methodName}(): You cannot specify both "merge" and "mergeFields".`);
  }
  return options2;
}
function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {
  if (argument1 === true && argument2 === true) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);
  }
}
function valueDescription(input) {
  if (input === void 0) {
    return "undefined";
  } else if (input === null) {
    return "null";
  } else if (typeof input === "string") {
    if (input.length > 20) {
      input = `${input.substring(0, 20)}...`;
    }
    return JSON.stringify(input);
  } else if (typeof input === "number" || typeof input === "boolean") {
    return "" + input;
  } else if (typeof input === "object") {
    if (input instanceof Array) {
      return "an array";
    } else {
      const customObjectName = tryGetCustomObjectType(input);
      if (customObjectName) {
        return `a custom ${customObjectName} object`;
      } else {
        return "an object";
      }
    }
  } else if (typeof input === "function") {
    return "a function";
  } else {
    return fail();
  }
}
function tryGetCustomObjectType(input) {
  if (input.constructor) {
    const funcNameRegex = /function\s+([^\s(]+)\s*\(/;
    const results = funcNameRegex.exec(input.constructor.toString());
    if (results && results.length > 1) {
      return results[1];
    }
  }
  return null;
}
function cast(obj, constructor) {
  if ("_delegate" in obj) {
    obj = obj._delegate;
  }
  if (!(obj instanceof constructor)) {
    if (constructor.name === obj.constructor.name) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?`);
    } else {
      const description = valueDescription(obj);
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);
    }
  }
  return obj;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isBase64Available() {
  return typeof atob !== "undefined";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assertUint8ArrayAvailable() {
  if (typeof Uint8Array === "undefined") {
    throw new FirestoreError(Code.UNIMPLEMENTED, "Uint8Arrays are not available in this environment.");
  }
}
function assertBase64Available() {
  if (!isBase64Available()) {
    throw new FirestoreError(Code.UNIMPLEMENTED, "Blobs are unavailable in Firestore in this environment.");
  }
}
class Blob {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static fromBase64String(base642) {
    assertBase64Available();
    return new Blob(Bu.fromBase64String(base642));
  }
  static fromUint8Array(array) {
    assertUint8ArrayAvailable();
    return new Blob(Bu.fromUint8Array(array));
  }
  toBase64() {
    assertBase64Available();
    return this._delegate.toBase64();
  }
  toUint8Array() {
    assertUint8ArrayAvailable();
    return this._delegate.toUint8Array();
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
  toString() {
    return "Blob(base64: " + this.toBase64() + ")";
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isPartialObserver(obj) {
  return implementsAnyMethods(obj, ["next", "error", "complete"]);
}
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const object = obj;
  for (const method of methods) {
    if (method in object && typeof object[method] === "function") {
      return true;
    }
  }
  return false;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndexedDbPersistenceProvider {
  enableIndexedDbPersistence(firestore2, forceOwnership) {
    return vu(firestore2._delegate, {forceOwnership});
  }
  enableMultiTabIndexedDbPersistence(firestore2) {
    return Vu(firestore2._delegate);
  }
  clearIndexedDbPersistence(firestore2) {
    return Du(firestore2._delegate);
  }
}
class Firestore {
  constructor(databaseIdOrApp, _delegate, _persistenceProvider) {
    this._delegate = _delegate;
    this._persistenceProvider = _persistenceProvider;
    this.INTERNAL = {
      delete: () => this.terminate()
    };
    if (!(databaseIdOrApp instanceof DatabaseId)) {
      this._appCompat = databaseIdOrApp;
    }
  }
  get _databaseId() {
    return this._delegate._databaseId;
  }
  settings(settingsLiteral) {
    if (settingsLiteral.merge) {
      settingsLiteral = Object.assign(Object.assign({}, this._delegate._getSettings()), settingsLiteral);
      delete settingsLiteral.merge;
    }
    this._delegate._setSettings(settingsLiteral);
  }
  useEmulator(host, port) {
    au(this._delegate, host, port);
  }
  enableNetwork() {
    return Nu(this._delegate);
  }
  disableNetwork() {
    return xu(this._delegate);
  }
  enablePersistence(settings) {
    let synchronizeTabs = false;
    let experimentalForceOwningTab = false;
    if (settings) {
      synchronizeTabs = !!settings.synchronizeTabs;
      experimentalForceOwningTab = !!settings.experimentalForceOwningTab;
      validateIsNotUsedTogether("synchronizeTabs", synchronizeTabs, "experimentalForceOwningTab", experimentalForceOwningTab);
    }
    return synchronizeTabs ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
  }
  clearPersistence() {
    return this._persistenceProvider.clearIndexedDbPersistence(this);
  }
  terminate() {
    if (this._appCompat) {
      this._appCompat._removeServiceInstance("firestore");
      this._appCompat._removeServiceInstance("firestore-exp");
    }
    return this._delegate._delete();
  }
  waitForPendingWrites() {
    return Cu(this._delegate);
  }
  onSnapshotsInSync(arg) {
    return ch(this._delegate, arg);
  }
  get app() {
    if (!this._appCompat) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    }
    return this._appCompat;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this, du(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "Firestore.collection()");
    }
  }
  doc(pathString) {
    try {
      return new DocumentReference(this, _u(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "Firestore.doc()");
    }
  }
  collectionGroup(collectionId) {
    try {
      return new Query(this, wu(this._delegate, collectionId));
    } catch (e) {
      throw replaceFunctionName(e, "collectionGroup()", "Firestore.collectionGroup()");
    }
  }
  runTransaction(updateFunction) {
    return lh(this._delegate, (transaction) => updateFunction(new Transaction(this, transaction)));
  }
  batch() {
    Pu(this._delegate);
    return new WriteBatch(new Ga(this._delegate, (mutations) => uh(this._delegate, mutations)));
  }
  loadBundle(bundleData) {
    throw new FirestoreError(Code.FAILED_PRECONDITION, '"loadBundle()" does not exist, have you imported "firebase/firestore/bundle"?');
  }
  namedQuery(name2) {
    throw new FirestoreError(Code.FAILED_PRECONDITION, '"namedQuery()" does not exist, have you imported "firebase/firestore/bundle"?');
  }
}
class UserDataWriter extends Qa {
  constructor(firestore2) {
    super();
    this.firestore = firestore2;
  }
  convertBytes(bytes) {
    return new Blob(new Bu(bytes));
  }
  convertReference(name2) {
    const key = this.convertDocumentKey(name2, this.firestore._databaseId);
    return DocumentReference.forKey(key, this.firestore, null);
  }
}
function setLogLevel$1(level) {
  setLogLevel(level);
}
class Transaction {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(_firestore);
  }
  get(documentRef) {
    const ref = castReference(documentRef);
    return this._delegate.get(ref).then((result) => new DocumentSnapshot(this._firestore, new pa(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref._converter)));
  }
  set(documentRef, data, options2) {
    const ref = castReference(documentRef);
    if (options2) {
      validateSetOptions("Transaction.set", options2);
      this._delegate.set(ref, data, options2);
    } else {
      this._delegate.set(ref, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref, dataOrField);
    } else {
      this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref = castReference(documentRef);
    this._delegate.delete(ref);
    return this;
  }
}
class WriteBatch {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  set(documentRef, data, options2) {
    const ref = castReference(documentRef);
    if (options2) {
      validateSetOptions("WriteBatch.set", options2);
      this._delegate.set(ref, data, options2);
    } else {
      this._delegate.set(ref, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref, dataOrField);
    } else {
      this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref = castReference(documentRef);
    this._delegate.delete(ref);
    return this;
  }
  commit() {
    return this._delegate.commit();
  }
}
class FirestoreDataConverter {
  constructor(_firestore, _userDataWriter, _delegate) {
    this._firestore = _firestore;
    this._userDataWriter = _userDataWriter;
    this._delegate = _delegate;
  }
  fromFirestore(snapshot, options2) {
    const expSnapshot = new Ea(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, null);
    return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options2 !== null && options2 !== void 0 ? options2 : {});
  }
  toFirestore(modelObject, options2) {
    if (!options2) {
      return this._delegate.toFirestore(modelObject);
    } else {
      return this._delegate.toFirestore(modelObject, options2);
    }
  }
  static getInstance(firestore2, converter) {
    const converterMapByFirestore = FirestoreDataConverter.INSTANCES;
    let untypedConverterByConverter = converterMapByFirestore.get(firestore2);
    if (!untypedConverterByConverter) {
      untypedConverterByConverter = new WeakMap();
      converterMapByFirestore.set(firestore2, untypedConverterByConverter);
    }
    let instance = untypedConverterByConverter.get(converter);
    if (!instance) {
      instance = new FirestoreDataConverter(firestore2, new UserDataWriter(firestore2), converter);
      untypedConverterByConverter.set(converter, instance);
    }
    return instance;
  }
}
FirestoreDataConverter.INSTANCES = new WeakMap();
class DocumentReference {
  constructor(firestore2, _delegate) {
    this.firestore = firestore2;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore2);
  }
  static forPath(path, firestore2, converter) {
    if (path.length % 2 !== 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path.canonicalString()} has ${path.length}`);
    }
    return new DocumentReference(firestore2, new hu(firestore2._delegate, converter, new DocumentKey(path)));
  }
  static forKey(key, firestore2, converter) {
    return new DocumentReference(firestore2, new hu(firestore2._delegate, converter, key));
  }
  get id() {
    return this._delegate.id;
  }
  get parent() {
    return new CollectionReference(this.firestore, this._delegate.parent);
  }
  get path() {
    return this._delegate.path;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this.firestore, du(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "DocumentReference.collection()");
    }
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof hu)) {
      return false;
    }
    return mu(this._delegate, other);
  }
  set(value, options2) {
    options2 = validateSetOptions("DocumentReference.set", options2);
    try {
      return nh(this._delegate, value, options2);
    } catch (e) {
      throw replaceFunctionName(e, "setDoc()", "DocumentReference.set()");
    }
  }
  update(fieldOrUpdateData, value, ...moreFieldsAndValues) {
    try {
      if (arguments.length === 1) {
        return sh(this._delegate, fieldOrUpdateData);
      } else {
        return sh(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);
      }
    } catch (e) {
      throw replaceFunctionName(e, "updateDoc()", "DocumentReference.update()");
    }
  }
  delete() {
    return ih(this._delegate);
  }
  onSnapshot(...args) {
    const options2 = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (result) => new DocumentSnapshot(this.firestore, new pa(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate._converter)));
    return oh(this._delegate, options2, observer);
  }
  get(options2) {
    let snap;
    if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "cache") {
      snap = Ya(this._delegate);
    } else if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "server") {
      snap = Xa(this._delegate);
    } else {
      snap = Ha(this._delegate);
    }
    return snap.then((result) => new DocumentSnapshot(this.firestore, new pa(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate._converter)));
  }
  withConverter(converter) {
    return new DocumentReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
}
function replaceFunctionName(e, original, updated) {
  e.message = e.message.replace(original, updated);
  return e;
}
function extractSnapshotOptions(args) {
  for (const arg of args) {
    if (typeof arg === "object" && !isPartialObserver(arg)) {
      return arg;
    }
  }
  return {};
}
function wrapObserver(args, wrapper) {
  var _a2, _b;
  let userObserver;
  if (isPartialObserver(args[0])) {
    userObserver = args[0];
  } else if (isPartialObserver(args[1])) {
    userObserver = args[1];
  } else if (typeof args[0] === "function") {
    userObserver = {
      next: args[0],
      error: args[1],
      complete: args[2]
    };
  } else {
    userObserver = {
      next: args[1],
      error: args[2],
      complete: args[3]
    };
  }
  return {
    next: (val) => {
      if (userObserver.next) {
        userObserver.next(wrapper(val));
      }
    },
    error: (_a2 = userObserver.error) === null || _a2 === void 0 ? void 0 : _a2.bind(userObserver),
    complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
  };
}
class DocumentSnapshot {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get ref() {
    return new DocumentReference(this._firestore, this._delegate.ref);
  }
  get id() {
    return this._delegate.id;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get exists() {
    return this._delegate.exists();
  }
  data(options2) {
    return this._delegate.data(options2);
  }
  get(fieldPath, options2) {
    return this._delegate.get(fieldPath, options2);
  }
  isEqual(other) {
    return Aa(this._delegate, other._delegate);
  }
}
class QueryDocumentSnapshot extends DocumentSnapshot {
  data(options2) {
    const data = this._delegate.data(options2);
    return data;
  }
}
class Query {
  constructor(firestore2, _delegate) {
    this.firestore = firestore2;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore2);
  }
  where(fieldPath, opStr, value) {
    try {
      return new Query(this.firestore, ba(this._delegate, Va(fieldPath, opStr, value)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  orderBy(fieldPath, directionStr) {
    try {
      return new Query(this.firestore, ba(this._delegate, Da(fieldPath, directionStr)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  limit(n2) {
    try {
      return new Query(this.firestore, ba(this._delegate, Na(n2)));
    } catch (e) {
      throw replaceFunctionName(e, "limit()", "Query.limit()");
    }
  }
  limitToLast(n2) {
    try {
      return new Query(this.firestore, ba(this._delegate, xa(n2)));
    } catch (e) {
      throw replaceFunctionName(e, "limitToLast()", "Query.limitToLast()");
    }
  }
  startAt(...args) {
    try {
      return new Query(this.firestore, ba(this._delegate, Oa(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAt()", "Query.startAt()");
    }
  }
  startAfter(...args) {
    try {
      return new Query(this.firestore, ba(this._delegate, $a(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAfter()", "Query.startAfter()");
    }
  }
  endBefore(...args) {
    try {
      return new Query(this.firestore, ba(this._delegate, Fa(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endBefore()", "Query.endBefore()");
    }
  }
  endAt(...args) {
    try {
      return new Query(this.firestore, ba(this._delegate, La(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endAt()", "Query.endAt()");
    }
  }
  isEqual(other) {
    return gu(this._delegate, other._delegate);
  }
  get(options2) {
    let query;
    if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "cache") {
      query = th(this._delegate);
    } else if ((options2 === null || options2 === void 0 ? void 0 : options2.source) === "server") {
      query = eh(this._delegate);
    } else {
      query = Za(this._delegate);
    }
    return query.then((result) => new QuerySnapshot(this.firestore, new Ta(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));
  }
  onSnapshot(...args) {
    const options2 = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (snap) => new QuerySnapshot(this.firestore, new Ta(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));
    return oh(this._delegate, options2, observer);
  }
  withConverter(converter) {
    return new Query(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
}
class DocumentChange {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get type() {
    return this._delegate.type;
  }
  get doc() {
    return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
  }
  get oldIndex() {
    return this._delegate.oldIndex;
  }
  get newIndex() {
    return this._delegate.newIndex;
  }
}
class QuerySnapshot {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get query() {
    return new Query(this._firestore, this._delegate.query);
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get size() {
    return this._delegate.size;
  }
  get empty() {
    return this._delegate.empty;
  }
  get docs() {
    return this._delegate.docs.map((doc) => new QueryDocumentSnapshot(this._firestore, doc));
  }
  docChanges(options2) {
    return this._delegate.docChanges(options2).map((docChange) => new DocumentChange(this._firestore, docChange));
  }
  forEach(callback, thisArg) {
    this._delegate.forEach((snapshot) => {
      callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));
    });
  }
  isEqual(other) {
    return Aa(this._delegate, other._delegate);
  }
}
class CollectionReference extends Query {
  constructor(firestore2, _delegate) {
    super(firestore2, _delegate);
    this.firestore = firestore2;
    this._delegate = _delegate;
  }
  get id() {
    return this._delegate.id;
  }
  get path() {
    return this._delegate.path;
  }
  get parent() {
    const docRef = this._delegate.parent;
    return docRef ? new DocumentReference(this.firestore, docRef) : null;
  }
  doc(documentPath) {
    try {
      if (documentPath === void 0) {
        return new DocumentReference(this.firestore, _u(this._delegate));
      } else {
        return new DocumentReference(this.firestore, _u(this._delegate, documentPath));
      }
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "CollectionReference.doc()");
    }
  }
  add(data) {
    return rh(this._delegate, data).then((docRef) => new DocumentReference(this.firestore, docRef));
  }
  isEqual(other) {
    return mu(this._delegate, other._delegate);
  }
  withConverter(converter) {
    return new CollectionReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
}
function castReference(documentRef) {
  return cast(documentRef, hu);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function loadBundle(data) {
  return Ou(this._delegate, data);
}
function namedQuery(queryName) {
  return $u(this._delegate, queryName).then((expQuery) => {
    if (!expQuery) {
      return null;
    }
    return new Query(this, expQuery);
  });
}
function registerBundle(instance) {
  instance.prototype.loadBundle = loadBundle;
  instance.prototype.namedQuery = namedQuery;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldPath$1 {
  constructor(...fieldNames) {
    this._delegate = new Fu(...fieldNames);
  }
  static documentId() {
    return new FieldPath$1(FieldPath.keyField().canonicalString());
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof Fu)) {
      return false;
    }
    return this._delegate._internalPath.isEqual(other._internalPath);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldValue {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static serverTimestamp() {
    const delegate = dh();
    delegate._methodName = "FieldValue.serverTimestamp";
    return new FieldValue(delegate);
  }
  static delete() {
    const delegate = fh();
    delegate._methodName = "FieldValue.delete";
    return new FieldValue(delegate);
  }
  static arrayUnion(...elements) {
    const delegate = wh(...elements);
    delegate._methodName = "FieldValue.arrayUnion";
    return new FieldValue(delegate);
  }
  static arrayRemove(...elements) {
    const delegate = _h(...elements);
    delegate._methodName = "FieldValue.arrayRemove";
    return new FieldValue(delegate);
  }
  static increment(n2) {
    const delegate = mh(n2);
    delegate._methodName = "FieldValue.increment";
    return new FieldValue(delegate);
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const firestoreNamespace = {
  Firestore,
  GeoPoint: Uu,
  Timestamp: U,
  Blob,
  Transaction,
  WriteBatch,
  DocumentReference,
  DocumentSnapshot,
  Query,
  QueryDocumentSnapshot,
  QuerySnapshot,
  CollectionReference,
  FieldPath: FieldPath$1,
  FieldValue,
  setLogLevel: setLogLevel$1,
  CACHE_SIZE_UNLIMITED: Tu
};
function configureForFirebase(firebase2, firestoreFactory) {
  firebase2.INTERNAL.registerComponent(new Component("firestore-compat", (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const firestoreExp = container.getProvider("firestore-exp").getImmediate();
    return firestoreFactory(app, firestoreExp);
  }, "PUBLIC").setServiceProps(Object.assign({}, firestoreNamespace)));
}
const name = "@firebase/firestore-compat";
const version$1 = "0.0.900-exp.894b5da5a";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerFirestore(instance) {
  configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));
  instance.registerVersion(name, version$1);
}
registerFirestore(firebase$1);
registerBundle(Firestore);
dotenv.config();
var config = {
  apiKey: process.env["FIREBASE_API_KEY"],
  authDomain: "winepottle.firebaseapp.com",
  projectId: "winepottle",
  storageBucket: "winepottle.appspot.com",
  messagingSenderId: "118092403337",
  appId: "1:118092403337:web:1cf5c3e510b9b19b91ac58",
  measurementId: "G-6KTPW3P72Y"
};
firebase$1.initializeApp(config);
const auth = firebase$1.auth();
new firebase$1.auth.GoogleAuthProvider();
const firestore = firebase$1.firestore();
const usersCollection = firestore.collection("users");
const venuesCollection = firestore.collection("venues");
const venueMembersCollection = firestore.collection("venueMembers");
const postsCollection = firestore.collection("posts");
const articlesCollection = firestore.collection("articles");
const winelistCollection = firestore.collection("wineLists");
const handle = async ({request, render: render2}) => {
  var _a2;
  try {
    if (auth.currentUser) {
      request.locals.user = auth.currentUser;
    }
    const cookies = cookie.parse(((_a2 = request.headers) == null ? void 0 : _a2.cookie) || "");
    const venueId = cookies.venueId;
    if (venueId) {
      request.locals.venueId = venueId;
    }
    return await render2(request);
  } catch (err) {
    console.log("Handle error:");
    console.log(err);
  }
};
const getSession = async (request) => {
  var _a2, _b;
  try {
    let user = null;
    let venue = null;
    if (request.locals.user) {
      const userProfile = await usersCollection.doc((_a2 = request.locals.user) == null ? void 0 : _a2.uid).get();
      user = {
        id: request.locals.user.uid,
        name: userProfile.data().name,
        email: (_b = request.locals.user) == null ? void 0 : _b.email
      };
    }
    if (request.locals.venueId) {
      const doc = await venuesCollection.doc(request.locals.venueId).get();
      venue = {id: doc.id, name: doc.data().name, route: doc.data().route};
    }
    return {
      user,
      venue
    };
  } catch (err) {
    console.log("getSession error:");
    console.log(err);
  }
};
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  handle,
  getSession
});
const template = ({head, body}) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.ico" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
let options = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-0fb2d957.js",
      css: ["/./_app/assets/start-a8cd1609.css"],
      js: ["/./_app/start-0fb2d957.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/singletons-bb9012b7.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id2) => "/./_app/" + entry_lookup[id2],
    get_stack: (error2) => String(error2),
    handle_error: (error2) => {
      console.error(error2.stack);
      error2.stack = options.get_stack(error2);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
const d = decodeURIComponent;
const empty = () => ({});
const manifest = {
  assets: [],
  layout: "src/routes/__layout.svelte",
  error: "src/routes/__error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/images\/upload\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return upload;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/images\/venues\/([^/]+?)\.json$/,
      params: (m) => ({venue: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return _venue__json;
      })
    },
    {
      type: "page",
      pattern: /^\/logout\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/logout.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\.json$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return index_json$3;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/joinVenue\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return joinVenue;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/create\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return create$1;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/create\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/venues/create.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/enter\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return enter;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/leave\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return leave;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/join\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/venues/join.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/([^/]+?)\.json$/,
      params: (m) => ({id: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return _id__json$1;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/([^/]+?)\/?$/,
      params: (m) => ({venue: d(m[1])}),
      a: ["src/routes/__layout.svelte", "src/routes/venues/[venue]/__layout.svelte", "src/routes/venues/[venue]/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/([^/]+?)\/articles\.json$/,
      params: (m) => ({venue: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return index_json$2;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/([^/]+?)\/articles\/?$/,
      params: (m) => ({venue: d(m[1])}),
      a: ["src/routes/__layout.svelte", "src/routes/venues/[venue]/__layout.svelte", "src/routes/venues/[venue]/articles/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/([^/]+?)\/articles\/preview\/?$/,
      params: (m) => ({venue: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return preview;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/([^/]+?)\/gallery\/?$/,
      params: (m) => ({venue: d(m[1])}),
      a: ["src/routes/__layout.svelte", "src/routes/venues/[venue]/__layout.svelte", "src/routes/venues/[venue]/gallery/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/venues\/([^/]+?)\/reading\/?$/,
      params: (m) => ({venue: d(m[1])}),
      a: ["src/routes/__layout.svelte", "src/routes/venues/[venue]/__layout.svelte", "src/routes/venues/[venue]/reading/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/([^/]+?)\/lists\.json$/,
      params: (m) => ({venue: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return index_json$1;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/([^/]+?)\/lists\/?$/,
      params: (m) => ({venue: d(m[1])}),
      a: ["src/routes/__layout.svelte", "src/routes/venues/[venue]/__layout.svelte", "src/routes/venues/[venue]/lists/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/venues\/([^/]+?)\/posts\.json$/,
      params: (m) => ({venue: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return index_json;
      })
    },
    {
      type: "page",
      pattern: /^\/venues\/([^/]+?)\/posts\/?$/,
      params: (m) => ({venue: d(m[1])}),
      a: ["src/routes/__layout.svelte", "src/routes/venues/[venue]/__layout.svelte", "src/routes/venues/[venue]/posts/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/login\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/login.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/users\/([^/]+?)\.json$/,
      params: (m) => ({id: d(m[1])}),
      load: () => Promise.resolve().then(function() {
        return _id__json;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/auth\/register\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return register;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/auth\/logout\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return logout$1;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/auth\/login\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return login$1;
      })
    }
  ]
};
const get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({request, render: render2}) => render2(request))
});
const module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout$1;
  }),
  "src/routes/__error.svelte": () => Promise.resolve().then(function() {
    return __error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$6;
  }),
  "src/routes/logout.svelte": () => Promise.resolve().then(function() {
    return logout;
  }),
  "src/routes/venues/create.svelte": () => Promise.resolve().then(function() {
    return create;
  }),
  "src/routes/venues/join.svelte": () => Promise.resolve().then(function() {
    return join;
  }),
  "src/routes/venues/[venue]/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/venues/[venue]/index.svelte": () => Promise.resolve().then(function() {
    return index$5;
  }),
  "src/routes/venues/[venue]/articles/index.svelte": () => Promise.resolve().then(function() {
    return index$4;
  }),
  "src/routes/venues/[venue]/gallery/index.svelte": () => Promise.resolve().then(function() {
    return index$3;
  }),
  "src/routes/venues/[venue]/reading/index.svelte": () => Promise.resolve().then(function() {
    return index$2;
  }),
  "src/routes/venues/[venue]/lists/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/venues/[venue]/posts/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/login.svelte": () => Promise.resolve().then(function() {
    return login;
  })
};
const metadata_lookup = {"src/routes/__layout.svelte": {"entry": "/./_app/pages/__layout.svelte-418b2358.js", "css": ["/./_app/assets/pages/__layout.svelte-a895d72f.css", "/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Card.svelte_svelte&type=style&lang-8d10bf93.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/__layout.svelte-418b2358.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/stores-6ec92c62.js"], "styles": null}, "src/routes/__error.svelte": {"entry": "/./_app/pages/__error.svelte-bbf7b10d.js", "css": [], "js": ["/./_app/pages/__error.svelte-bbf7b10d.js", "/./_app/chunks/vendor-197173f7.js"], "styles": null}, "src/routes/index.svelte": {"entry": "/./_app/pages/index.svelte-d15cd7ec.js", "css": ["/./_app/assets/pages/index.svelte-b5310335.css", "/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css"], "js": ["/./_app/pages/index.svelte-d15cd7ec.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/ErrorAlert-f76ade2a.js", "/./_app/chunks/stores-23449eec.js"], "styles": null}, "src/routes/logout.svelte": {"entry": "/./_app/pages/logout.svelte-79b48dd2.js", "css": [], "js": ["/./_app/pages/logout.svelte-79b48dd2.js", "/./_app/chunks/vendor-197173f7.js"], "styles": null}, "src/routes/venues/create.svelte": {"entry": "/./_app/pages/venues/create.svelte-3c819fa0.js", "css": ["/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/venues/create.svelte-3c819fa0.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/ErrorAlert-f76ade2a.js"], "styles": null}, "src/routes/venues/join.svelte": {"entry": "/./_app/pages/venues/join.svelte-8ff29950.js", "css": ["/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/venues/join.svelte-8ff29950.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/ErrorAlert-f76ade2a.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js"], "styles": null}, "src/routes/venues/[venue]/__layout.svelte": {"entry": "/./_app/pages/venues/[venue]/__layout.svelte-a61515f1.js", "css": ["/./_app/assets/pages/venues/[venue]/__layout.svelte-49be5634.css"], "js": ["/./_app/pages/venues/[venue]/__layout.svelte-a61515f1.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/stores-23449eec.js"], "styles": null}, "src/routes/venues/[venue]/index.svelte": {"entry": "/./_app/pages/venues/[venue]/index.svelte-71c39c8c.js", "css": [], "js": ["/./_app/pages/venues/[venue]/index.svelte-71c39c8c.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/stores-23449eec.js"], "styles": null}, "src/routes/venues/[venue]/articles/index.svelte": {"entry": "/./_app/pages/venues/[venue]/articles/index.svelte-d2ca28bd.js", "css": ["/./_app/assets/pages/venues/[venue]/articles/index.svelte-e27b47ed.css", "/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/venues/[venue]/articles/index.svelte-d2ca28bd.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/firebase-d84582fa.js", "/./_app/chunks/utils-ccc08853.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/ErrorAlert-f76ade2a.js", "/./_app/chunks/stores-23449eec.js"], "styles": null}, "src/routes/venues/[venue]/gallery/index.svelte": {"entry": "/./_app/pages/venues/[venue]/gallery/index.svelte-c1282500.js", "css": ["/./_app/assets/pages/venues/[venue]/gallery/index.svelte-b2586ffd.css", "/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/venues/[venue]/gallery/index.svelte-c1282500.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/ErrorAlert-f76ade2a.js"], "styles": null}, "src/routes/venues/[venue]/reading/index.svelte": {"entry": "/./_app/pages/venues/[venue]/reading/index.svelte-e23e1322.js", "css": [], "js": ["/./_app/pages/venues/[venue]/reading/index.svelte-e23e1322.js", "/./_app/chunks/vendor-197173f7.js"], "styles": null}, "src/routes/venues/[venue]/lists/index.svelte": {"entry": "/./_app/pages/venues/[venue]/lists/index.svelte-7fea6af7.js", "css": ["/./_app/assets/pages/venues/[venue]/lists/index.svelte-7efc5826.css", "/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/venues/[venue]/lists/index.svelte-7fea6af7.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/firebase-d84582fa.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/utils-ccc08853.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/ErrorAlert-f76ade2a.js"], "styles": null}, "src/routes/venues/[venue]/posts/index.svelte": {"entry": "/./_app/pages/venues/[venue]/posts/index.svelte-12be3dd0.js", "css": ["/./_app/assets/pages/venues/[venue]/posts/index.svelte-46e952dc.css", "/./_app/assets/Card.svelte_svelte&type=style&lang-8d10bf93.css", "/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/venues/[venue]/posts/index.svelte-12be3dd0.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/Card-4907b462.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/ErrorAlert-f76ade2a.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/utils-ccc08853.js"], "styles": null}, "src/routes/login.svelte": {"entry": "/./_app/pages/login.svelte-8da2c063.js", "css": ["/./_app/assets/ErrorAlert.svelte_svelte&type=style&lang-acc52312.css", "/./_app/assets/Card.svelte_svelte&type=style&lang-8d10bf93.css", "/./_app/assets/Button-398cc11c.css"], "js": ["/./_app/pages/login.svelte-8da2c063.js", "/./_app/chunks/vendor-197173f7.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/ErrorAlert-f76ade2a.js", "/./_app/chunks/Card-4907b462.js", "/./_app/chunks/Button-80d06a7e.js", "/./_app/chunks/stores-23449eec.js", "/./_app/chunks/stores-6ec92c62.js"], "styles": null}};
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init({paths: {"base": "", "assets": "/."}});
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond$1({...request, host}, options, {prerender});
}
async function post$a(request) {
  try {
    await fetch(`https://api.cloudinary.com/v1_1/${"dkj7bctqg"}/image/upload`, {
      method: "post",
      body: request.body
    });
    return {
      body: {
        ok: true
      }
    };
  } catch (err) {
    return {
      status: 500
    };
  }
}
var upload = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$a
});
dotenv.config();
v2.config({
  cloud_name: "dkj7bctqg",
  api_key: process.env["CLOUDINARY_API_KEY"],
  api_secret: process.env["CLOUDINARY_API_SECRET"]
});
async function get$5({params, query}) {
  const venue = params.venue;
  const next = query.get("next");
  try {
    const gallery = await v2.api.resources_by_tag(venue, {
      max_results: 5,
      next_cursor: next
    });
    return {
      body: JSON.stringify(gallery)
    };
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var _venue__json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$5
});
async function get$4(request) {
  const {query} = request;
  const venues = [];
  const venueSnapshot = await venuesCollection.get();
  venueSnapshot.forEach((doc) => venues.push({
    id: doc.id,
    name: doc.data().name,
    route: doc.data().route
  }));
  if (query.get("userId")) {
    const userVenueMemberships = [];
    const uvmSnapshot = await venueMembersCollection.where("userId", "==", query.get("userId")).get();
    if (!uvmSnapshot.empty)
      uvmSnapshot.forEach((doc) => userVenueMemberships.push({
        id: doc.id,
        venueId: doc.data().venueId,
        userId: doc.data().userId
      }));
    return {
      body: {
        venues,
        userVenueMemberships
      }
    };
  }
  return {
    body: {
      venues
    }
  };
}
var index_json$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$4
});
async function post$9(request) {
  try {
    const doc = await venuesCollection.doc(request.body.venueId).get();
    const venue = {
      id: doc.id,
      name: doc.data().name,
      route: doc.data().route,
      password: doc.data().password
    };
    if (venue.password === request.body.password) {
      await venueMembersCollection.add({
        venueId: venue.id,
        userId: request.body.userId
      });
      return {
        status: 200,
        headers: {
          "set-cookie": `venueId=${venue.id}; Path=/; HttpOnly`
        },
        body: {
          ok: true
        }
      };
    } else {
      return {
        status: 504,
        body: {
          errors: "Incorrect password"
        }
      };
    }
  } catch (err) {
    return {
      status: 500,
      body: {
        errors: err
      }
    };
  }
}
var joinVenue = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$9
});
async function post$8({
  body
}) {
  try {
    const {name: name2, userId, password} = body;
    const route = encodeURIComponent(name2.toLowerCase().split(" ").join("-"));
    const venueRef = await venuesCollection.add({
      name: name2,
      password,
      route
    });
    await venueMembersCollection.add({
      venueId: venueRef.id,
      userId
    });
    return {
      status: 200,
      body: {
        id: venueRef.id,
        route
      }
    };
  } catch (err) {
    return {
      status: 500,
      body: {
        errors: err
      }
    };
  }
}
var create$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$8
});
async function get$3({query}) {
  const venueId = query.get("venueId");
  const route = query.get("route");
  return {
    headers: {
      "set-cookie": `venueId=${venueId}; Path=/; HttpOnly`,
      "location": route
    },
    status: 308
  };
}
var enter = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$3
});
function post$7() {
  return {
    headers: {
      "set-cookie": "venueId=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT"
    },
    body: {
      ok: true
    }
  };
}
var leave = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$7
});
async function get$2(request) {
  try {
    const {params} = request;
    const {id: id2} = params;
    const resp = await venuesCollection.doc(id2).get();
    const venue = {
      id: resp.id,
      name: resp.data().name,
      route: resp.data().route
    };
    return {
      body: {
        venue
      }
    };
  } catch (err) {
    return {
      status: 404
    };
  }
}
var _id__json$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$2
});
async function post$6({body}) {
  try {
    const {userId, venueId, href, datetime} = body;
    const ref = await articlesCollection.add({
      userId,
      venueId,
      href,
      datetime
    });
    return {
      body: {
        id: ref.id
      }
    };
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var index_json$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$6
});
async function post$5({body}) {
  try {
    const url = body.url;
    const preview2 = await getLinkPreview(url);
    return {
      body: preview2
    };
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var preview = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$5
});
async function post$4({body}) {
  try {
    const ref = await winelistCollection.add(body);
    return {
      body: {
        id: ref.id
      }
    };
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var index_json$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$4
});
async function get$1({query}) {
  try {
    const venueId = query.get("venueId");
    const docs = await postsCollection.where("venueId", "==", venueId).get();
    const posts = [];
    if (!docs.empty) {
      docs.forEach((doc) => posts.push({
        ...doc.data(),
        id: doc.id
      }));
    }
    return {
      body: {
        posts
      }
    };
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
async function post$3({body}) {
  try {
    const response = await postsCollection.add(body);
    return {
      body: {
        postId: response.id
      }
    };
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var index_json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get: get$1,
  post: post$3
});
async function get(request) {
  try {
    const {params} = request;
    const {id: id2} = params;
    const resp = await usersCollection.doc(id2).get();
    const user = {
      id: resp.id,
      name: resp.data().name,
      email: resp.data().email
    };
    return {
      body: user
    };
  } catch (err) {
    return {
      status: 404
    };
  }
}
var _id__json = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
async function respond(body) {
  const creds = body;
  const user = creds.user;
  const json = JSON.stringify(await user.getIdToken());
  const value = Buffer.from(json).toString("base64");
  return {
    headers: {
      "set-cookie": `jwt=${value}; Path=/; HttpOnly`
    },
    body: JSON.stringify(creds)
  };
}
async function respondLogout() {
  return {
    headers: {
      "set-cookie": ["jwt=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT", "venueId=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT"]
    },
    body: {
      ok: true
    }
  };
}
async function post$2(request) {
  const newUser = request.body;
  try {
    const response = await auth.createUserWithEmailAndPassword(newUser.email, newUser.password);
    await usersCollection.doc(response.user.uid).set({
      name: newUser.username,
      email: newUser.email
    });
    return respond(response);
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var register = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$2
});
async function post$1() {
  await auth.signOut();
  return respondLogout();
}
var logout$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$1
});
async function post(request) {
  const {email, password} = request.body;
  try {
    const response = await auth.signInWithEmailAndPassword(email, password);
    return respond(response);
  } catch (err) {
    return {
      body: {
        errors: err
      }
    };
  }
}
var login$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post
});
const ssr = typeof window === "undefined";
const getStores = () => {
  const stores = getContext("__svelte__");
  return {
    page: {
      subscribe: stores.page.subscribe
    },
    navigating: {
      subscribe: stores.navigating.subscribe
    },
    get preloading() {
      console.error("stores.preloading is deprecated; use stores.navigating instead");
      return {
        subscribe: stores.navigating.subscribe
      };
    },
    session: stores.session
  };
};
const error = (verb) => {
  throw new Error(ssr ? `Can only ${verb} session store in browser` : `Cannot ${verb} session store before subscribing`);
};
const session = {
  subscribe(fn2) {
    const store = getStores().session;
    if (!ssr) {
      session.set = store.set;
      session.update = store.update;
    }
    return store.subscribe(fn2);
  },
  set: (value) => {
    error("set");
  },
  update: (updater) => {
    error("update");
  }
};
var ErrorAlert_svelte_svelte_type_style_lang = "div.svelte-eb3fio{padding:10px 20px;border:1px solid tomato;border-radius:2px;color:tomato}";
const css$9 = {
  code: "div.svelte-eb3fio{padding:10px 20px;border:1px solid tomato;border-radius:2px;color:tomato}",
  map: '{"version":3,"file":"ErrorAlert.svelte","sources":["ErrorAlert.svelte"],"sourcesContent":["<!-- ****** Logic ****** -->\\r\\n<script lang=\\"ts\\">export let message;\\r\\n</script>\\r\\n\\r\\n<!-- ****** Styling ****** -->\\r\\n<style>\\r\\n    div {\\r\\n        padding: 10px 20px;\\r\\n        border: 1px solid tomato;\\r\\n        border-radius: 2px;\\r\\n        color: tomato;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<!-- ****** Markup ****** -->\\r\\n<div>\\r\\n    {message}\\r\\n</div>"],"names":[],"mappings":"AAMI,GAAG,cAAC,CAAC,AACD,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,MAAM,CACxB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,MAAM,AACjB,CAAC"}'
};
const ErrorAlert = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {message} = $$props;
  if ($$props.message === void 0 && $$bindings.message && message !== void 0)
    $$bindings.message(message);
  $$result.css.add(css$9);
  return `






<div class="${"svelte-eb3fio"}">${escape(message)}</div>`;
});
var Card_svelte_svelte_type_style_lang = ".cardContainer.svelte-1trv6g{border:1px solid black;border-radius:5px}.cardTitle.svelte-1trv6g{border-bottom:1px solid red;font-size:x-large;color:white;background-color:black}.cardContent.svelte-1trv6g{padding:5px;font-style:italic}";
const css$8 = {
  code: ".cardContainer.svelte-1trv6g{border:1px solid black;border-radius:5px}.cardTitle.svelte-1trv6g{border-bottom:1px solid red;font-size:x-large;color:white;background-color:black}.cardContent.svelte-1trv6g{padding:5px;font-style:italic}",
  map: '{"version":3,"file":"Card.svelte","sources":["Card.svelte"],"sourcesContent":["<script lang=\\"ts\\">export let title = \\"\\";\\r\\n</script>\\r\\n\\r\\n<style>\\r\\n    .cardContainer {\\r\\n        border: 1px solid black;\\r\\n        border-radius: 5px;\\r\\n    }\\r\\n    .cardTitle {\\r\\n        border-bottom: 1px solid red;\\r\\n        font-size: x-large;\\r\\n        color: white;\\r\\n        background-color: black;\\r\\n    }\\r\\n    .cardContent {\\r\\n        padding: 5px;\\r\\n        font-style: italic;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<div class=\\"cardContainer\\">\\r\\n    <div class=\\"cardTitle\\">{title}</div>\\r\\n    <div class=\\"cardContent\\">\\r\\n        <slot></slot>\\r\\n    </div>\\r\\n</div>"],"names":[],"mappings":"AAII,cAAc,cAAC,CAAC,AACZ,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,aAAa,CAAE,GAAG,AACtB,CAAC,AACD,UAAU,cAAC,CAAC,AACR,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,GAAG,CAC5B,SAAS,CAAE,OAAO,CAClB,KAAK,CAAE,KAAK,CACZ,gBAAgB,CAAE,KAAK,AAC3B,CAAC,AACD,YAAY,cAAC,CAAC,AACV,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,MAAM,AACtB,CAAC"}'
};
const Card = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {title = ""} = $$props;
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  $$result.css.add(css$8);
  return `<div class="${"cardContainer svelte-1trv6g"}"><div class="${"cardTitle svelte-1trv6g"}">${escape(title)}</div>
    <div class="${"cardContent svelte-1trv6g"}">${slots.default ? slots.default({}) : ``}</div></div>`;
});
var Button_svelte_svelte_type_style_lang = "button.svelte-qk5r0g{padding:5px 10px;background-color:darkgray;border:none;color:white;border-radius:2px;cursor:pointer;font-size:18px}.primary.svelte-qk5r0g{background-color:cornflowerblue}.secondary.svelte-qk5r0g{background-color:darkcyan}.danger.svelte-qk5r0g{background-color:tomato}";
const css$7 = {
  code: "button.svelte-qk5r0g{padding:5px 10px;background-color:darkgray;border:none;color:white;border-radius:2px;cursor:pointer;font-size:18px}.primary.svelte-qk5r0g{background-color:cornflowerblue}.secondary.svelte-qk5r0g{background-color:darkcyan}.danger.svelte-qk5r0g{background-color:tomato}",
  map: `{"version":3,"file":"Button.svelte","sources":["Button.svelte"],"sourcesContent":["<!-- ****** Logic ****** -->\\r\\n<script lang=\\"ts\\">export let variant = 'primary';\\r\\nexport let type = 'button';\\r\\n</script>\\r\\n\\r\\n<!-- ****** Styling ****** -->\\r\\n<style>\\r\\n    button {\\r\\n        padding: 5px 10px;\\r\\n        background-color: darkgray;\\r\\n        border: none;\\r\\n        color: white;\\r\\n        border-radius: 2px;\\r\\n        cursor: pointer;\\r\\n        font-size: 18px;\\r\\n    }\\r\\n    .primary {\\r\\n        background-color: cornflowerblue;\\r\\n    }\\r\\n    .secondary {\\r\\n        background-color: darkcyan;\\r\\n    }\\r\\n    .danger {\\r\\n        background-color: tomato;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<!-- ****** Markup ****** -->\\r\\n<button class={variant} {type} on:click>\\r\\n    <slot></slot>\\r\\n</button>"],"names":[],"mappings":"AAOI,MAAM,cAAC,CAAC,AACJ,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,gBAAgB,CAAE,QAAQ,CAC1B,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,IAAI,AACnB,CAAC,AACD,QAAQ,cAAC,CAAC,AACN,gBAAgB,CAAE,cAAc,AACpC,CAAC,AACD,UAAU,cAAC,CAAC,AACR,gBAAgB,CAAE,QAAQ,AAC9B,CAAC,AACD,OAAO,cAAC,CAAC,AACL,gBAAgB,CAAE,MAAM,AAC5B,CAAC"}`
};
const Button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {variant = "primary"} = $$props;
  let {type = "button"} = $$props;
  if ($$props.variant === void 0 && $$bindings.variant && variant !== void 0)
    $$bindings.variant(variant);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  $$result.css.add(css$7);
  return `






<button class="${escape(null_to_empty(variant)) + " svelte-qk5r0g"}"${add_attribute("type", type, 0)}>${slots.default ? slots.default({}) : ``}</button>`;
});
const loading = writable(false);
const Auth = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_loading;
  let $$unsubscribe_session;
  $$unsubscribe_loading = subscribe(loading, (value) => value);
  $$unsubscribe_session = subscribe(session, (value) => value);
  (function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let {authMode = "login"} = $$props;
  let email = "";
  let username = "";
  let password = "";
  let confirmPassword = "";
  if ($$props.authMode === void 0 && $$bindings.authMode && authMode !== void 0)
    $$bindings.authMode(authMode);
  $$unsubscribe_loading();
  $$unsubscribe_session();
  return `






${validate_component(Card, "Card").$$render($$result, {
    title: authMode === "login" ? "Login" : "Register"
  }, {}, {
    default: () => `<div>${validate_component(Button, "Button").$$render($$result, {
      variant: authMode === "login" ? "secondary" : "primary"
    }, {}, {default: () => `Login`})}
        ${validate_component(Button, "Button").$$render($$result, {
      variant: authMode === "register" ? "secondary" : "primary"
    }, {}, {default: () => `Register`})}</div>
    ${authMode === "login" ? `<div>${``}
            <h4>Login</h4>    
            <div><label for="${"loginEmail"}">Email</label>
                <input id="${"loginEmail"}" type="${"email"}" placeholder="${"Enter your email address"}"${add_attribute("value", email, 1)}></div>
            <div><label for="${"loginPassword"}">Password</label>
                <input id="${"loginPassword"}" type="${"password"}" placeholder="${"Enter your password"}"${add_attribute("value", password, 1)}></div>
            <div>${validate_component(Button, "Button").$$render($$result, {variant: "primary"}, {}, {default: () => `Login`})}</div></div>` : `<div>${``}
            <h4>Register</h4>
            <div><label for="${"registerName"}">Username</label>
                <input id="${"registerName"}" type="${"text"}" placeholder="${"Enter you username"}"${add_attribute("value", username, 1)}></div>    
            <div><label for="${"registerEmail"}">Email</label>
                <input id="${"registerEmail"}" type="${"email"}" placeholder="${"Enter your email address"}"${add_attribute("value", email, 1)}></div>
            <div><label for="${"registerPassword"}">Password</label>
                <input id="${"registerPassword"}" type="${"password"}" placeholder="${"Enter your password"}"${add_attribute("value", password, 1)}></div>
            <div><label for="${"confirmRegisterPassword"}">Password</label>
                <input id="${"confirmRegisterPassword"}" type="${"password"}" placeholder="${"Enter your password"}"${add_attribute("value", confirmPassword, 1)}></div>
            <div>${validate_component(Button, "Button").$$render($$result, {variant: "primary"}, {}, {default: () => `Register`})}</div></div>`}`
  })}`;
});
var __layout_svelte_svelte_type_style_lang$1 = "#svelte{font-family:Verdana, Geneva, Tahoma, sans-serif;min-height:100vh;display:flex;flex-direction:column;margin:0}a{text-decoration:none;color:inherit}input, textarea{padding:4px 5px;font-family:inherit;border:1px solid black;border-radius:3px;box-shadow:none;font-size:inherit;margin-bottom:5px}textarea{width:100%;box-sizing:border-box}header.svelte-158lxlq{display:flex;flex-direction:column;height:50px;border-bottom:1px solid black;color:white;background-color:mediumslateblue;font-weight:bold}#topNav.svelte-158lxlq{flex:auto;display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding:0px 20px}main.svelte-158lxlq{flex:1 1 auto;display:flex;flex-direction:column;text-align:center;padding:20px 350px}footer.svelte-158lxlq{display:flex;flex-direction:row;justify-content:center}";
const css$6 = {
  code: "#svelte{font-family:Verdana, Geneva, Tahoma, sans-serif;min-height:100vh;display:flex;flex-direction:column;margin:0}a{text-decoration:none;color:inherit}input, textarea{padding:4px 5px;font-family:inherit;border:1px solid black;border-radius:3px;box-shadow:none;font-size:inherit;margin-bottom:5px}textarea{width:100%;box-sizing:border-box}header.svelte-158lxlq{display:flex;flex-direction:column;height:50px;border-bottom:1px solid black;color:white;background-color:mediumslateblue;font-weight:bold}#topNav.svelte-158lxlq{flex:auto;display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding:0px 20px}main.svelte-158lxlq{flex:1 1 auto;display:flex;flex-direction:column;text-align:center;padding:20px 350px}footer.svelte-158lxlq{display:flex;flex-direction:row;justify-content:center}",
  map: `{"version":3,"file":"__layout.svelte","sources":["__layout.svelte"],"sourcesContent":["<script context=\\"module\\" lang=\\"ts\\">;\\r\\nexport const load = ({ session, page }) => {\\r\\n    if (!session.user && !page.path.includes('login')) {\\r\\n        return {\\r\\n            status: 302,\\r\\n            redirect: '/login'\\r\\n        };\\r\\n    }\\r\\n    return {\\r\\n        props: {}\\r\\n    };\\r\\n};\\r\\n</script>\\r\\n\\r\\n<script lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nimport { goto } from '$app/navigation';\\r\\nimport { session } from '$app/stores';\\r\\nimport Auth from '$lib/components/Auth.svelte';\\r\\nimport Button from '$lib/components/Button.svelte';\\r\\nimport { loading } from '$lib/stores';\\r\\nfunction logout() {\\r\\n    return __awaiter(this, void 0, void 0, function* () {\\r\\n        //console.log(\\"Logout function called at \\" + new Date().toISOString());\\r\\n        yield fetch('/auth/logout', {\\r\\n            method: 'post'\\r\\n        });\\r\\n        goto('/logout');\\r\\n    });\\r\\n}\\r\\n</script>\\r\\n\\r\\n<style>\\r\\n    :global(#svelte) {\\r\\n        font-family: Verdana, Geneva, Tahoma, sans-serif;\\r\\n        min-height: 100vh;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        margin: 0;\\r\\n    }\\r\\n    :global(a) {\\r\\n        text-decoration: none;\\r\\n        color: inherit;\\r\\n    }\\r\\n    :global(input, textarea) {\\r\\n        padding: 4px 5px;\\r\\n        font-family: inherit;\\r\\n        border: 1px solid black;\\r\\n        border-radius: 3px;\\r\\n        box-shadow: none;\\r\\n        font-size: inherit;\\r\\n        margin-bottom: 5px;\\r\\n    }\\r\\n    :global(textarea) {\\r\\n        width: 100%;\\r\\n        box-sizing: border-box;\\r\\n    }\\r\\n    header {\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        height: 50px;\\r\\n        border-bottom: 1px solid black;     \\r\\n        color: white;\\r\\n        background-color:mediumslateblue;  \\r\\n        font-weight: bold;\\r\\n    }\\r\\n    #topNav {\\r\\n        flex: auto;\\r\\n        display: flex;\\r\\n        flex-direction: row;\\r\\n        justify-content: space-between;\\r\\n        align-items: center;\\r\\n        padding: 0px 20px;\\r\\n    }\\r\\n    main {\\r\\n        flex: 1 1 auto;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        text-align: center;\\r\\n        padding: 20px 350px;\\r\\n    }\\r\\n    footer {\\r\\n        display: flex;\\r\\n        flex-direction: row;\\r\\n        justify-content: center;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<header>\\r\\n    <nav id=\\"topNav\\">\\r\\n        <a id='winePottleLogo' href=\\"/\\">Wine Pottle</a>\\r\\n        <div>\\r\\n            {#if $loading}\\r\\n                <p>Loading...</p>\\r\\n            {/if}\\r\\n        </div>\\r\\n        <div id='topNavRight'>\\r\\n            {#if $session.user}\\r\\n                <a href={\`/profile/\${$session.user.name}\`} style=\\"margin: 0px 20px\\">{$session.user.name}</a>\\r\\n                <Button variant='primary' on:click={logout}>Logout</Button>\\r\\n            {:else}\\r\\n                <a href='/login'>Login</a>\\r\\n            {/if}\\r\\n        </div>\\r\\n    </nav>\\r\\n</header>\\r\\n\\r\\n<main>\\r\\n    <slot></slot>\\r\\n</main>\\r\\n\\r\\n<footer>\\r\\n    <p>&copy; Jasmin Natterer 2021</p>\\r\\n</footer>"],"names":[],"mappings":"AAwCY,OAAO,AAAE,CAAC,AACd,WAAW,CAAE,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,UAAU,CAChD,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,CAAC,AACb,CAAC,AACO,CAAC,AAAE,CAAC,AACR,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,OAAO,AAClB,CAAC,AACO,eAAe,AAAE,CAAC,AACtB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,WAAW,CAAE,OAAO,CACpB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,OAAO,CAClB,aAAa,CAAE,GAAG,AACtB,CAAC,AACO,QAAQ,AAAE,CAAC,AACf,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,UAAU,AAC1B,CAAC,AACD,MAAM,eAAC,CAAC,AACJ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CAC9B,KAAK,CAAE,KAAK,CACZ,iBAAiB,eAAe,CAChC,WAAW,CAAE,IAAI,AACrB,CAAC,AACD,OAAO,eAAC,CAAC,AACL,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,GAAG,CAAC,IAAI,AACrB,CAAC,AACD,IAAI,eAAC,CAAC,AACF,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,IAAI,CAAC,KAAK,AACvB,CAAC,AACD,MAAM,eAAC,CAAC,AACJ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,MAAM,AAC3B,CAAC"}`
};
const load$b = ({session: session2, page}) => {
  if (!session2.user && !page.path.includes("login")) {
    return {status: 302, redirect: "/login"};
  }
  return {props: {}};
};
const _layout$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $loading, $$unsubscribe_loading;
  let $session, $$unsubscribe_session;
  $$unsubscribe_loading = subscribe(loading, (value) => $loading = value);
  $$unsubscribe_session = subscribe(session, (value) => $session = value);
  (function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  $$result.css.add(css$6);
  $$unsubscribe_loading();
  $$unsubscribe_session();
  return `<header class="${"svelte-158lxlq"}"><nav id="${"topNav"}" class="${"svelte-158lxlq"}"><a id="${"winePottleLogo"}" href="${"/"}">Wine Pottle</a>
        <div>${$loading ? `<p>Loading...</p>` : ``}</div>
        <div id="${"topNavRight"}">${$session.user ? `<a${add_attribute("href", `/profile/${$session.user.name}`, 0)} style="${"margin: 0px 20px"}">${escape($session.user.name)}</a>
                ${validate_component(Button, "Button").$$render($$result, {variant: "primary"}, {}, {default: () => `Logout`})}` : `<a href="${"/login"}">Login</a>`}</div></nav></header>

<main class="${"svelte-158lxlq"}">${slots.default ? slots.default({}) : ``}</main>

<footer class="${"svelte-158lxlq"}"><p>\xA9 Jasmin Natterer 2021</p></footer>`;
});
var __layout$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout$1,
  load: load$b
});
const load$a = ({error: error2, status}) => {
  return {
    props: {error: `${status}: ${error2.message}`}
  };
};
const _error = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {error: error2} = $$props;
  if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
    $$bindings.error(error2);
  return `<h1>Oooops! Looks like something went wrong.</h1>
<p>${escape(error2)}</p>`;
});
var __error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _error,
  load: load$a
});
var index_svelte_svelte_type_style_lang$4 = "#newVenueButton.svelte-1trzo8z{margin:25px 0px}";
const css$5 = {
  code: "#newVenueButton.svelte-1trzo8z{margin:25px 0px}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context='module' lang='ts'>var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\n;\\r\\nexport const load = ({ session, fetch }) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    //console.log('Called load function');\\r\\n    if (!session.user) {\\r\\n        return { redirect: 'login', status: 302 };\\r\\n    }\\r\\n    if (session.venue) {\\r\\n        //console.log('Leaving ' + session.venue.name);\\r\\n        yield fetch('/venues/leave', { method: 'post' });\\r\\n    }\\r\\n    //console.log('Getting venues');\\r\\n    try {\\r\\n        const response = yield fetch(\`venues.json?userId=\${session.user.id}\`);\\r\\n        const data = yield response.json();\\r\\n        return {\\r\\n            props: {\\r\\n                venues: data.venues,\\r\\n                uvms: data.userVenueMemberships\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    catch (error) {\\r\\n        console.log(error);\\r\\n    }\\r\\n});\\r\\n</script>\\n\\n<script lang=\\"ts\\">import ErrorAlert from '$lib/components/ErrorAlert.svelte';\\r\\nimport { session } from '$app/stores';\\r\\nexport let venues;\\r\\nexport let uvms;\\r\\nlet err;\\r\\nconst userVenues = uvms.length > 0 ? venues === null || venues === void 0 ? void 0 : venues.filter(v => uvms.some(uv => (uv === null || uv === void 0 ? void 0 : uv.venueId) === v.id)) : [];\\r\\nconst otherVenues = userVenues.length > 0 ? venues === null || venues === void 0 ? void 0 : venues.filter(v => !userVenues.includes(v)) : venues;\\r\\n</script>\\n\\n<style>\\n    #newVenueButton {\\n        margin: 25px 0px;\\n    }\\n</style>\\n\\n<h1>Wine Pottle</h1>\\n\\n{#if err}\\n    <ErrorAlert message={err} />\\n{/if}\\n\\n<section>\\n    {#if $session.user}\\n        <p>Welcome {$session.user.name}</p>\\n        {#if userVenues.length > 0}\\n            <h2>Your Venues</h2>\\n            <div id=\\"userVenues\\">\\n                {#each userVenues as venue}\\n                    <p>\\n                    <a href={\`venues/enter?venueId=\${venue.id}&route=\${venue.route}\`}>{venue.name}</a>\\n                    </p>\\n                {/each}\\n            </div>\\n        {/if}\\n        <div id='newVenueButton'>\\n            <a href='/venues/create'>Create A Venue Channel</a>\\n        </div>\\n        {#if otherVenues.length > 0}\\n            <h2>All Venues</h2>\\n            <div id='allVenues'>\\n                {#each otherVenues as venue}\\n                    <p>\\n                    <a href={\`/venues/join?venue=\${venue.id}\`}>{venue.name}</a>\\n                    </p>\\n                {/each}\\n            </div>\\n        {/if}\\n    {/if}\\n</section>\\n"],"names":[],"mappings":"AA8CI,eAAe,eAAC,CAAC,AACb,MAAM,CAAE,IAAI,CAAC,GAAG,AACpB,CAAC"}`
};
var __awaiter$6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$9 = ({session: session2, fetch: fetch2}) => __awaiter$6(void 0, void 0, void 0, function* () {
  if (!session2.user) {
    return {redirect: "login", status: 302};
  }
  if (session2.venue) {
    yield fetch2("/venues/leave", {method: "post"});
  }
  try {
    const response = yield fetch2(`venues.json?userId=${session2.user.id}`);
    const data = yield response.json();
    return {
      props: {
        venues: data.venues,
        uvms: data.userVenueMemberships
      }
    };
  } catch (error2) {
    console.log(error2);
  }
});
const Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $session, $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => $session = value);
  let {venues} = $$props;
  let {uvms} = $$props;
  const userVenues = uvms.length > 0 ? venues === null || venues === void 0 ? void 0 : venues.filter((v3) => uvms.some((uv) => (uv === null || uv === void 0 ? void 0 : uv.venueId) === v3.id)) : [];
  const otherVenues = userVenues.length > 0 ? venues === null || venues === void 0 ? void 0 : venues.filter((v3) => !userVenues.includes(v3)) : venues;
  if ($$props.venues === void 0 && $$bindings.venues && venues !== void 0)
    $$bindings.venues(venues);
  if ($$props.uvms === void 0 && $$bindings.uvms && uvms !== void 0)
    $$bindings.uvms(uvms);
  $$result.css.add(css$5);
  $$unsubscribe_session();
  return `<h1>Wine Pottle</h1>

${``}

<section>${$session.user ? `<p>Welcome ${escape($session.user.name)}</p>
        ${userVenues.length > 0 ? `<h2>Your Venues</h2>
            <div id="${"userVenues"}">${each(userVenues, (venue) => `<p><a${add_attribute("href", `venues/enter?venueId=${venue.id}&route=${venue.route}`, 0)}>${escape(venue.name)}</a>
                    </p>`)}</div>` : ``}
        <div id="${"newVenueButton"}" class="${"svelte-1trzo8z"}"><a href="${"/venues/create"}">Create A Venue Channel</a></div>
        ${otherVenues.length > 0 ? `<h2>All Venues</h2>
            <div id="${"allVenues"}">${each(otherVenues, (venue) => `<p><a${add_attribute("href", `/venues/join?venue=${venue.id}`, 0)}>${escape(venue.name)}</a>
                    </p>`)}</div>` : ``}` : ``}</section>`;
});
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  load: load$9
});
const load$8 = ({session: session2}) => {
  session2.user = null;
  session2.venue = null;
  return {props: {message: "Bye!"}};
};
const Logout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {message} = $$props;
  if ($$props.message === void 0 && $$bindings.message && message !== void 0)
    $$bindings.message(message);
  return `






<h2>${escape(message)}</h2>

<div><a href="${"/login"}">Login</a></div>`;
});
var logout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Logout,
  load: load$8
});
const Create = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => value);
  (function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let name2 = "";
  let password = "";
  $$unsubscribe_session();
  return `



<h1>New Venue</h1>

<section>${``}
	<form><div><label for="${"venueName"}">Venue Name</label>
			<input id="${"venueName"}" type="${"text"}"${add_attribute("value", name2, 1)}></div>
		<div><label for="${"venuePassword"}">Venue Password</label>
			<input id="${"venuePassword"}" type="${"text"}"${add_attribute("value", password, 1)}></div>
		<div>${validate_component(Button, "Button").$$render($$result, {variant: "primary"}, {}, {default: () => `Create`})}</div></form></section>

`;
});
var create = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Create
});
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$7 = ({page, fetch: fetch2}) => __awaiter$5(void 0, void 0, void 0, function* () {
  const response = yield fetch2(`/venues/${page.query.get("venue")}.json`);
  const data = yield response.json();
  return {props: {venue: data.venue}};
});
const Join = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => value);
  (function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let {venue} = $$props;
  let password = "";
  if ($$props.venue === void 0 && $$bindings.venue && venue !== void 0)
    $$bindings.venue(venue);
  $$unsubscribe_session();
  return `








<h1>${escape(venue.name)}</h1>

<section>${``}
    <div><label for="${"passwordInput"}">Venue Password</label>
        <input id="${"passwordInput"}" type="${"password"}"${add_attribute("value", password, 1)}>
        ${validate_component(Button, "Button").$$render($$result, {variant: "primary"}, {}, {default: () => `Submit`})}</div></section>`;
});
var join = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Join,
  load: load$7
});
var __layout_svelte_svelte_type_style_lang = "#venueHeader.svelte-qnj26h.svelte-qnj26h{height:100px;margin-bottom:30px}#venueNav.svelte-qnj26h.svelte-qnj26h{flex:auto;display:flex;flex-direction:row;justify-content:center}#venueNav.svelte-qnj26h a.svelte-qnj26h{display:block;margin:auto 20px;font-size:28px}";
const css$4 = {
  code: "#venueHeader.svelte-qnj26h.svelte-qnj26h{height:100px;margin-bottom:30px}#venueNav.svelte-qnj26h.svelte-qnj26h{flex:auto;display:flex;flex-direction:row;justify-content:center}#venueNav.svelte-qnj26h a.svelte-qnj26h{display:block;margin:auto 20px;font-size:28px}",
  map: '{"version":3,"file":"__layout.svelte","sources":["__layout.svelte"],"sourcesContent":["<script context=\\"module\\" lang=\\"ts\\">export const load = ({ session }) => {\\r\\n    if (!session.user) {\\r\\n        return {\\r\\n            status: 302,\\r\\n            redirect: \'/login\'\\r\\n        };\\r\\n    }\\r\\n    return {\\r\\n        props: {}\\r\\n    };\\r\\n};\\r\\n</script>\\r\\n\\r\\n<!-- ****** Logic ****** -->\\r\\n<script lang=\\"ts\\">import { session } from \'$app/stores\';\\r\\n;\\r\\n</script>\\r\\n\\r\\n<!-- ****** Styling ****** -->\\r\\n<style>\\r\\n    #venueHeader {\\r\\n        height: 100px;\\r\\n        margin-bottom: 30px;\\r\\n    }\\r\\n    #venueNav {\\r\\n        flex: auto;\\r\\n        display: flex;\\r\\n        flex-direction: row;\\r\\n        justify-content: center;\\r\\n    }\\r\\n    #venueNav a {\\r\\n        display: block;\\r\\n        margin: auto 20px;\\r\\n        font-size: 28px;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<!-- ****** Markup ****** -->\\r\\n<section id=\\"venueHeader\\">\\r\\n    {#if $session.venue}\\r\\n        <h1><a href={`/venues/${$session.venue.route}`}>{$session.venue.name}</a></h1>\\r\\n\\r\\n        <nav id=\'venueNav\'>\\r\\n            <a sveltekit:prefetch href={`/venues/${$session.venue.route}/posts`} >Posts</a>\\r\\n            <a sveltekit:prefetch href={`/venues/${$session.venue.route}/gallery`}>Gallery</a>\\r\\n            <a sveltekit:prefetch href={`/venues/${$session.venue.route}/articles`}>Articles</a>\\r\\n            <a sveltekit:prefetch href={`/venues/${$session.venue.route}/lists`}>Lists</a>\\r\\n            <a sveltekit:prefetch href={`/venues/${$session.venue.route}/reading`}>Reading</a>\\r\\n        </nav>\\r\\n    {/if}\\r\\n</section>\\r\\n\\r\\n<slot></slot>"],"names":[],"mappings":"AAoBI,YAAY,4BAAC,CAAC,AACV,MAAM,CAAE,KAAK,CACb,aAAa,CAAE,IAAI,AACvB,CAAC,AACD,SAAS,4BAAC,CAAC,AACP,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,MAAM,AAC3B,CAAC,AACD,uBAAS,CAAC,CAAC,cAAC,CAAC,AACT,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,SAAS,CAAE,IAAI,AACnB,CAAC"}'
};
const load$6 = ({session: session2}) => {
  if (!session2.user) {
    return {status: 302, redirect: "/login"};
  }
  return {props: {}};
};
const _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $session, $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => $session = value);
  $$result.css.add(css$4);
  $$unsubscribe_session();
  return `






<section id="${"venueHeader"}" class="${"svelte-qnj26h"}">${$session.venue ? `<h1><a${add_attribute("href", `/venues/${$session.venue.route}`, 0)}>${escape($session.venue.name)}</a></h1>

        <nav id="${"venueNav"}" class="${"svelte-qnj26h"}"><a sveltekit:prefetch${add_attribute("href", `/venues/${$session.venue.route}/posts`, 0)} class="${"svelte-qnj26h"}">Posts</a>
            <a sveltekit:prefetch${add_attribute("href", `/venues/${$session.venue.route}/gallery`, 0)} class="${"svelte-qnj26h"}">Gallery</a>
            <a sveltekit:prefetch${add_attribute("href", `/venues/${$session.venue.route}/articles`, 0)} class="${"svelte-qnj26h"}">Articles</a>
            <a sveltekit:prefetch${add_attribute("href", `/venues/${$session.venue.route}/lists`, 0)} class="${"svelte-qnj26h"}">Lists</a>
            <a sveltekit:prefetch${add_attribute("href", `/venues/${$session.venue.route}/reading`, 0)} class="${"svelte-qnj26h"}">Reading</a></nav>` : ``}</section>

${slots.default ? slots.default({}) : ``}`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout,
  load: load$6
});
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$5 = ({session: session2}) => __awaiter$4(void 0, void 0, void 0, function* () {
  const venue = session2.venue;
  return {props: {venue}};
});
const U5Bvenueu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $session, $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => $session = value);
  $$unsubscribe_session();
  return `








<h2>Welcome ${escape($session.user.name)}</h2>`;
});
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5Bvenueu5D,
  load: load$5
});
function sortNewest(array) {
  array.sort((a, b2) => new Date(b2.datetime).valueOf() - new Date(a.datetime).valueOf());
  return array;
}
var index_svelte_svelte_type_style_lang$3 = "#newArticle.svelte-1eumhpq{display:flex;flex-direction:column;text-align:left;gap:10px;margin-bottom:20px}#feed.svelte-1eumhpq{display:flex;flex-direction:column;gap:20px}article.svelte-1eumhpq{display:flex;flex-direction:row}.articleImage.svelte-1eumhpq{width:100px;height:100px}";
const css$3 = {
  code: "#newArticle.svelte-1eumhpq{display:flex;flex-direction:column;text-align:left;gap:10px;margin-bottom:20px}#feed.svelte-1eumhpq{display:flex;flex-direction:column;gap:20px}article.svelte-1eumhpq{display:flex;flex-direction:row}.articleImage.svelte-1eumhpq{width:100px;height:100px}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<!-- ****** Loading Logic ****** -->\\r\\n<script context=\\"module\\" lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\n;\\r\\nimport { articlesCollection } from '$services/firebase';\\r\\nexport const load = ({ fetch, session }) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    try {\\r\\n        let articles = [];\\r\\n        const snapshot = yield articlesCollection.where('venueId', '==', session.venue.id).get();\\r\\n        const docs = snapshot.docs;\\r\\n        for (let doc of docs) {\\r\\n            let article = (yield doc.data());\\r\\n            article.datetime = new Date(article.datetime);\\r\\n            const previewResponse = yield fetch('articles/preview', {\\r\\n                method: 'post',\\r\\n                credentials: 'include',\\r\\n                headers: { 'Content-Type': 'application/json ' },\\r\\n                body: JSON.stringify({ url: article.href })\\r\\n            });\\r\\n            if (!previewResponse.ok) {\\r\\n                const errorData = yield previewResponse.json();\\r\\n                throw errorData.errors;\\r\\n            }\\r\\n            article.preview = (yield previewResponse.json());\\r\\n            articles.push(article);\\r\\n        }\\r\\n        return {\\r\\n            props: {\\r\\n                articles: articles\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    catch (err) {\\r\\n        return {\\r\\n            props: {\\r\\n                err: err\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n});\\r\\n</script>\\r\\n\\r\\n<!-- ****** Client-side Logic ****** -->\\r\\n<script lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nimport { sortNewest } from '$lib/utils';\\r\\nimport Button from '$lib/components/Button.svelte';\\r\\nimport ErrorAlert from '$lib/components/ErrorAlert.svelte';\\r\\nimport { session } from '$app/stores';\\r\\nexport let err;\\r\\nexport let articles;\\r\\n// console.log(articles);\\r\\nlet newArticleUrl = '';\\r\\nfunction newArticle() {\\r\\n    return __awaiter(this, void 0, void 0, function* () {\\r\\n        try {\\r\\n            const newArticle = {\\r\\n                userId: $session.user.id,\\r\\n                venueId: $session.venue.id,\\r\\n                href: newArticleUrl,\\r\\n                datetime: new Date()\\r\\n            };\\r\\n            const previewResponse = yield fetch('articles/preview', {\\r\\n                method: 'post',\\r\\n                credentials: 'include',\\r\\n                headers: { 'Content-Type': 'application/json ' },\\r\\n                body: JSON.stringify({ url: newArticleUrl })\\r\\n            });\\r\\n            if (!previewResponse.ok) {\\r\\n                const errorData = yield previewResponse.json();\\r\\n                throw errorData.errors;\\r\\n            }\\r\\n            newArticle.preview = (yield previewResponse.json());\\r\\n            articles = [...articles, newArticle];\\r\\n            fetch('articles.json', {\\r\\n                method: 'post',\\r\\n                credentials: 'include',\\r\\n                headers: { 'Content-Type': 'application/json ' },\\r\\n                body: JSON.stringify(newArticle)\\r\\n            }).then((response) => response.json())\\r\\n                .then(data => {\\r\\n                if (data.errors)\\r\\n                    throw data.errors;\\r\\n                console.log(data);\\r\\n            });\\r\\n        }\\r\\n        catch (error) {\\r\\n            err = error;\\r\\n        }\\r\\n    });\\r\\n}\\r\\n</script>\\r\\n\\r\\n<!-- ****** Markup ****** -->\\r\\n<h1>Articles</h1>\\r\\n\\r\\n{#if err}\\r\\n    <ErrorAlert>{err}</ErrorAlert>\\r\\n{/if}\\r\\n\\r\\n<section id=\\"newArticle\\">\\r\\n\\t<form id=\\"newPostForm\\" on:submit|preventDefault={newArticle}>\\r\\n\\t\\t<div id=\\"titleSection\\">\\r\\n\\t\\t\\t<label for=\\"articleUrl\\">URL</label>\\r\\n\\t\\t\\t<input\\r\\n\\t\\t\\t\\tid=\\"articleUrl\\"\\r\\n\\t\\t\\t\\tbind:value={newArticleUrl}\\r\\n\\t\\t\\t\\ttype=\\"text\\"\\r\\n\\t\\t\\t\\tplaceholder=\\"Paste the address of the article...\\"\\r\\n\\t\\t\\t/>\\r\\n\\t\\t</div>\\r\\n\\t\\t<div id=\\"newPostButtons\\">\\r\\n\\t\\t\\t<Button variant=\\"primary\\" type=\\"submit\\">Post</Button>\\r\\n\\t\\t</div>\\r\\n\\t</form>\\r\\n</section>\\r\\n\\r\\n<section id=\\"feed\\">\\r\\n\\t{#each sortNewest(articles) as article}\\r\\n\\t\\t<article>\\r\\n\\t\\t\\t<div class=\\"articleImage\\">\\r\\n\\t\\t\\t\\t<img\\r\\n\\t\\t\\t\\t\\tsrc={article.preview?.images?.length > 0 ? article.preview.images[0] : ''}\\r\\n\\t\\t\\t\\t\\talt={article.preview.title}\\r\\n\\t\\t\\t\\t\\twidth=\\"100\\"\\r\\n\\t\\t\\t\\t/>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"articleInfo\\">\\r\\n\\t\\t\\t\\t<h4>{article.preview.title}</h4>\\r\\n\\t\\t\\t\\t<p>{article.preview.description}</p>\\r\\n\\t\\t\\t\\t<a href={article.href} target=\\"_blank\\">Visit</a>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</article>\\r\\n\\t{/each}\\r\\n</section>\\r\\n\\r\\n<!-- ****** Styling ****** -->\\r\\n<style>\\r\\n\\t#newArticle {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\ttext-align: left;\\r\\n\\t\\tgap: 10px;\\r\\n\\t\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n\\t#feed {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tgap: 20px;\\r\\n\\t}\\r\\n\\tarticle {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: row;\\r\\n\\t}\\r\\n\\t.articleImage {\\r\\n\\t\\twidth: 100px;\\r\\n\\t\\theight: 100px;\\r\\n\\t}\\r\\n</style>\\r\\n"],"names":[],"mappings":"AAwJC,WAAW,eAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,UAAU,CAAE,IAAI,CAChB,GAAG,CAAE,IAAI,CACT,aAAa,CAAE,IAAI,AACpB,CAAC,AACD,KAAK,eAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,GAAG,CAAE,IAAI,AACV,CAAC,AACD,OAAO,eAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,AACpB,CAAC,AACD,aAAa,eAAC,CAAC,AACd,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACd,CAAC"}`
};
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$4 = ({fetch: fetch2, session: session2}) => __awaiter$3(void 0, void 0, void 0, function* () {
  try {
    let articles = [];
    const snapshot = yield articlesCollection.where("venueId", "==", session2.venue.id).get();
    const docs = snapshot.docs;
    for (let doc of docs) {
      let article = yield doc.data();
      article.datetime = new Date(article.datetime);
      const previewResponse = yield fetch2("articles/preview", {
        method: "post",
        credentials: "include",
        headers: {"Content-Type": "application/json "},
        body: JSON.stringify({url: article.href})
      });
      if (!previewResponse.ok) {
        const errorData = yield previewResponse.json();
        throw errorData.errors;
      }
      article.preview = yield previewResponse.json();
      articles.push(article);
    }
    return {props: {articles}};
  } catch (err) {
    return {props: {err}};
  }
});
const Articles = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => value);
  (function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let {err} = $$props;
  let {articles} = $$props;
  let newArticleUrl = "";
  if ($$props.err === void 0 && $$bindings.err && err !== void 0)
    $$bindings.err(err);
  if ($$props.articles === void 0 && $$bindings.articles && articles !== void 0)
    $$bindings.articles(articles);
  $$result.css.add(css$3);
  $$unsubscribe_session();
  return `






<h1>Articles</h1>

${err ? `${validate_component(ErrorAlert, "ErrorAlert").$$render($$result, {}, {}, {default: () => `${escape(err)}`})}` : ``}

<section id="${"newArticle"}" class="${"svelte-1eumhpq"}"><form id="${"newPostForm"}"><div id="${"titleSection"}"><label for="${"articleUrl"}">URL</label>
			<input id="${"articleUrl"}" type="${"text"}" placeholder="${"Paste the address of the article..."}"${add_attribute("value", newArticleUrl, 1)}></div>
		<div id="${"newPostButtons"}">${validate_component(Button, "Button").$$render($$result, {variant: "primary", type: "submit"}, {}, {default: () => `Post`})}</div></form></section>

<section id="${"feed"}" class="${"svelte-1eumhpq"}">${each(sortNewest(articles), (article) => {
    var _a2, _b;
    return `<article class="${"svelte-1eumhpq"}"><div class="${"articleImage svelte-1eumhpq"}"><img${add_attribute("src", ((_b = (_a2 = article.preview) == null ? void 0 : _a2.images) == null ? void 0 : _b.length) > 0 ? article.preview.images[0] : "", 0)}${add_attribute("alt", article.preview.title, 0)} width="${"100"}"></div>
			<div class="${"articleInfo"}"><h4>${escape(article.preview.title)}</h4>
				<p>${escape(article.preview.description)}</p>
				<a${add_attribute("href", article.href, 0)} target="${"_blank"}">Visit</a></div>
		</article>`;
  })}</section>

`;
});
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Articles,
  load: load$4
});
var index_svelte_svelte_type_style_lang$2 = "#gallery.svelte-3xdcj1{display:flex;flex-direction:column;gap:30px\r\n    }";
const css$2 = {
  code: "#gallery.svelte-3xdcj1{display:flex;flex-direction:column;gap:30px\r\n    }",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<!-- ****** Logic ****** -->\\r\\n<script context=\\"module\\" lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\n;\\r\\n;\\r\\nexport const load = ({ fetch, session }) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    try {\\r\\n        const galleryResponse = yield fetch(\`/images/venues/\${session.venue.route}.json\`);\\r\\n        if (!galleryResponse.ok) {\\r\\n            const errorData = yield galleryResponse.json();\\r\\n            throw errorData.errors;\\r\\n        }\\r\\n        const gallery = yield galleryResponse.json();\\r\\n        return {\\r\\n            props: {\\r\\n                gallery: gallery\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    catch (err) {\\r\\n        return {\\r\\n            props: {\\r\\n                err: err\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n});\\r\\n</script>\\r\\n\\r\\n<script lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nimport { session } from '$app/stores';\\r\\nimport Button from '$lib/components/Button.svelte';\\r\\nimport ErrorAlert from '$lib/components/ErrorAlert.svelte';\\r\\nexport let err;\\r\\n//Gallery\\r\\nexport let gallery;\\r\\nlet images = (gallery === null || gallery === void 0 ? void 0 : gallery.resources.map(r => r)) || [];\\r\\n$: sortedImages = images.sort((a, b) => new Date(b.created_at).valueOf() - new Date(a.created_at).valueOf());\\r\\n// Image uploading\\r\\nlet files;\\r\\n$: preview = files && files.length > 0 ? URL.createObjectURL(files[0]) : '';\\r\\nfunction uploadImage() {\\r\\n    return __awaiter(this, void 0, void 0, function* () {\\r\\n        try {\\r\\n            let formdata = new FormData();\\r\\n            formdata.append('file', files.item(0));\\r\\n            formdata.append('upload_preset', 'wine-pottle');\\r\\n            formdata.append('folder', 'WinePottle');\\r\\n            formdata.append('tags', $session.venue.route);\\r\\n            let response = yield fetch(\`https://api.cloudinary.com/v1_1/dkj7bctqg/image/upload\`, {\\r\\n                method: 'post',\\r\\n                body: formdata\\r\\n            });\\r\\n            if (!response.ok) {\\r\\n                throw yield response.json();\\r\\n            }\\r\\n            let data = yield response.json();\\r\\n            images = [...images, data];\\r\\n        }\\r\\n        catch (error) {\\r\\n            err = error;\\r\\n        }\\r\\n    });\\r\\n}\\r\\n</script>\\r\\n\\r\\n<!-- ****** Styling ****** -->\\r\\n<style>\\r\\n    #gallery {\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        gap: 30px\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<!-- ****** Markup ****** -->\\r\\n<h1>Gallery</h1>\\r\\n\\r\\n<form id=\\"uploadForm\\" on:submit|preventDefault={uploadImage} >\\r\\n    <label for=\\"imageUpload\\">Upload Image</label>\\r\\n    <input type=\\"file\\" id=\\"imageUpload\\" accept=\\"image/*\\" bind:files />\\r\\n\\r\\n    <div id=\\"preview\\">\\r\\n        <img src={preview} alt=\\"Preview\\" height=\\"100px\\" />\\r\\n    </div>\\r\\n    <div id=\\"uploadButtonContainer\\">\\r\\n        <Button type='submit'>Upload</Button>\\r\\n    </div>\\r\\n</form>\\r\\n\\r\\n{#if err}\\r\\n    <ErrorAlert>{err}</ErrorAlert>\\r\\n{/if}\\r\\n\\r\\n<div id=\\"gallery\\">\\r\\n    {#each sortedImages as image}\\r\\n        <picture>\\r\\n            <img src={image.secure_url} alt={image.public_id} loading=\\"lazy\\" />\\r\\n        </picture>\\r\\n    {/each}\\r\\n</div>"],"names":[],"mappings":"AAmFI,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,GAAG,CAAE,IAAI;IACb,CAAC"}`
};
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$3 = ({fetch: fetch2, session: session2}) => __awaiter$2(void 0, void 0, void 0, function* () {
  try {
    const galleryResponse = yield fetch2(`/images/venues/${session2.venue.route}.json`);
    if (!galleryResponse.ok) {
      const errorData = yield galleryResponse.json();
      throw errorData.errors;
    }
    const gallery = yield galleryResponse.json();
    return {props: {gallery}};
  } catch (err) {
    return {props: {err}};
  }
});
const Gallery = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let sortedImages;
  let preview2;
  let $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => value);
  (function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let {err} = $$props;
  let {gallery} = $$props;
  let images = (gallery === null || gallery === void 0 ? void 0 : gallery.resources.map((r2) => r2)) || [];
  if ($$props.err === void 0 && $$bindings.err && err !== void 0)
    $$bindings.err(err);
  if ($$props.gallery === void 0 && $$bindings.gallery && gallery !== void 0)
    $$bindings.gallery(gallery);
  $$result.css.add(css$2);
  sortedImages = images.sort((a, b2) => new Date(b2.created_at).valueOf() - new Date(a.created_at).valueOf());
  preview2 = "";
  $$unsubscribe_session();
  return `








<h1>Gallery</h1>

<form id="${"uploadForm"}"><label for="${"imageUpload"}">Upload Image</label>
    <input type="${"file"}" id="${"imageUpload"}" accept="${"image/*"}">

    <div id="${"preview"}"><img${add_attribute("src", preview2, 0)} alt="${"Preview"}" height="${"100px"}"></div>
    <div id="${"uploadButtonContainer"}">${validate_component(Button, "Button").$$render($$result, {type: "submit"}, {}, {default: () => `Upload`})}</div></form>

${err ? `${validate_component(ErrorAlert, "ErrorAlert").$$render($$result, {}, {}, {default: () => `${escape(err)}`})}` : ``}

<div id="${"gallery"}" class="${"svelte-3xdcj1"}">${each(sortedImages, (image) => `<picture><img${add_attribute("src", image.secure_url, 0)}${add_attribute("alt", image.public_id, 0)} loading="${"lazy"}">
        </picture>`)}</div>`;
});
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Gallery,
  load: load$3
});
const Reading = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<h1>Reading</h1>`;
});
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Reading
});
var index_svelte_svelte_type_style_lang$1 = "#newList.svelte-ko7vyc{display:flex;flex-direction:column;text-align:left;gap:10px;margin-bottom:20px}#feed.svelte-ko7vyc{display:flex;flex-direction:column;gap:20px}article.svelte-ko7vyc{border:1px solid black;border-radius:5px}";
const css$1 = {
  code: "#newList.svelte-ko7vyc{display:flex;flex-direction:column;text-align:left;gap:10px;margin-bottom:20px}#feed.svelte-ko7vyc{display:flex;flex-direction:column;gap:20px}article.svelte-ko7vyc{border:1px solid black;border-radius:5px}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<!-- ****** Loading Logic ****** -->\\r\\n<script context=\\"module\\" lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nimport { winelistCollection } from '$services/firebase';\\r\\n;\\r\\nexport const load = ({ session }) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    try {\\r\\n        const wineLists = [];\\r\\n        const snapshot = yield winelistCollection.where('venueId', '==', session.venue.id).get();\\r\\n        if (!snapshot.empty) {\\r\\n            for (let doc of snapshot.docs) {\\r\\n                wineLists.push(yield doc.data());\\r\\n            }\\r\\n        }\\r\\n        //console.log(wineLists);\\r\\n        return {\\r\\n            props: {\\r\\n                wineLists: wineLists\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    catch (err) {\\r\\n        return {\\r\\n            props: {\\r\\n                err: err\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n});\\r\\n</script>\\r\\n\\r\\n<!-- ****** Client-side Logic ****** -->\\r\\n<script lang=\\"ts\\">import { session } from '$app/stores';\\r\\nimport { sortNewest } from '$lib/utils';\\r\\nimport Button from '$lib/components/Button.svelte';\\r\\nimport ErrorAlert from '$lib/components/ErrorAlert.svelte';\\r\\nexport let err;\\r\\nexport let wineLists = [];\\r\\n//console.log(wineLists);\\r\\nlet newListUrl;\\r\\nlet venueName;\\r\\nlet note;\\r\\nfunction addList() {\\r\\n    try {\\r\\n        const newWineList = {\\r\\n            userId: $session.user.id,\\r\\n            venueId: $session.venue.id,\\r\\n            listVenueName: venueName,\\r\\n            href: newListUrl,\\r\\n            note: note,\\r\\n            datetime: new Date()\\r\\n        };\\r\\n        wineLists = [...wineLists, newWineList];\\r\\n        fetch('lists.json', {\\r\\n            method: 'post',\\r\\n            credentials: 'include',\\r\\n            headers: { 'Content-Type': 'application/json' },\\r\\n            body: JSON.stringify(newWineList)\\r\\n        }).then((response) => response.json())\\r\\n            .then(data => {\\r\\n            if (data.errors)\\r\\n                throw data.errors;\\r\\n            console.log(data);\\r\\n        });\\r\\n    }\\r\\n    catch (error) {\\r\\n        err = error;\\r\\n    }\\r\\n}\\r\\n</script>\\r\\n\\r\\n<!-- ****** Markup ****** -->\\r\\n<h1>Wine Lists</h1>\\r\\n\\r\\n{#if err}\\r\\n    <ErrorAlert>{err}</ErrorAlert>\\r\\n{/if}\\r\\n\\r\\n<section id=\\"newList\\">\\r\\n    <form id=\\"newListForm\\" on:submit|preventDefault={addList}>\\r\\n        <div>\\r\\n            <label for=\\"venueName\\">Venue</label>\\r\\n            <input id=\\"venueName\\" bind:value={venueName} type=\\"text\\" />\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\"newListUrl\\">Link</label>\\r\\n            <input id=\\"newListUrl\\" bind:value={newListUrl} type=\\"text\\" />\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\"note\\">Note</label>\\r\\n            <textarea id=\\"note\\" bind:value={note} rows=\\"5\\" cols=\\"45\\" ></textarea>\\r\\n        </div>\\r\\n        <div>\\r\\n            <Button variant=\\"primary\\" type=\\"submit\\">Post</Button>\\r\\n        </div>\\r\\n    </form>\\r\\n</section>\\r\\n\\r\\n<section id=\\"feed\\">\\r\\n\\t{#each sortNewest(wineLists) as list}\\r\\n\\t\\t<article>\\r\\n\\t\\t\\t<h4>{list.listVenueName}</h4>\\r\\n            <a href={list.href} target=\\"_blank\\">Open</a>\\r\\n            <p>{list.note}</p>\\r\\n\\t\\t</article>\\r\\n\\t{/each}\\r\\n</section>\\r\\n\\r\\n<!-- ****** Styling ****** -->\\r\\n<style>\\r\\n    #newList {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\ttext-align: left;\\r\\n\\t\\tgap: 10px;\\r\\n\\t\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n\\t#feed {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tgap: 20px;\\r\\n\\t}\\r\\n    article {\\r\\n        border: 1px solid black;\\r\\n        border-radius: 5px;\\r\\n    }\\r\\n</style>\\r\\n"],"names":[],"mappings":"AAqHI,QAAQ,cAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,UAAU,CAAE,IAAI,CAChB,GAAG,CAAE,IAAI,CACT,aAAa,CAAE,IAAI,AACpB,CAAC,AACD,KAAK,cAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,GAAG,CAAE,IAAI,AACV,CAAC,AACE,OAAO,cAAC,CAAC,AACL,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,aAAa,CAAE,GAAG,AACtB,CAAC"}`
};
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$2 = ({session: session2}) => __awaiter$1(void 0, void 0, void 0, function* () {
  try {
    const wineLists = [];
    const snapshot = yield winelistCollection.where("venueId", "==", session2.venue.id).get();
    if (!snapshot.empty) {
      for (let doc of snapshot.docs) {
        wineLists.push(yield doc.data());
      }
    }
    return {props: {wineLists}};
  } catch (err) {
    return {props: {err}};
  }
});
const Lists = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => value);
  let {err} = $$props;
  let {wineLists = []} = $$props;
  let newListUrl;
  let venueName;
  if ($$props.err === void 0 && $$bindings.err && err !== void 0)
    $$bindings.err(err);
  if ($$props.wineLists === void 0 && $$bindings.wineLists && wineLists !== void 0)
    $$bindings.wineLists(wineLists);
  $$result.css.add(css$1);
  $$unsubscribe_session();
  return `






<h1>Wine Lists</h1>

${err ? `${validate_component(ErrorAlert, "ErrorAlert").$$render($$result, {}, {}, {default: () => `${escape(err)}`})}` : ``}

<section id="${"newList"}" class="${"svelte-ko7vyc"}"><form id="${"newListForm"}"><div><label for="${"venueName"}">Venue</label>
            <input id="${"venueName"}" type="${"text"}"${add_attribute("value", venueName, 1)}></div>
        <div><label for="${"newListUrl"}">Link</label>
            <input id="${"newListUrl"}" type="${"text"}"${add_attribute("value", newListUrl, 1)}></div>
        <div><label for="${"note"}">Note</label>
            <textarea id="${"note"}" rows="${"5"}" cols="${"45"}">${""}</textarea></div>
        <div>${validate_component(Button, "Button").$$render($$result, {variant: "primary", type: "submit"}, {}, {default: () => `Post`})}</div></form></section>

<section id="${"feed"}" class="${"svelte-ko7vyc"}">${each(sortNewest(wineLists), (list) => `<article class="${"svelte-ko7vyc"}"><h4>${escape(list.listVenueName)}</h4>
            <a${add_attribute("href", list.href, 0)} target="${"_blank"}">Open</a>
            <p>${escape(list.note)}</p>
		</article>`)}</section>

`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Lists,
  load: load$2
});
var index_svelte_svelte_type_style_lang = "#compose.svelte-7wyeu4{display:flex;flex-direction:column;text-align:left;gap:10px;margin-bottom:20px}#titleSection.svelte-7wyeu4{display:flex;align-items:center;gap:10px}#newPostButtons.svelte-7wyeu4{display:flex;flex-direction:row;justify-content:flex-end;gap:10px}#feed.svelte-7wyeu4{display:flex;flex-direction:column;gap:20px}";
const css = {
  code: "#compose.svelte-7wyeu4{display:flex;flex-direction:column;text-align:left;gap:10px;margin-bottom:20px}#titleSection.svelte-7wyeu4{display:flex;align-items:center;gap:10px}#newPostButtons.svelte-7wyeu4{display:flex;flex-direction:row;justify-content:flex-end;gap:10px}#feed.svelte-7wyeu4{display:flex;flex-direction:column;gap:20px}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\" lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\n;\\r\\nexport const load = ({ session, fetch }) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    try {\\r\\n        const response = yield fetch('posts.json?venueId=' + session.venue.id);\\r\\n        if (!response.ok) {\\r\\n            const errorData = yield response.json();\\r\\n            throw errorData.errors;\\r\\n        }\\r\\n        const { posts } = yield response.json();\\r\\n        posts.forEach(p => p.datetime = new Date(p.datetime));\\r\\n        return {\\r\\n            props: {\\r\\n                posts: posts\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    catch (err) {\\r\\n        return {\\r\\n            props: {\\r\\n                err: err\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n});\\r\\n</script>\\r\\n\\r\\n<script lang=\\"ts\\">import Card from \\"$lib/components/Card.svelte\\";\\r\\nimport Button from '$lib/components/Button.svelte';\\r\\nimport ErrorAlert from '$lib/components/ErrorAlert.svelte';\\r\\nimport { session } from \\"$app/stores\\";\\r\\nimport { sortNewest } from \\"$lib/utils\\";\\r\\nexport let err;\\r\\nexport let posts;\\r\\nlet title = '';\\r\\nlet content = '';\\r\\nfunction newPost() {\\r\\n    try {\\r\\n        const newPost = {\\r\\n            author: $session.user.name,\\r\\n            title: title,\\r\\n            content: content,\\r\\n            datetime: new Date(),\\r\\n            userId: $session.user.id,\\r\\n            venueId: $session.venue.id\\r\\n        };\\r\\n        posts = [...posts, newPost];\\r\\n        fetch('posts.json', {\\r\\n            method: 'post',\\r\\n            credentials: 'include',\\r\\n            headers: { 'Content-Type': 'application/json ' },\\r\\n            body: JSON.stringify({ newPost })\\r\\n        }).then(response => response.json())\\r\\n            .then(data => {\\r\\n            if (data.errors)\\r\\n                throw data.errors;\\r\\n            newPost.id = data.postId;\\r\\n        });\\r\\n    }\\r\\n    catch (error) {\\r\\n        err = error;\\r\\n    }\\r\\n}\\r\\n</script>\\r\\n\\r\\n<style>\\r\\n    #compose {\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        text-align: left;\\r\\n        gap: 10px;\\r\\n        margin-bottom: 20px;\\r\\n    }\\r\\n    #titleSection {\\r\\n        display: flex;\\r\\n        align-items: center;\\r\\n        gap: 10px;\\r\\n    }\\r\\n    #newPostButtons {\\r\\n        display: flex;\\r\\n        flex-direction: row;\\r\\n        justify-content: flex-end;\\r\\n        gap: 10px;\\r\\n    }\\r\\n    #feed {\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        gap: 20px;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<h2>Posts</h2>\\r\\n\\r\\n{#if err}\\r\\n    <ErrorAlert>{err}</ErrorAlert>\\r\\n{/if}\\r\\n\\r\\n<section id=\\"compose\\">\\r\\n    <form id=\\"newPostForm\\" on:submit|preventDefault={newPost}>\\r\\n        <div id=\\"titleSection\\">\\r\\n            <label for=\\"newPostTitle\\">Title</label>\\r\\n            <input id=\\"newPostTitle\\" bind:value={title} type=\\"text\\" placeholder=\\"Give your post a title...\\" />\\r\\n        </div>\\r\\n        <div id=\\"contentSection\\">\\r\\n            <textarea id=\\"newPostContent\\" rows=\\"5\\" cols=\\"45\\" placeholder=\\"Write a new post...\\" bind:value={content}></textarea>\\r\\n        </div>\\r\\n        <div id=\\"newPostButtons\\">\\r\\n            <Button variant=\\"secondary\\" type=\\"reset\\">Clear</Button>\\r\\n            <Button variant=\\"primary\\" type=\\"submit\\">Post</Button>\\r\\n        </div>\\r\\n    </form>\\r\\n</section>\\r\\n\\r\\n<section id=\\"feed\\">\\r\\n    {#each sortNewest(posts) as post}\\r\\n        <Card title={post.title}>\\r\\n            <strong>{post.author}</strong>\\r\\n            <i>{post.datetime.toLocaleDateString()}</i>\\r\\n            <p>{post.content}</p>\\r\\n        </Card>\\r\\n    {/each}\\r\\n</section>"],"names":[],"mappings":"AA0EI,QAAQ,cAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,UAAU,CAAE,IAAI,CAChB,GAAG,CAAE,IAAI,CACT,aAAa,CAAE,IAAI,AACvB,CAAC,AACD,aAAa,cAAC,CAAC,AACX,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,GAAG,CAAE,IAAI,AACb,CAAC,AACD,eAAe,cAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,QAAQ,CACzB,GAAG,CAAE,IAAI,AACb,CAAC,AACD,KAAK,cAAC,CAAC,AACH,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,GAAG,CAAE,IAAI,AACb,CAAC"}`
};
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const load$1 = ({session: session2, fetch: fetch2}) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const response = yield fetch2("posts.json?venueId=" + session2.venue.id);
    if (!response.ok) {
      const errorData = yield response.json();
      throw errorData.errors;
    }
    const {posts} = yield response.json();
    posts.forEach((p2) => p2.datetime = new Date(p2.datetime));
    return {props: {posts}};
  } catch (err) {
    return {props: {err}};
  }
});
const Posts = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => value);
  let {err} = $$props;
  let {posts} = $$props;
  let title = "";
  if ($$props.err === void 0 && $$bindings.err && err !== void 0)
    $$bindings.err(err);
  if ($$props.posts === void 0 && $$bindings.posts && posts !== void 0)
    $$bindings.posts(posts);
  $$result.css.add(css);
  $$unsubscribe_session();
  return `<h2>Posts</h2>

${err ? `${validate_component(ErrorAlert, "ErrorAlert").$$render($$result, {}, {}, {default: () => `${escape(err)}`})}` : ``}

<section id="${"compose"}" class="${"svelte-7wyeu4"}"><form id="${"newPostForm"}"><div id="${"titleSection"}" class="${"svelte-7wyeu4"}"><label for="${"newPostTitle"}">Title</label>
            <input id="${"newPostTitle"}" type="${"text"}" placeholder="${"Give your post a title..."}"${add_attribute("value", title, 1)}></div>
        <div id="${"contentSection"}"><textarea id="${"newPostContent"}" rows="${"5"}" cols="${"45"}" placeholder="${"Write a new post..."}">${""}</textarea></div>
        <div id="${"newPostButtons"}" class="${"svelte-7wyeu4"}">${validate_component(Button, "Button").$$render($$result, {variant: "secondary", type: "reset"}, {}, {default: () => `Clear`})}
            ${validate_component(Button, "Button").$$render($$result, {variant: "primary", type: "submit"}, {}, {default: () => `Post`})}</div></form></section>

<section id="${"feed"}" class="${"svelte-7wyeu4"}">${each(sortNewest(posts), (post2) => `${validate_component(Card, "Card").$$render($$result, {title: post2.title}, {}, {
    default: () => `<strong>${escape(post2.author)}</strong>
            <i>${escape(post2.datetime.toLocaleDateString())}</i>
            <p>${escape(post2.content)}</p>
        `
  })}`)}</section>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Posts,
  load: load$1
});
const load = ({session: session2}) => {
  return {props: {message: "Hello"}};
};
const Login = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $session, $$unsubscribe_session;
  $$unsubscribe_session = subscribe(session, (value) => $session = value);
  let {message} = $$props;
  if ($$props.message === void 0 && $$bindings.message && message !== void 0)
    $$bindings.message(message);
  $$unsubscribe_session();
  return `






<h2>${escape(message)}${escape($session.user ? " " + $session.user.name : "")}!</h2>
${validate_component(Auth, "Auth").$$render($$result, {}, {}, {})}`;
});
var login = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Login,
  load
});
export {init, render};
